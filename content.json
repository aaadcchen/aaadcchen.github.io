{"meta":{"title":"星辰的博客","subtitle":"","description":"","author":"陈斌","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","text":"","path":"/404.html","date":"05-22","excerpt":""},{"title":"书单","text":"","path":"books/index.html","date":"05-22","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"05-22","excerpt":""},{"title":"关于","text":"个人详细介绍 写作很重要。通过写作清晰地表达观点，这很有帮助。从某种程度上来说，写代码和写作非常相似，两种都需要你把你的想法，通过某个结构化的方式清晰并且无歧义的表达出来。Email 当然是写不完的了，不过还有你所开发的产品特性所配套的文档、需要清晰描述 Bug 的漏洞报告、还有对你修复的 Bug 做出的解释。 与其裹紧被子，躲在小屋里抵御风雪，倒不如打点行囊，奔赴遥远南方的温暖春天。 有些文章出自转载，转载的意义并不是说为了凑文章，赶业绩，而是感觉到别人写的那么好，自己也疏于整理，内容无非是一些易忘的小dome，转载出来，自己也方便查阅。 有问题请联系： QQ：2625746496 微信：LightChaser_010","path":"about/index.html","date":"05-22","excerpt":""},{"title":"友情链接","text":"","path":"links/index.html","date":"05-22","excerpt":""},{"title":"Repositories","text":"","path":"repository/index.html","date":"05-22","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"05-22","excerpt":""}],"posts":[{"title":"Mysql基础（黑马程序员视频笔记总结）","text":"Mysql基础（黑马程序员视频笔记总结）通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 DDL（数据定义语言）数据定义语言 数据库操作12345678910111213查询所有数据库：`SHOW DATABASES;`查询当前数据库：`SELECT DATABASE();`创建数据库：`CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];`删除数据库：`DROP DATABASE [ IF EXISTS ] 数据库名;`使用数据库：`USE 数据库名;`##### 注意事项- UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集#### 表操作 数据库表操作 123456查询当前数据库所有表：`SHOW TABLES;`查询表结构：`DESC 表名;`查询指定表的建表语句：`SHOW CREATE TABLE 表名;` 创建表： 12345678CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释])[ COMMENT 表注释 ]; 实例 123456789101112131415161718auto_increment_increment = 1 ，每次插入数据，id++；auto_increment_offset =1 ，说明从1开始。create table user( id int primary key auto_increment comment &#x27;主键&#x27;, name varchar(10) not null unique comment &#x27;姓名&#x27;, age int check ( age &gt; 0 &amp;&amp; age &lt;= 120 ) comment &#x27;年龄&#x27;, status char(1) default &#x27;1&#x27; comment &#x27;状态&#x27;, gender char(1) comment &#x27;性别&#x27;) comment &#x27;用户表&#x27;;或者create table user( id int primary key comment &#x27;主键&#x27;, name varchar(10) not null unique comment &#x27;姓名&#x27;, age int check ( age &gt; 0 &amp;&amp; age &lt;= 120 ) comment &#x27;年龄&#x27;, status char(1) default &#x27;1&#x27; comment &#x27;状态&#x27;, gender char(1) comment &#x27;性别&#x27;)ENGINE=InnoDB AUTO_INCREMENT=704677 DEFAULT CHARSET=utf8 comment &#x27;用户表&#x27;; 最后一个字段后面没有逗号 12345678910111213141516171.添加字段：`ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];`例：`ALTER TABLE emp ADD nickname varchar(20) COMMENT &#x27;昵称&#x27;;`2.修改数据类型：`ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);`3.修改字段名和字段类型：`ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];`例：将emp表的nickname字段修改为username，类型为varchar(30)`ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#x27;昵称&#x27;;`4.删除字段：`ALTER TABLE 表名 DROP 字段名;`5.修改表名：`ALTER TABLE 表名 RENAME TO 新表名`6.删除表：`DROP TABLE [IF EXISTS] 表名;`7.删除表，并重新创建该表：`TRUNCATE TABLE 表名; DML（数据操作语言）添加数据123456789101112指定字段：`INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);`全部字段：`INSERT INTO 表名 VALUES (值1, 值2, ...);`批量添加数据：`INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);``INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);insert into user(name,age,status,gender) values (&#x27;Tom4&#x27;,80,&#x27;1&#x27;,&#x27;男&#x27;);insert into user(name,age,status,gender) values (&#x27;Tom5&#x27;,-1,&#x27;1&#x27;,&#x27;男&#x27;);insert into user(name,age,status,gender) values (&#x27;Tom5&#x27;,121,&#x27;1&#x27;,&#x27;男&#x27;);insert into user(name,age,gender) values (&#x27;Tom5&#x27;,120,&#x27;男&#x27;); 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 更新和删除数据123456修改数据：`UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];`例：`UPDATE emp SET name = &#x27;Jack&#x27; WHERE id = 1;`删除数据：`DELETE FROM 表名 [ WHERE 条件 ]; DQL（数据查询语言）语法： 1234567891011121314SELECT 字段列表FROM 表名字段WHERE 条件列表GROUP BY 分组字段列表HAVING 分组后的条件列表ORDER BY 排序字段列表LIMIT 分页参数 基础查询1234567891011查询多个字段：`SELECT 字段1, 字段2, 字段3, ... FROM 表名;``SELECT * FROM 表名;`设置别名：`SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;``SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;`去除重复记录：`SELECT DISTINCT 字段列表 FROM 表名;`转义：`SELECT * FROM 表名 WHERE name LIKE &#x27;/_张三&#x27; ESCAPE &#x27;/&#x27;`/ 之后的_不作为通配符 条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 &lt;&gt; 或 !&#x3D; 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 &amp;&amp; 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： 123456789101112131415161718192021-- 没有身份证select * from employee where idcard is null or idcard = &#x27;&#x27;;-- 有身份证select * from employee where idcard;select * from employee where idcard is not null;-- 不等于select * from employee where age != 30;-- 年龄在20到30之间select * from employee where age between 20 and 30;select * from employee where age &gt;= 20 and age &lt;= 30;-- 下面语句不报错，但查不到任何信息select * from employee where age between 30 and 20;-- 性别为女且年龄小于30select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;-- 年龄等于25或30或35select * from employee where age = 25 or age = 30 or age = 35;select * from employee where age in (25, 30, 35);-- 姓名为两个字select * from employee where name like &#x27;__&#x27;;-- 身份证最后为Xselect * from employee where idcard like &#x27;%X&#x27;; 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法： 123`SELECT 聚合函数(字段列表) FROM 表名;`例：`SELECT count(id) from employee where workaddress = &quot;广东省&quot;;` 分组查询语法： 12345SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];`where 和 having 的区别：- 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。- 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： 12345678910-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）select count(*) from employee group by gender;-- 根据性别分组，统计男性和女性数量select gender, count(*) from employee group by gender;-- 根据性别分组，统计男性和女性的平均年龄select gender, avg(age) from employee group by gender;-- 年龄小于45，并根据工作地址分组select workaddress, count(*) from employee where age &lt; 45 group by workaddress;-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3; 注意事项 执行顺序：where &gt; 聚合函数 &gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 排序查询语法： 1`SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;` 排序方式： ASC: 升序（默认） DESC: 降序 例子： 12345-- 根据年龄升序排序SELECT * FROM employee ORDER BY age ASC;SELECT * FROM employee ORDER BY age;-- 两字段排序，根据年龄升序排序，入职时间降序排序SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： 12345-- 查询第一页数据，展示10条SELECT * FROM employee LIMIT 0, 10;-- 查询第二页SELECT * FROM employee LIMIT 10, 10;1234 注意事项 起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 DQL执行顺序FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT DCL管理用户查询用户： 123USER mysql;SELECT * FROM user;12 12345678创建用户:`CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;`修改用户密码：`ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;`删除用户：`DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;; 例子： 12345678910-- 创建用户test，只能在当前主机localhost访问create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;-- 创建用户test，能在任意主机访问create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;create user &#x27;test&#x27; identified by &#x27;123456&#x27;;-- 修改密码alter user &#x27;test&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;1234&#x27;;-- 删除用户drop user &#x27;test&#x27;@&#x27;localhost&#x27;;123456789 注意事项 主机名可以使用 % 通配 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库&#x2F;表&#x2F;视图 CREATE 创建数据库&#x2F;表 12345678查询权限：`SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;`授予权限：`GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;`撤销权限：`REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;; 实例： 1234567891011121314151、root登录服务器 进入数据库 mysql -u root -p2、创建数据库 create database shop; shop 为数据库名称3、查看创建数据库 show databases; (小命令 use shop; 进入数据库 show table;)4、创建数据库的用户create user &#x27;shop_user&#x27;@&#x27;%&#x27; identified by &#x27;shop@123&#x27;;&#x27;shop_user&#x27; 用户名称&#x27;shop@123&#x27; 用户密码@后的命令解释&#x27;%&#x27; - 所有情况都能访问&#x27;localhost&#x27; - 本机才能访问&#x27;111.222.33.44&#x27; - 指定 ip 才能访问 5、给予新用户的授予权限grant all/select on 数据库名.数据库表 to 用户名@&#x27;%&#x27; identified by &quot;密码&quot;; 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 函数 字符串函数 数值函数 日期函数 流程函数 字符串函数常用函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 使用示例： 123456789101112131415-- 拼接SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);-- 小写SELECT LOWER(&#x27;Hello&#x27;);-- 大写SELECT UPPER(&#x27;Hello&#x27;);-- 左填充SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- 右填充SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);-- 去除空格SELECT TRIM(&#x27; Hello World &#x27;);-- 切片（起始索引为1）SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5);1234567891011121314 数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x&#x2F;y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子： 123-- DATE_ADDSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);12 流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子： 123456789select name, (case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)from employee;select name, (case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;from employee;12345678 约束分类： 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。 常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子： 12345678create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age &gt; 0 and age &lt; 120), status char(1) default &#x27;1&#x27;, gender char(1));1234567 外键约束添加外键： 12345678910CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);123456789 删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 删除&#x2F;更新行为 行为 说明 NO ACTION 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致） RESTRICT 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致） CASCADE 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录 SET NULL 当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除&#x2F;更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为; 多表查询多表关系 一对多（多对一） 多对多 一对一 一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键 多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） 查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id; 内连接查询内连接查询的是两张表交集的部分 隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; 显式性能比隐式高 例子： 123456-- 查询员工姓名，及关联的部门的名称-- 隐式select e.name, d.name from employee as e, dept as d where e.dept = d.id;-- 显式select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;12345 外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据 右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...; 例子： 123456-- 左select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样-- 右select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;12345 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept 自连接查询当前表与自身的连接查询，自连接必须使用表别名 语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; 自连接查询，可以是内连接查询，也可以是外连接查询 例子： 12345-- 查询员工及其所属领导的名字select a.name, b.name from employee a, employee b where a.manager = b.id;-- 没有领导的也查询出来select a.name, b.name from employee a left join employee b on a.manager = b.id;1234 联合查询 union, union all把多次查询的结果合并，形成一个新的查询集 语法： 1234SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ...123 注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D; 例子： 12345678910-- 查询销售部所有员工select id from dept where name = &#x27;销售部&#x27;;-- 根据销售部部门ID，查询员工信息select * from employee where dept = 4;-- 合并（子查询）select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);-- 查询xxx入职之后的员工信息select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);123456789 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： 1234567-- 查询销售部和市场部的所有员工信息select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);-- 查询比财务部所有人工资都高的员工信息select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));-- 查询比研发部任意一人工资高的员工信息select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;));123456 行子查询返回的结果是一行（可以是多列）。常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN 例子： 1234-- 查询与xxx的薪资及直属领导相同的员工信息select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;);123 表子查询返回的结果是多行多列常用操作符：IN 例子： 12345-- 查询与xxx1，xxx2的职位和薪资相同的员工select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);-- 查询入职日期是2006-01-01之后的员工，及其部门信息select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;1234 事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 基本操作： 123456789101112131415161718192021222324-- 1. 查询张三账户余额select * from account where name = &#x27;张三&#x27;;-- 2. 将张三账户余额-1000update account set money = money - 1000 where name = &#x27;张三&#x27;;-- 此语句出错后张三钱减少但是李四钱没有增加模拟sql语句错误-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = &#x27;李四&#x27;;-- 查看事务提交方式SELECT @@AUTOCOMMIT;-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效SET @@AUTOCOMMIT = 0;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;-- 设置手动提交后上面代码改为：select * from account where name = &#x27;张三&#x27;;update account set money = money - 1000 where name = &#x27;张三&#x27;;update account set money = money + 1000 where name = &#x27;李四&#x27;;commit;1234567891011121314151617181920212223 操作方式二： 123456开启事务：`START TRANSACTION 或 BEGIN TRANSACTION;`提交事务：`COMMIT;`回滚事务：`ROLLBACK;` 操作实例： 123456start transaction;select * from account where name = &#x27;张三&#x27;;update account set money = money - 1000 where name = &#x27;张三&#x27;;update account set money = money + 1000 where name = &#x27;李四&#x27;;commit;12345 四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd 并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × - √表示在当前隔离级别下该问题会出现 - Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别： `SELECT @@TRANSACTION_ISOLATION;` 设置事务隔离级别： `SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;` SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效","path":"2022/08/15/Mysql基础（黑马程序员视频笔记总结）/","date":"08-15","excerpt":"","tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"idea常见插件及maven依赖","text":"[TOC] idea常用快捷键 快捷键 Ctrl +Space（空格） 基本代码补全，输入字母按后列出匹配的词组 Ctrl+Shift+Space 智能代码补全，列出与预期类型一致的方法或变量 Ctrl+Alt+Space 补全类名 Ctrl+Shift+Enter 补全语句 Ctrl+P 显示方法参数 Ctrl+Q 显示注释文档 Ctrl+D 重复上一行 Shift+F1 显示外部文档 Alt+Insert 生成代码，生成 Getter、Setter、构造器等 Ctrl+O 重写父类方法 Ctrl+I 实现接口方法 Ctrl+Alt+T 使用(if..else, try..catch, for, synchronized 等)包围选中语句 Ctrl+&#x2F; 使用“&#x2F;&#x2F;”注释或取消注释 Ctrl+Shift+&#x2F; 使用“&#x2F;** **&#x2F;”注释或取消注释 Alt+Enter 显示快速修复列表 Ctrl+F 查找 F3 查找下一个 Shift+F3 查找上一个 Ctrl+R 替换 Ctrl+Shift+F 目录内查找 Ctrl+Shift+R 目录内替换 Ctrl+Shift+S 语法模板搜索 Ctrl+Shift+M 语法模板替换 IDEA 常用插件1.Hrisey Pluginsidea安装lombok插件后报错：（lombok报错Ambiguous method call. Both）是因为由于IntelliJ IDEA 2018 默认是开启了Hrisey Plugins插件的，与 Lombok Plugins 使用产生了冲突，这里之提供Window下的解决方法：IDEA–》setting—–》Plugins—–》已安装的插件Hrisey Plugins—&gt;禁用重启IDEA便可以 2.MybatisX如何你使用MyBatis-Plus开发，MybatisX插件可谓神器，不仅可以快速帮你从数据生成mapper、xml、entity、service等通用代码（需要在IDEA右侧Database中连接数据库），还可以根据接口方法生成xml中的标签，快速从mapper中方法跳转到xml代码。 3.Properties to YAML ConverterProperties 转yaml文件 EasyCode 自动生成代码插件 教程：https://blog.csdn.net/wang20010104/article/details/124410277 4.LombokLombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter&#x2F;setter，也许还要去写构造器、equals等方法，而且需要维护，当属性多时会出现大量的getter&#x2F;setter方法，这些显得很冗长也没有太多技术含量，一旦修改属性，就容易出现忘记修改对应方法的失误。Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter&#x2F;setter、equals、hashcode、toString方法。 5.MyBatisCodeHelperPro在开发中编写生成bean，mapper，mapper.xml即费时也费力，可以通过MyBatisCodeHelper-Pro自动生成bean，dao，mapper.xml等文件，然后根据自己的需要进行修改。 6.Stackoverflow这个插件其实是最实用的插件，程序猿遇到的问题，基本都能找到回答，但是它使用的是google搜索引擎，对于，不购买vpn的同学来说，感觉好鸡肋呀~ 选中需要搜索的问题，然后，右键点击 7.Mybatis-log-plugin开发的项目一般都少不了日志系统，而我们在书写mysql语句的时候，参数的对应，往往有时候会忽略，mybatis自己控制的参数编译对应，个人感觉有点反人类，我们可以使用这个插件变成自己比较直观的对应~ 选中需要转换的mybatis log日志，然后点击右键，选择Restore sql from slection 8.GsonFormat在与组外或者不同部门对接接口时候发现，有时候对方返回的是JSON对象，自己想要用一个对象去接受，以便于处理后续，此时，需要自己一个个手动去输入属性么，肯定很抓狂，不过咱们可以使用这个插件来解决这个尴尬问题，当然也可以使用外部网址解决，比如bejson这个网站~ 9.Free-idea-mybatismybatis xml和对应的mapper之间来回切换的时候，有时候不同人开发，放置的位置又不同，使用此插件后，来回切换的时候异常方便，和所放置的位置无关~ 10.Maven Helper主要功能如下：查找和排除冲突依赖项的简便方法，为包含当前文件或根模块的模块运行&#x2F;调试maven目标的操作，运行&#x2F;调试当前测试文件的操作 配置文件1.application.yml配置文件12345678910111213141516171819spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-88&amp;allowMultiQueries=true username: root password: password web: resources: static-locations: - file:C:/server: port: 9002 mybatis-plus: mapper-locations: classpath*:/mapper/*Mapper.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启sql日志 map-underscore-to-camel-case: true # 该配置就是将带有下划线的表字段映射为驼峰格式的实体类属性 2.application.properties配置文件12345678910111213141516# 应用名称spring.application.name=test# 应用服务 WEB 访问端口server.port=8085# 数据库驱动：spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据源名称spring.datasource.name=defaultDataSource# 数据库连接地址spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test1?characterEncoding=UTF-8&amp;useUnicode=true&amp;useSSL=false&amp;tinyInt1isBit=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai# 数据库用户名&amp;密码：spring.datasource.username=rootspring.datasource.password=password#输出运行的sql语句命令#mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl Maven工程一.辅助依赖1.测试接口123456&lt;!-- 导入swagger --&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;version&gt;1.5.20&lt;/version&gt; &lt;/dependency&gt; 2.jsoup（爬虫）12345&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.14.3&lt;/version&gt; &lt;/dependency&gt; 3.lombok123456&lt;!--简略get、set方法--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; 5.MySQL12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 6.Json格式转换工具Fastjson12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; 7.Netty12345&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.17.Final&lt;/version&gt; &lt;/dependency&gt; 二.Springboot1.核心依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 2.web12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 3.websevice1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web-services&lt;/artifactId&gt; &lt;/dependency&gt; 4.security1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415161718数据库如果是用mybatis的话，选mybatis和mysql驱动就可以了jdbc api 就是 spring-jdbc 相关的东西data jdbc 是 spring data 的一个项目，是另外一个封装数据库操作的库JDBC规范 &gt; java.sql和javax.sql两个包中的类与接口(天龙八部)：&gt; DataSource:数据源&gt; DriverManager：驱动管理&gt; Driver：JDBC驱动&gt; Connection：数据库连接&gt; Statement：语句，执行SQL&gt; PrepareStatement:预编译语句，性能更好&gt; CallableStatement：调用存储过程&gt; ResultSet：结果集，封装了多条记录&gt; JDBC数据库连接池/Connection Pool&gt; DBCP:apache tomcat内置&gt; c3p0:hibernate&gt; 光-HikariCP：spring boot 5.引入数据库驱动123456&lt;!--引入数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 6.springboot 数据库连接（如果是用mybatis的话，选mybatis和mysql驱动就可以了）123456789&lt;!--springBoot数据库连接 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; 7.mybatisPlus 核心库123456789101112&lt;!-- mybatisPlus 核心库 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatisplus自动生成代码依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; 8.mybatis 核心库12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; 9.thymeleaf模板1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 10.支持热部署123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 11.redis1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- redisson分布式锁 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.16.6&lt;/version&gt;&lt;/dependency&gt; 12.测试引擎1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 13.maven事例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!--springboot版本--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;&lt;!--粘贴替换部分--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;","path":"2022/08/15/idea常见插件及maven依赖/","date":"08-15","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Arduino开发基础","text":"数字端口与模拟端口数字口不区分输入和输出，因为它可以既当输入口用又当输出口用，只需要在使用之前做一个声明便可。数字口和模拟口最大的区别就是，数字口只能输入或输出一个数字0或1（也可以传数据二进制编码的形式），而模拟口可以输入或输出的数据范围为0到1023。例如控制灯的亮灭只需要用0、1控制，定义成数字输出端口。需要具体输出电压就必须使用模拟输出口。 板子数字端口是013，共14个，如果需要，可以将A0A5作为数字端口的1419；A0A5一般作为模拟输入使用~定义模拟端口是 int xxpin&#x3D;A2; 如定义成int xxpin&#x3D;2；是数字端口的2号，只能做逻辑输入，不能做AD转换器信号输入。 1）14个数字接口：数字接口从图上可以看到总共有14个（0～13号)，0号和1号口属于串口通信用的，一般我们不去占用；从2号口到13号口是我们可随意使用的数字接口数字接口可以读取数字信号，也可以输出数字信号，而在2到13号口中带有“～”符号的接口代表它不仅可以输出高电平和低电平信号，也可以输出调制的模拟信号，不带“～”符号的接口就只能输出5V高电平或者0V低电平（这里不深究高低电平的细节，因为事实上对于TTL型的接口高低电平并不严格等于5V和0V，而CMOS型的高低电平则是5V和0V，Arduino上的数字引脚属于TTL型所以严格的讲它们输出的高低电平是有一个误差范围的只要在这个误差范围之内Arduino都认可而不会误判）。输出高电平和低电平很好理解，你可以理解为只能输出5V和0V。 模拟输入口和输出口需要硬件支持，不能一口两用。A0-A5 SS引脚SS是关机&#x2F;同步控制管脚，该引脚可用于同步的一部分，近两倍的基础频率。一个TTL将关闭部分低下来，投入低电流模式。如果不使用同步，该引脚应为正常运行或为正常运行的高或悬空。 VIN引脚● VIN引脚 - 该引脚用于使用外部电源为Arduino Uno开发板供电。电压应控制在上述提到的范围内。 IIC（SCL，SDA）IIC全称为Inter-Integrated Circuit(集成电路总线)。IIC接口只有两根线：SCL，SDA。SCL为同步时钟线，SDA为数据线，通SPI不同的是，数据线为双向接口，也就是说，发送接收都走这根线。 IIC是一种多向控制总线，也就是说多个芯片可以连接到同一总线结构下，同时每个芯片都可以作为实时数据传输的控制源。这种方式简化了信号传输总线接口。 多数EEPROM芯片都是IIC接口，指令有所不同，但是传输格式都是一样的。 SCK、MISO、MOSIVCC代表的电源输入，GND是地，RST是复位脚，SCK、MISO、MOSI这三个引脚是SPI通讯需要的时钟和数据脚。VCC、GND、RST怎么接需要去看单片机对应的用户手册，上面都有典型电路，不同型号的单片机接法是不同的，SCK、MISO、MOSI这三个接到你需要通信的芯片上对应的脚就可以了，但是要注意一点，单片机的MISO要接到芯片上的MOSI SPISPI（Serial Peripheral Interface） 协议是由摩托罗拉公司提出的通讯协议，即串行外围设备接口，是一种高速全双工的通信总线。它被广泛地使用在 ADC、LCD 等设备与 MCU 间，要求通讯速率较高的场合。 芯片的管脚上只占用四根线。（下面会讲到） MISO： 主器件数据输出，从器件数据输入。MOSI：主器件数据输入，从器件数据输出。SCK： 时钟信号，由主设备控制发出。NSS（CS）： 从设备选择信号，由主设备控制。当NSS为低电平则选中 从器件。 SCK（CK），Serial Clock此引脚在主机模式下用于时钟输出，&#x3D;&#x3D;从机模式下用于时钟输入。MISO（SDI），Master In &#x2F; Slave Out data此引脚在从机模式下用于发送数据，主机模式下接收数据。MOSI（SDO）, Master Out &#x2F; Slave In data此引脚在从机模式下用于数据接收，主机模式下发送数据。SS（WS）, Slave select pin根据 SPI 和 SS 设置，此引脚可用于：⌘. 选择从器件进行通信。⌘. 允许多主模式（可以禁止 NSS 引脚输出）。 RX，TX（串口通讯）RX串口接收，TX串口发送实例在最后面 认识Arduino Uno：https://blog.csdn.net/weixin_42645653/article/details/90205369 ESP8266 D1-UNO-R3开发板的初步测试：https://blog.csdn.net/zhuoqingjoking97298/article/details/117458338 SPI 理论知识（通信）：https://blog.csdn.net/m0_57818334/article/details/124884119 ARDUINO UNO开发板介绍：https://blog.csdn.net/weixin_44940488/article/details/121432946 代码理解部分123456789101112131415161718192021222324252627282930313233343536373839/*************************************************# 说明：超声波传感器模块项目，直接运行即可。 ECHO pin 4 TRING Pin 5**************************************************/#include &lt;NewPing.h&gt;#define TRIGGER_PIN 5 // Arduino销与超声波传感器上的触发销相连#define ECHO_PIN 4 // Arduino引脚与超声波传感器上的回波引脚相连。#define MAX_DISTANCE 400 // 我们要ping的最大距离（厘米）。最大传感器距离的额定值为400-500cm。NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE); // 相当于新建初始化实例化一个传感器对象，参数为前面三个变量，新建引脚设置和最大距离。setup()当程序开始执行时，将调用setup()函数，使用此函数①用来初始化变量②管脚模式③调用库函数注意：setup()函数将只运行一次。loop()功能：连续执行函数内的语句void setup() &#123; Serial.begin(9600); //以9600波特打开串行监视器，查看ping结果。 //serial(串口通信) //函数Serial.begin(9600)是设置串口通讯的波特率为9600; //波特率表示单位时间内传送的码元符号的个数，它是对符号传输速率的一种度量，它用单位时间内载波调制状态改变的次数来表示，波特率即指一个单位时间内传输符号的个数。 //Serial.available() 的意思是：返回串口缓冲区中当前剩余的字符个数。一般用这个函数来判断串口的缓冲区有无数据，当Serial.available()&gt;0时，说明串口接收到了数据可以读取； //Serial.read()指从串口的缓冲区取出并读取一个Byte的数据，比如有设备通过串口向Arduino发送数据了，我们就可以用Serial.read()来读取发送的数据。&#125;void loop() &#123; delay(100);// 在两次ping之间等待50毫秒（大约20次ping/秒）。29ms应该是ping之间最短的延迟。//delay(ms)，毫秒级延时函数 unsigned int uS = sonar.ping(); // 发送ping，获取ping时间，单位为微秒（uS）。 Serial.print(&quot;Ping: &quot;); Serial.print(uS / US_ROUNDTRIP_CM); // 将ping时间转换为以厘米为单位的距离，并打印结果（0=超出设置的距离范围） Serial.println(&quot;cm&quot;);&#125; 基础方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566pinMode(pin,mode)功能：配置一个端口为输入或输出端口，无返回值pin：所配引脚的标号，0~13mode：INPUT 输入模式OUTPUT 输出模式INPUT-PULLUP 输入上拉模式输入输出当引脚 13 输出高电平（1）时，LED 将被点亮；输出低电平（0）时，LED 将熄灭。digitalWrite(pin,value)功能：设置一个引脚的输出电压为低电平或高电平，无返回值，需要先将引脚设置为输出引脚pin：所配引脚的标号，0~13value：表示输出电压，LOW为低电平，HIGH为高电平digitalRead(pin)功能：读取外部输入的数字电压值，返回值为int型高电平或低电平的函数，使用前要定义引脚为输出引脚pin：所配引脚的标号，0~13delay(ms)功能：实现毫秒级别的延时ms：无符号长整型delayMicroseconds(us)功能：实现微秒级别的延时us：无符号长整型analogRead(pin)功能：读取指定引脚的模拟电压值pin：模拟电压值的输入引脚，A0~A5返回值为0~1023的整数map(value,fromlow,fromhigh,tolow,tohigh)功能：将一个数据从一个范围映射到另一个范围value：映射的数据[fromlow,fromhigh]：原范围[tolow,tohigh]：映射范围analogWrite(pin,value)功能：在指定引脚输出指定占空比的PWM信号，无返回值pin：输出PWM信号的引脚，仅限数字引脚（即带~的）value：占空比，取值范围为0-255对应0%-100%Serial.begin(speed)功能：串口初始化函数，用来设置串口的波特率。通常只设定一次，在setup函数中使用。speed：表示通信的波特率，通常有：9600、19200、57600、115200PC机默认为9600Serial.print(data)功能：从主板向计算机发送数据data：可发送变量、字符、字符串，默认为十进制Serial.println(data)功能：从主板向计算机发送数据，并在输出后换行data：可发送变量、字符、字符串，默认为十进制Serial.read()功能：读取外部计算机通过串口发给主板的数据该函数不带参数，返回值为串口数据，数据类型为int型Serial.available()功能：用来判断串口是否接收到数据函数返回值为尚未被read读取到的函数的字节数，函数返回值为int型若返回值为0，则说明没有已接收二未被读取的数据1.analogRead()函数读取引脚的模拟量电压值，返回一个0到1023的数值(int型)，表示对应的0到5的电压值。2.analogWrite(pinvalue)，将模拟值(PWM波)输出到引脚，PWM的信号频率约为490赫兹脚位通常会在3、5、6、9、10与11，Value变数范围0-255，而0-255对应的是0-5v电压3.map(value, fromLow,fromHigh,toLow,toHigh)，把一个数从一个范围变换到另一个范围就是将value变数依照fromLow与fromHigh范围，对等转换至toLow与toHigh范围 RX，TX（串口通讯）Dome参考：https://www.freesion.com/article/44641339692/ Serial.begin() 描述：开启串口，通常置于setup()函数中。 原型： Serial.begin(speed) Serial.begin(speed, config) 参数： speed：波特率，一般取值9600,115200等。 config：设置数据位、校验位和停止位。默认SERIAL_8N1表示8个数据位，无校验位，1个停止位。 返回值：无。 Serial.end() 描述：禁止串口传输。此时串口Rx和Tx可以作为数字IO引脚使用。 原型：Serial.end() 参数：无。 返回值：无。 Serial.print() 描述：串口输出数据，写入字符数据到串口。 原型： Serial.print(val) Serial.print(val, format) 参数： val：打印的值，任意数据类型。 config：输出的数据格式。BIN(二进制)、OCT(八进制)、DEC(十进制)、HEX(十六进制)。对于浮点数，此参数指定要使用的小数位数。 示例： Serial.print(78, BIN) 得到 “1001110” Serial.print(78, OCT) 得到 “116” Serial.print(78, DEC) 得到 “78” Serial.print(78, HEX) 得到 “4E” Serial.print(1.23456, 0) 得到 “1” Serial.print(1.23456, 2) 得到 “1.23” Serial.print(1.23456, 4) 得到 “1.2346” Serial.print(‘N’) 得到 “N” Serial.print(“Hello world.”) 得到 “Hello world.” 返回值：返回写入的字节数。 Serial.println() 描述：串口输出数据并换行。 原型： Serial.println(val) Serial.println(val, format) 参数： val：打印的值，任意数据类型。 config：输出的数据格式。 返回值：返回写入的字节数。 Serial.available() 描述：判断串口缓冲区的状态，返回从串口缓冲区读取的字节数。 原型：Serial.available() 参数：无。 返回值：可读取的字节数。 Serial.read() 描述：读取串口数据，一次读一个字符，读完后删除已读数据。 原型：Serial.read() 参数：无。 返回值：返回串口缓存中第一个可读字节，当没有可读数据时返回-1，整数类型。 发生数据方参考：https://www.freesion.com/article/17421166048/ 123456789101112131415161718/* * 串口通信-发送数据方 */int data = 52;void setup() &#123; Serial.begin(9600); //初始化串口 while (!Serial) &#123; //等待串口正常工作 ; &#125; &#125;void loop() &#123; Serial.write(data); //发送数值信息 Serial.println(F(&quot;String test&quot;)); //发送字符信息,为什么加了一个F（），官方文档说的 delay(1000); //延时一下，不然发送的太频繁&#125; 接收数据方入门版入门版没有将数值转换成对应的字符并连接起来 123456789101112131415161718192021/* * 串口通信-接受数据方 */String readdata = &quot;&quot;;void setup() &#123; Serial.begin(9600); //初始化串口 while (!Serial) &#123; //等待串口正常工作 ; &#125; &#125;void loop() &#123; while(Serial.available() &gt; 0) //当串口有数据就读取数据 &#123; Serial.print(&quot;Uno recieve: &quot;);Serial.println(Serial.read()); &#125; delay(100);&#125; 基础版将Ascii数值转换成对应的字符并连接起来，并解决了重复读的问题 1234567891011121314151617181920212223242526/* * 串口通信-接受数据方 */String readdata = &quot;&quot;;void setup() &#123; Serial.begin(9600); //初始化串口 while (!Serial) &#123; //等待串口正常工作 ; &#125; &#125;void loop() &#123; while(Serial.available() &gt; 0) //当串口有数据就读取数据 &#123; readdata = readdata +char(Serial.read()); //将分立的单个数据转化为字符后连接起来 &#125; if(readdata.length() &gt; 0) //有数据才显示 &#123; Serial.print(&quot;Uno recieve: &quot;);Serial.println(readdata); readdata = &quot;&quot;; //清空数据缓存 &#125; delay(100);&#125;","path":"2022/07/19/Arduino开发基础/","date":"07-19","excerpt":"","tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"Netty的通讯与ESP8266（代码）","text":"Netty的通讯与ESP8266（代码）12345NettyServer类NettyServerHandler类NettyClient类NettyClientHandler类ESP8266 通讯测试 NettyServer类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class NettyServer &#123; public static void main(String[] args) throws Exception &#123; //创建BossGroup 和 WorkerGroup //说明 //1. 创建两个线程组 bossGroup 和 workerGroup //2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成 //3. 两个都是无限循环 //4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数 // 默认实际 cpu核数 * 2 EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(8); //8 try &#123; //创建服务器端的启动对象，配置参数 ServerBootstrap bootstrap = new ServerBootstrap(); //使用链式编程来进行设置 bootstrap.group(bossGroup, workerGroup) //设置两个线程组 .channel(NioServerSocketChannel.class) //使用NioSocketChannel 作为服务器的通道实现 .option(ChannelOption.SO_BACKLOG, 128) // 设置线程队列得到连接个数 .childOption(ChannelOption.SO_KEEPALIVE, true) //设置保持活动连接状态// .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; protected void initChannel(SocketChannel ch) throws Exception &#123; System.out.println(&quot;客户socketchannel hashcode=&quot; + ch.hashCode()); //可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue ch.pipeline().addLast(new NettyServerHandler()); &#125;//创建一个通道初始化对象(匿名对象) //给pipeline 设置处理器 &#125;); // 给我们的workerGroup 的 EventLoop 对应的管道设置处理器 System.out.println(&quot;.....服务器 is ready...&quot;); //绑定一个端口并且同步, 生成了一个 ChannelFuture 对象 //启动服务器(并绑定端口) ChannelFuture cf = bootstrap.bind(8087).sync(); //给cf 注册监听器，监控我们关心的事件 /*cf.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; if (cf.isSuccess()) &#123; System.out.println(&quot;监听端口 6668 成功&quot;); &#125; else &#123; System.out.println(&quot;监听端口 6668 失败&quot;); &#125; &#125; &#125;);*/ //对关闭通道进行监听 cf.channel().closeFuture().sync(); &#125;finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; NettyServerHandler类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*说明1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)2. 这时我们自定义一个Handler , 才能称为一个handler */public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123; //读取数据实际(这里我们可以读取客户端发送的消息) /* 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址 2. Object msg: 就是客户端发送的数据 默认Object */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; //比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的 //NIOEventLoop 的 taskQueue中, //解决方案1 用户程序自定义的普通任务 //解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中 /*ctx.channel().eventLoop().execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(5 * 1000); ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;, CharsetUtil.UTF_8)); System.out.println(&quot;channel code=&quot; + ctx.channel().hashCode()); &#125; catch (Exception ex) &#123; System.out.println(&quot;发生异常&quot; + ex.getMessage()); &#125; &#125; &#125;);*/ System.out.println(&quot;go on ...&quot;); System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName() + &quot; channle =&quot; + ctx.channel()); System.out.println(&quot;server ctx =&quot; + ctx); System.out.println(&quot;看看channel 和 pipeline的关系&quot;); Channel channel = ctx.channel(); ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站 //将 msg 转成一个 ByteBuf //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer. ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;客户端发送消息是:&quot; + buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;客户端地址:&quot; + channel.remoteAddress()); &#125; //数据读取完毕 @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; //writeAndFlush 是 write + flush //将数据写入到缓存，并刷新 //一般讲，我们对这个发送的数据进行编码 ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;, CharsetUtil.UTF_8)); &#125; //处理异常, 一般是需要关闭通道 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; ctx.close(); &#125;&#125; NettyClient类 12345678910111213141516171819202122232425262728293031323334public class NettyClient &#123; public static void main(String[] args) throws Exception &#123; //客户端需要一个事件循环组 EventLoopGroup group = new NioEventLoopGroup(); try &#123; //创建客户端启动对象 //注意客户端使用的不是 ServerBootstrap 而是 Bootstrap Bootstrap bootstrap = new Bootstrap(); //Bootstrap bootstrap = new Bootstrap(); //设置相关参数 bootstrap.group(group) //设置线程组 .channel(NioSocketChannel.class) // 设置客户端通道的实现类(反射) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new NettyClientHandler()); //加入自己的处理器 &#125; &#125;); System.out.println(&quot;客户端 ok..&quot;); //启动客户端去连接服务器端 //关于 ChannelFuture 要分析，涉及到netty的异步模型 ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 8087).sync(); //给关闭通道进行监听 channelFuture.channel().closeFuture().sync(); &#125;finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; NettyClientHandler类 123456789101112131415161718192021222324public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123; //当通道就绪就会触发该方法 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;client &quot; + ctx); ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, server: (&gt;^ω^&lt;)喵&quot;, CharsetUtil.UTF_8)); &#125; //当通道有读取事件时，会触发 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf buf = (ByteBuf) msg; System.out.println(&quot;服务器回复的消息:&quot; + buf.toString(CharsetUtil.UTF_8)); System.out.println(&quot;服务器的地址： &quot;+ ctx.channel().remoteAddress()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 与ESP8266 通讯测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;ESP8266WiFi.h&gt; #include &lt;WiFiClient.h&gt; /*****************网络设置项 *****************/const char *STAssid =&quot;iQOOZ1&quot;; //需要连接路由器的名称const char *STApassword=&quot;chenbin123&quot;; //路由器的密码const char *host= &quot;192.168.94.71&quot;; //外网服务器ipconst int httpPort = 8087; //外网服务器端口WiFiClient client; //声明客户端对象bool is=0; //用来做连接到服务器后，仅发送一次问候语 void setup() &#123; Serial.begin(115200); Serial.println(&quot;开始连接&quot;); WiFi.mode(WIFI_STA); //设置为STA模式 WiFi.begin(STAssid, STApassword); //配置连接信息，开始连接 //运行自定义函数，在未连接到路由器的过程中，打印输出......，直到连接成功 gotoWifi(); Serial.println(&quot;连接路由器成功&quot;); //此时已经连接到路由器，可以开始连接远程服务器 lianjie(); &#125;void loop() &#123; /****************检测WiFi连接状态****************/ if (WiFi.status() != WL_CONNECTED) &#123; WiFi.disconnect(); WiFi.begin(STAssid, STApassword); gotoWifi(); &#125; else&#123; if (!client.connected()) &#123; //如果没有连接到服务器 lianjie(); return; &#125; else&#123; //否则，就是连接到服务器 if(is==0)&#123; client.print(&quot;hello,server&quot;); Serial.println(&quot;hello,client&quot;); is=1; &#125; &#125; &#125; Tcp_Handler(Read_Tcp()); //读取服务器信息，并处理 Tcp_HandlerClient(Write_Tcp());&#125;//读取服务器信息，返回String类型String Read_Tcp()&#123; String data = &quot;&quot;; while (client.available() &gt; 0)&#123; data += char(client.read()); delay(2); &#125; return data;&#125;//发送信息，返回String类型String Write_Tcp()&#123; String data = &quot;&quot;; while (Serial.available() &gt; 0)&#123; data += char(Serial.read()); delay(2); &#125; return data;&#125;//处理服务器信息void Tcp_Handler(String data)&#123; if(data!=&quot;&quot;)&#123; Serial.print(&quot;收到服务器信息：&quot;); Serial.println(data); &#125; &#125;//处理客户端信息void Tcp_HandlerClient(String data)&#123; /****************获取温度湿度****************/ float temperature = getTemp(); //调用函数计算温度值 client.print(&quot;温度:&quot;); client.println(temperature); if(data!=&quot;&quot;)&#123; client.print(&quot;client:&quot;); client.println(data); &#125; &#125;//连接路由器void gotoWifi()&#123; while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;.&quot;); &#125;&#125;//连接服务器void lianjie() &#123; Serial.println(&quot;开始连接服务器&quot;); client.connect(host, httpPort); delay(1000);&#125;//模拟温湿度float getTemp()&#123; //returns the temperature from one DS18S20 in DEG Celsius float temp[]=&#123;23.22,24.12,25.16,27.13,27.15,19.36,26.45&#125;; float aa=0; long randNumber = random(6); delay(100); //延迟0.1S return temp[randNumber]; &#125;","path":"2022/07/17/Netty的通讯与ESP8266（代码）/","date":"07-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"原生IO模式与Reactor模式与Netty框架简介","text":"原生IO模式与Reactor模式与Netty框架简介Netty 的介绍Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github 上的独立项目。Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。Netty 主要针对在 TCP 协议下，面向 Client 端的高并发应用，或者 Peer-to-Peer 场景下的大量数据持续传输的应用。Netty 本质是一个 NIO 框架，适用于服务器通讯相关的多种应用场景。要透彻理解 Netty，需要先学习 NIO，这样我们才能阅读 Netty 的源码。 详细内容参照：原文：https://blog.csdn.net/Youth_lql/article/details/115524052 本文简要介绍 Java BIO编程I&#x2F;O 模型I&#x2F;O 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。Java 共支持 3 种网络编程模型 I&#x2F;O 模式：BIO、NIO、AIO。 Java BIO：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。（一个线程对一个事件） Java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求就进行处理。 Java AIO(NIO.2)：异步非阻塞，AIO引入异步通道的概念，采用了Proactor&#96; 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。 BIO、NIO、AIO 使用场景分析BIO 方式 适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序简单易理解。NIO 方式 适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4 开始支持。AIO 方式 使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。Java BIO 基本介绍Java BIO 就是传统的 Java I&#x2F;O 编程，其相关的类和接口在 java.io。BIO(BlockingI&#x2F;O)：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，程序简单易理解。 Java BIO 应用实例在以前的serversocketDome中Java NIO编程Java NIO 基本介绍Java NIO 全称 Java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO（即 NewIO），是同步非阻塞的。NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。【基本案例】NIO 有三大核心部分：Channel（通道）、Buffer（缓冲区）、Selector（选择器） 。NIO 是面向缓冲区，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 10000 个请求过来,根据实际情况，可以分配 50 或者 100 个线程来处理。不像之前的阻塞 IO 那样，非得分配 10000 个。HTTP 2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP 1.1 大了好几个数量级。 12345678910111213NIO 和 BIO 的比较BIO 以流的方式处理数据，而 NIO 以块的方式处理数据，块 I/O 的效率比流 I/O 高很多。BIO 是阻塞的，NIO 则是非阻塞的。BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel（通道）和 Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。Buffer和Channel之间的数据流向是双向的每个 Channel 都会对应一个 Buffer。Selector 对应一个线程，一个线程对应多个 Channel（连接）。该图反应了有三个 Channel 注册到该 Selector //程序程序切换到哪个 Channel 是由事件决定的，Event 就是一个重要的概念。Selector 会根据不同的事件，在各个通道上切换。Buffer 就是一个内存块，底层是有一个数组。数据的读取写入是通过 Buffer，这个和 BIO是不同的，BIO 中要么是输入流，或者是输出流，不能双向，但是 NIO 的 Buffer 是可以读也可以写，需要 flip 方法切换 Channel 是双向的，可以返回底层操作系统的情况，比如 Linux，底层的操作系统通道就是双向的。 Netty框架完整流程 图片梳理传统阻塞IO模式 传统阻塞IO模式的改进（Reactor模式） 根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现 单 Reactor 单线程 单 Reactor 多线程 主从 Reactor 多线程 单 Reactor 多线程 主从 Reactor 多线程 Netty","path":"2022/07/17/原生IO模式与Reactor模式与Netty框架简介/","date":"07-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"计算机网络结构模型","text":"计算机网络结构模型OSI七层参考模型国际标准化组织（ISO）1984年颁布了开放系统互连参考模型（OSI），一个开放式体系结构，将架构分为7层。 分层 功能 应用层 网络服务与最终用户的一个接口 表示层 数据的表示，安全，压缩 会话层 建立，管理，中止会话 传输层 定义传输数据的协议端口号，以及流控和差错校验 网络层 进行逻辑地址寻址(IP)，实现不同网络之间的路径选择 数据链路层 建立逻辑链接，进行硬件地址寻址（MAC），差错校验等功能 物理层 建立，维护，断开物理连接 五层结构的作用汇总 层级名称 主要作用和功能 物理层 发送和接收比特流； 负责将比特流调制到载波上面（调幅、调频、调相）； 可以用信道复用等技术提升发送速率； 数据链路层 负责相邻设备间通信，这两个设备间没有交换节点，具体表现为点对点通信（PPP协议）和广播通信（CSMA&#x2F;CD协议）； 用MAC地址识别参与通信的两个节点（源节点、目的节点），MAC地址是本层及以下层专用； 上层网络层根据目的IP确定下一跳IP地址，数据链路层(交换机)根据下一跳IP地址就能确定下一跳的MAC地址，并将网络层数据报再次封装，加上目的MAC地址，交由物理层传送； 负责帧的差错检测，丢弃错误的帧（只检错不纠错），错误可能是帧丢失、帧重复、帧失序； 网络层 负责不相邻的两个节点间的通信，比如我的电脑和网页服务器之间的通信； 用IP地址识别源地址、目的地址，IP地址是本层及以上层专用； 能够确定转发路线，使得效率最高； 运输层 识别并将数据报正确交付相应的应用程序，识别数据报属于哪个应用程序的方法为看端口； TCP可靠传输，UDP不可靠传输； 应用层 使用得到的报文段，为用户提供各种服务（浏览器、邮件、远程通信）； 向上面向用户（域名给用户看），向下面向运输层和网络层（域名解析给他们看）； 五层结构传输单元名称 层级名称 传输单元名称 应用层 报文 运输层 TCP：报文段； UDP：用户数据报； 网络层 分组或IP数据报（简称数据报） 数据链路层 帧 物理层 比特 各层协议和专用术语汇总常见的 层级名称 传输单元名称 应用层 http，mqtt 运输层 TCP，UDP 层级名称 传输单元名称 应用层 网际组管理协议IGMP：使得连接在本局域网上的多播路由器知道本局域网上是否有主机（指主机上的进程）参加或退出某个多播组； DNS：域名系统； 简单文件传送协议TFTP； 文件传送协议FTP； NFS：网络文件系统； 动态主机配置协议DHCP：用于自动分配IP地址； 简单网络管理协议SNMP； 简单邮件传送协议SMTP：用于发送邮件； 邮件读取协议POP和IMAP：用于读取邮件； 远程终端协议TELNET； 超文本传送协议HTTP； socket：IP和端口统称套接字，java语言中称为java socket编程； 安全外壳SSH（Secure Shell）：不是一种协议，是运用运输层SSL协议构建的一个类似telnet的应用，SSH &#x3D; TELNET + SSL，和web开发框架中的SSH框架没有任何关系（SSH&#x3D;Struts+Spring+Hibernate）； 运输层 传输控制协议TCP：面向连接； 用户数据报协议UDP：无连接； 安全套接层SSL：是一种在运输层对网络数据进行加密的协议; 网络层 地址解析协议ARP：已知一台机器的IP地址，需要找出其相对应的硬件MAC地址； 网际控制报文协议ICMP：分为ICMP差错报文和ICMP询问报文，用于主机和路由器报告差错和异常情况，ping命令是在应用层直接使用网络层协议的例子； 内部网关协议IGP：一个自治系统内部使用的路由协议，包括RIP和OSPF协议； 外部网关协议EGP：自治系统间路由协议，包括BGP协议； VPN：虚拟专用网技术，用到了网络地址转换NAT技术； 数据链路层 PPP：点对点信道所使用的协议； CSMA&#x2F;CD：广播信道使用的协议； MAC地址； 物理层 传输介质：双绞线、同轴电缆； 信道复用技术：频分复用、时分复用、码分复用； 宽带接入技术：ADSL（非对称用户数字线）； 各层典型设备 层级名称 设备名称 应用层 网关：连接两个或多个使用不同协议的网络，充当“协议转换器”，是两个局域网之间的通道； 运输层 暂无 网络层 路由器：连接不同网络的设备，自动选择设定路由，寻找最佳路径，在某些情况下，路由器也被称做网关； 数据链路层 网卡（网络适配器）：当接收帧错误时就丢弃，正确时就交付网络层，内含MAC地址； 交换机：相当于多个网桥，将好多计算机连接成一个局域网，负责局域网内部的数据交换，相当于扩展的网桥，允许在还没把数据帧接受完全的情况下转发帧； 网桥&#x2F;桥接器：把一个局域网隔离成许多网段，维护转发表，对收到的帧进行转发、过滤或丢弃（完全接收到一帧后才转发）； 物理层 集线器&#x2F;转发器：简单转发比特，不维护任何表； 原文：https://changsiyuan.github.io/2015/09/12/2015-9-12-five-layer/?nsukey=dqWDT924aub5wdRRxQzhz0rDzccgK%2Bhc6dNa6el5MvnPq5EW75AsEIn%2Bon8ry5JJrS5vqSfjAQYMaqml7083LbbFRFhqDgYnZ5azat248mVUl2dIx90eWgfZdd9EDFbSf0Qd9IXK3bZF7K2Yv%2FFTlfkjDyXu10yG6ilAjRbIzpDnKZHXgFJ68yISxuRH1ZkQHvWZb%2BBh0cfkdrhbPbNbzg%3D%3D Socket，MQTT，WebSocket的区别1.Socket是对TCP&#x2F;IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP&#x2F;IP协议。2.MQTT协议是应用层协议不依赖长连接，适合弱网络。通过topic缓存信息。符合物联网设备的使用场景。因为通过topic缓存信息，因此可以实现通过topic与多个端的一对多连接，而不是设备与设备的多对多连接，节省了能耗及带宽。MQTT的心跳，及非信息的报文，较Websocket更少，更节省带宽及能耗。更适用于物理网的多种网络协议。3.WebSocket和Http一样在应用层,提供使用一个TCP连接进行双向通讯的机制，包括网络协议和API，以取代网页和服务器采用HTTP轮询进行双向通讯的机制。 本质上来说，WebSocket是不限于HTTP协议的，但是由于现存大量的HTTP基础设施，代理，过滤，身份认证等等，WebSocket借用HTTP和HTTPS的端口。由于使用HTTP的端口，因此TCP连接建立后的握手消息是基于HTTP的，由服务器判断这是一个HTTP协议，还是WebSocket协议。 WebSocket连接除了建立和关闭时的握手，数据传输和HTTP没丁点关系了。 SokectSocket 连接,至少需要一对套接字，分为 clientSocket，serverSocket 连接分为3个步骤: (1) 服务器监听:服务器并不定位具体客户端的套接字，而是时刻处于监听状态；(2) 客户端请求:客户端的套接字要描述它要连接的服务器的套接字，提供地址和端口号，然后向服务器套接字提出连接请求；(3) 连接确认:当服务器套接字收到客户端套接字发来的请求后，就响应客户端套接字的请求,并建立一个新的线程,把服务器端的套接字的描述发给客户端。一旦客户端确认了此描述，就正式建立连接。而服务器套接字继续处于监听状态，继续接收其他客户端套接字的连接请求.Socket为长连接：通常情况下Socket 连接就是 TCP 连接，因此 Socket 连接一旦建立,通讯双方开始互发数据内容，直到双方断开连接。在实际应用中，由于网络节点过多，在传输过程中，会被节点断开连接，因此要通过轮询高速网络，该节点处于活跃状态。 很多情况下，都是需要服务器端向客户端主动推送数据，保持客户端与服务端的实时同步。若双方是 Socket 连接，可以由服务器直接向客户端发送数据。若双方是 HTTP 连接，则服务器需要等客户端发送请求后，才能将数据回传给客户端。因此，客户端定时向服务器端发送请求，不仅可以保持在线，同时也询问服务器是否有新数据，如果有就将数据传给客户端。 MQTTMQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是轻量级基于代理的发布&#x2F;订阅的消息传输协议，设计思想是开放、简单、轻量、易于实现。这些特点使它适用于受限环境。例如：①网络代价昂贵，带宽低、不可靠。②在嵌入设备中运行，处理器和内存资源有限。该协议的特点有：①使用发布&#x2F;订阅消息模式，提供一对多的消息发布，解除应用程序耦合。 ②对负载内容屏蔽的消息传输。③使用 TCP&#x2F;IP 提供网络连接。④有三种消息发布服务质量：⑤”至多一次”，消息发布完全依赖底层 TCP&#x2F;IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。⑥”至少一次”，确保消息到达，但消息重复可能会发生。⑦”只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。⑧小型传输，开销很小（固定长度的头部是 2 字节），协议交换最小化，以降低网络流量。⑨使用 Last Will 和 Testament 特性通知有关各方客户端异常中断的机制。 MQTT实现实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（payload）两部分： 有三种消息发布服务质量： “至多一次”，消息发布完全依赖底层TCP&#x2F;IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，倘若你的智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。qos&#x3D;0 “至少一次”，确保消息到达，但消息重复可能会发生。qos&#x3D;1 “只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。qos&#x3D;2 Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）； payload，可以理解为消息的内容，是指订阅者具体要使用的内容。 MQTT协议数据包结构 在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。MQTT数据包结构如下： 固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。 WebSocketWebSocket则提供使用一个TCP连接进行双向通讯的机制，包括网络协议和API，以取代网页和服务器采用HTTP轮询进行双向通讯的机制。 本质上来说，WebSocket是不限于HTTP协议的，但是由于现存大量的HTTP基础设施，代理，过滤，身份认证等等，WebSocket借用HTTP和HTTPS的端口。由于使用HTTP的端口，因此TCP连接建立后的握手消息是基于HTTP的，由服务器判断这是一个HTTP协议，还是WebSocket协议。 WebSocket连接除了建立和关闭时的握手，数据传输和HTTP没丁点关系了。 由此可知两者的应用场景不一样： MQTT是为了物联网场景设计的基于TCP的Pub&#x2F;Sub协议，有许多为物联网优化的特性，比如适应不同网络的QoS、层级主题、遗言等等。 WebSocket是为了HTML5应用方便与服务器双向通讯而设计的协议，HTTP握手然后转TCP协议，用于取代之前的Server Push、Comet、长轮询等老旧实现。 两者之所有有交集，是因为一个应用场景：如何通过HTML5应用来作为MQTT的客户端，以便接受设备消息或者向设备发送信息，那么MQTT over WebSocket自然成了最合理的途径了。 原文：https://zoyi14.smartapps.cn/pages/note/index?_swebFromHost=baiduboxapp&amp;origin=share&amp;slug=18df97360773&amp;_swebfr=1 MQTT与HTTP的区别 : MQTT HTTP 架构 基于发布&#x2F;订阅模式 基于请求&#x2F;响应模型 复杂度 相对简单 相对复杂 运行方式 基于TCP运行 基于TCP，也可以使用UDP 协议设计 数据中心 文档中心 消息大小 使用二进制，较小 使用 ASCII 码，较大 消息头 2字节 8字节 端口号 1883 80或8080 数据安全 提供SSL&#x2F;TLS方法 不提供安全方法，但是https提供 HTTP是用于客户端服务器计算的以文档为中心的请求-响应协议。 与HTTP中的直接客户端服务器交互不同，MQTT在发布&#x2F;订阅范例下运行，中间有MQTT代理。客户端可以将主题发布到MQTT代理或订阅主题，同一客户端可以发布主题X和Y，并订阅由另一个MQTT客户端发布的主题Z，MQTT还允许MQTT客户端和代理之间的持久连接以及不同的服务质量级别，这使得它非常适合各种受限环境，因为在这种情况下，它比HTTP更节能、更快。","path":"2022/07/17/计算机网络结构模型/","date":"07-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"vue中axios的用法","text":"1.下载 1npm install --save axios vue-axios 2.引入调用 12345import Vue from &#x27;vue&#x27;import axios from &#x27;axios&#x27;import VueAxios from &#x27;vue-axios&#x27;Vue.use(VueAxios, axios) 3.简单调用的三种方式 123456789101112Vue.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)this.$http.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) 4.get请求 1234567891011121314151617181920212223242526272829303132333435363738new Vue(&#123; el: &#x27;#app&#x27;, data () &#123; return &#123; info: null &#125; &#125;, mounted () &#123; axios .get(&#x27;https://www.runoob.com/try/ajax/json_demo.json&#x27;) .then(response =&gt; (this.info = response)) .catch(function (error) &#123; // 请求失败处理 console.log(error); &#125;); &#125;&#125;)//000000000000000000// 直接在 URL 上添加参数 ID=12345axios.get(&#x27;/user?ID=12345&#x27;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); // 也可以通过 params 设置参数：axios.get(&#x27;/user&#x27;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 5.post请求 123456789101112131415161718192021222324252627282930313233343536373839new Vue(&#123; el: &#x27;#app&#x27;, data () &#123; return &#123; info: null &#125; &#125;, mounted () &#123; axios .post(&#x27;https://www.runoob.com/try/ajax/demo_axios_post.php&#x27;) .then(response =&gt; (this.info = response)) .catch(function (error) &#123; // 请求失败处理 console.log(error); &#125;); &#125;&#125;)//传参axios.post(&#x27;/user&#x27;, &#123; firstName: &#x27;Fred&#x27;, // 参数 firstName lastName: &#x27;Flintstone&#x27; // 参数 lastName &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); //执行多个并发请求 function getUserAccount() &#123; return axios.get(&#x27;/user/12345&#x27;);&#125; function getUserPermissions() &#123; return axios.get(&#x27;/user/12345/permissions&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); 可以通过向 axios 传递相关配置来创建请求。 12345678910111213141516171819202122axios(config)// 发送 POST 请求axios(&#123; method: &#x27;post&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;&#125;);// GET 请求远程图片axios(&#123; method:&#x27;get&#x27;, url:&#x27;https://static.runoob.com/images/runoob-logo.png&#x27;, responseType:&#x27;stream&#x27;&#125;) .then(function(response) &#123; response.data.pipe(fs.createWriteStream(&#x27;ada_lovelace.jpg&#x27;))&#125;);axios(url[, config])// 发送 GET 请求（默认的方法）axios(&#x27;/user/12345&#x27;); 请求配置项在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。因为params是添加到url的请求字符串中的，用于get请求。而data是添加到请求体（body）中的， 用于post请求。 当axios中的请求方式为‘post’的时候，axios的数据应该是 data:{}，并且默认请求的是json字符串 当请求方式是‘get’的时候，里面的数据应该是params:{}，并且默认请求的是查询字符串 data是添加到请求头中(多用与post请求) params是添加到url请求字符串中(多用于get请求) 参数 类型 描述 url string 请求的目标URL body Object, FormData, string 作为请求体发送的数据 headers Object 作为请求头部发送的头部对象 params Object 作为URL参数的参数对象 method string HTTP方法 (例如GET，POST，…) timeout number 请求超时（单位：毫秒） (0表示永不超时) before function(request) 在请求发送之前修改请求的回调函数 progress function(event) 用于处理上传进度的回调函数 ProgressEvent credentials boolean 是否需要出示用于跨站点请求的凭据 emulateHTTP boolean 是否需要通过设置X-HTTP-Method-Override头部并且以传统POST方式发送PUT，PATCH和DELETE请求。 emulateJSON boolean 设置请求体的类型为application/x-www-form-urlencoded 通过如下属性和方法处理一个请求获取到的响应对象： 属性 类型 描述 url string 响应的 URL 源 body Object, Blob, string 响应体数据 headers Header 请求头部对象 ok boolean 当 HTTP 响应码为 200 到 299 之间的数值时该值为 true status number HTTP 响应码 statusText string HTTP 响应状态 方法 类型 描述 text() 约定值 以字符串方式返回响应体 json() 约定值 以格式化后的 json 对象方式返回响应体 blob() 约定值 以二进制 Blob 对象方式返回响应体 123456789101112131415// `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &quot;PUT&quot;, &quot;POST&quot;, 和 &quot;PATCH&quot; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: &quot;Fred&quot; &#125;, 下面是创建请求时可用的配置选项，注意只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&#123; url: &quot;/user&quot;, method: &quot;get&quot;, // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &quot;https://some-domain.com/api/&quot;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &quot;PUT&quot;, &quot;POST&quot; 和 &quot;PATCH&quot; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;], // `headers` 是即将被发送的自定义请求头 headers: &#123;&quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;&#125;, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, https://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &quot;brackets&quot;&#125;) &#125;, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &quot;PUT&quot;, &quot;POST&quot;, 和 &quot;PATCH&quot; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: &#123; firstName: &quot;Fred&quot; &#125;, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求花费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) &#123; /* ... */ &#125;, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: &#123; username: &quot;janedoe&quot;, password: &quot;s00pers3cret&quot; &#125;, // `responseType` 表示服务器响应的数据类型，可以是 &quot;arraybuffer&quot;, &quot;blob&quot;, &quot;document&quot;, &quot;json&quot;, &quot;text&quot;, &quot;stream&quot; responseType: &quot;json&quot;, // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &quot;XSRF-TOKEN&quot;, // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: &quot;X-XSRF-TOKEN&quot;, // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理 &#125;, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) &#123; return status &amp;gt;= 200 &amp;amp;&amp;amp; status &amp;lt; 300; // 默认的 &#125;, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // &quot;proxy&quot; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: &#123; host: &quot;127.0.0.1&quot;, port: 9000, auth: : &#123; username: &quot;mikeymike&quot;, password: &quot;rapunz3l&quot; &#125; &#125;, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 响应结构axios请求的响应包含以下信息： 12345678910111213141516&#123; // `data` 由服务器提供的响应 data: &#123;&#125;, // `status` HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &quot;OK&quot;, // `headers` 服务器响应的头 headers: &#123;&#125;, // `config` 是为请求提供的配置信息 config: &#123;&#125;&#125; 使用 then 时，会接收下面这样的响应： 12345678axios.get(&quot;/user/12345&quot;) .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 参考菜鸟教程：https://www.runoob.com/vue2/vuejs-ajax-axios.html","path":"2022/07/09/vue中axios的用法/","date":"07-09","excerpt":"","tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Node.js-vue概念","text":"Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，使其轻量又高效。 Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node 使用事件驱动， 非阻塞I&#x2F;O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 官网上对其特点描述为： 它是一个Javascript运行环境 依赖于Chrome V8引擎进行代码解释 事件驱动 非阻塞I&#x2F;O 轻量、可伸缩，适于实时数据交互应用 单进程，单线程 相对于传统的JavaScript来说，Node.js 是一个运行在服务端的框架，它的底层就使用了 V8 引擎。我们知道 Apache + PHP 以及 Java 的 Servlet 都可以用来开发动态网页，Node.js 的作用与他们类似，只不过是使用 JavaScript 来开发，它大大提升了开发的性能以及便利。 nmpnpm（包管理工具）是基于 Node.js的前端项目包管理工具，是项目中对各种程序包的依赖管理，传统的开发项目主要是后端，现在技术在更新，前端有了框架的开发模式管理，也需要用包管理工具的思想去管理，目的是简化第三方程序包在项目中引用复杂化。前端的ｊｓ包是全世界JavaScript 天才开发共享的各种代码模块，把这些代码模块都按照一个独立的软件功能统一在一个库中，一个代码模块是一个程序包（package，即代码模块）。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块），使用包的结构使您能够轻松跟踪依赖项和版本。npm是node官方的包管理器。cnpm是个中国版的npm，是淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm: 123456789101112131415161718192021221. 创建一个文件包2. npm init3. 创建一个index.js 文件，并写入一些要实现的代码4.npm install –D xxx 项目依赖安装，并写入package.json的devDependencies中5.npm install -g xxx # 安装最新版本6.npm install -g xxx@1.0.0 # 安装指定版本7.npm install xxx 本地安装（当前文件夹） 8.npm install –S xxx # 和上面效果一样--save 安装并添加条目到 package.json 文件的 dependencies。--save-dev 安装并添加条目到 package.json 文件的 devDependencies。9.npm install --registry=https://registry.npmmirror.com 项目本次安装依赖，临时使用淘宝镜像9.npm get registry 查询当前源配置10.npm config set reg istry https://registry.npmmirror.com 设置淘宝镜像源11.npm info 查看每个模块的具体信息12.npm list 命令以树型结构列出当前项目安装的所有模块，以及它们依赖的模块。13.npm list -global 会列出全局安装的模块。5. npm link 本地调试6. npm login 登录7. npm publish 发布8. npm version patch // 更新版本9. npm update gulp //可以把当前目录下node_modules子目录里边的对应模块更新至最新版本 10. npm unpublish npmhswcommonwei@1.0.2 // 可以撤销发布自己发布过的某个版本代码 Bower：Bower是一个客户端技术的软件包管理器，它可用于搜索、安装和卸载如JavaScript、HTML、CSS之类的网络资源。其他还有一些建立在Bower基础之上的开发工具，如YeoMan和Grunt。 为了安装bower，你首先需要安装如下文件： Node：下载最新版本的node.js NPM：NPM是node程序包管理器。它是捆绑在nodejs的安装程序上的，所以一旦你已经安装了node，NPM也就安装好了。 Git：你需要从git仓库获取一些代码包。 下载 &#96;&#96;&#96;npm install -g bower 1234567 #### yarnYarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ，正如[官方文档](https://link.jianshu.com/?t=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fcode.facebook.com%2Fposts%2F1840075619545360)中写的，Yarn 是为了弥补 npm 的一些缺陷而出现的。 1、速度快速度快主要来自以下两个方面： 1.1、并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。1.2、离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。2、安装版本统一为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。3、更简洁的输出npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。4、多注册来源处理所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。5、更好的语义化yarn改变了一些npm命令的名称，比如 yarn add&#x2F;remove，感觉上比 npm 原本的 install&#x2F;uninstall 要更清晰。 1 三、Yarn安装npm install -g yarn四、Yarn命令1、查看版本yarn -v2、创建工程yarn init3、安装依赖yarn 或者 yarn install4、运行脚本yarn run5、打包构建yarn build6、显示某个包信息yarn info7、列出当前项目的依赖yarn list8、显示当前配置yarn config list9、列出已缓存的每个包sudo yarn cache list10、清除缓存sudo yarn cache clean &#96;&#96;&#96; 五、NPM对比npm install react –save yarn add reactnpm uninstall react –save yarn remove reactnpm install react –save-dev yarn add react –devnpm update –save yarn upgrade Vue首先vue.js 是库，不是框架，不是框架，不是框架。 Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。 Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。 vue.js 支持路由功能开发的 叫vue-route.js，vue.js支持数据请求功能开发的 叫vue-resource.js。原文链接：https://blog.csdn.net/u013182960/article/details/110189159","path":"2022/07/09/Node-js-vue概念/","date":"07-09","excerpt":"","tags":[{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"Spring boot中前后端数据交互之前端对后端数据的调用(Thymeleaf的用法)","text":"Thymeleaf模板参考：https://blog.csdn.net/weixin_43055096/article/details/87704493 菜鸟教程：https://blog.csdn.net/baiduwenku112/article/details/120071356 创建 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; “&lt;html lang&#x3D;“en” xmlns:th&#x3D;“http://www.thymeleaf.org”：这段代码就是引入了th模板 主体内容 如果你要传入的是一个字符串@Controller public class NodeController &#123; @Resource private StudentServiceImp ssi; @RequestMapping(value = &quot;/&quot;) public String index(Model model)&#123; String students =&quot;刘洋&quot;; model.addAttribute(&quot;s&quot;,students) return &quot;index&quot;; &#125; &#125; model.addAttribute(“s”,students) s就为传入前端的标识Html代码如下 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;span th:text=&quot;$&#123;s&#125;&quot;&gt; &lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 如果你要传入的是一个list集合.我们都知道如果传入的是一个list集合，前端就必须要展示list集合的属性。 12345678910111213@Controllerpublic class NodeController &#123; @Resource private StudentServiceImp ssi; @RequestMapping(value = &quot;/&quot;) public String index(Model model)&#123; List&lt;Student&gt; list = ssi.findStudentByAge(15); model.addAttribute(&quot;s&quot;,list) return &quot;index&quot;; &#125;&#125; Html代码如下，这里只是拿出了s中的属性。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table th:each=&quot;i:$&#123;s&#125;&quot;&gt; &lt;tr &gt; &lt;td&gt;学生Id&lt;/td&gt; &lt;td th:text=&quot;$&#123;i.id&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr &gt; &lt;td&gt;学生姓名&lt;/td&gt; &lt;td th:text=&quot;$&#123;i.name&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr &gt; &lt;td&gt;学生分数&lt;/td&gt; &lt;td th:text=&quot;$&#123;i.score&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 如果你要传入的是一个对象. 123456789101112@Controllerpublic class NodeController &#123; @Resource private StudentServiceImp ssi; @RequestMapping(value = &quot;/&quot;) public String index(Model model)&#123; Student students =new Student(0,1,2,3,4); model.addAttribute(&quot;s&quot;,students); return &quot;index&quot;; &#125;&#125; Html代码如下,这里就要用到get方法了。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table th:each=&quot;i:$&#123;s&#125;&quot;&gt; &lt;tr &gt; &lt;td&gt;学生Id&lt;/td&gt; &lt;td th:text=&quot;$&#123;i.getId(&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr &gt; &lt;td&gt;学生姓名&lt;/td&gt; &lt;td th:text=&quot;$&#123;i.getName()&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr &gt; &lt;td&gt;学生分数&lt;/td&gt; &lt;td th:text=&quot;$&#123;i.getScore()&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 遍历时的状态变量&lt;tr th:each=&quot;user,userStat:$&#123;users&#125;&quot;&gt;userStat是状态变量，有 index,count,size,current,even,odd,first,last等属性，如果没有显示设置状态变量，thymeleaf会默 认给个“变量名+Stat”的状态变量。 th:each&#x3D;”user, userStat : ${userList}” 中的 ${userList} 是后台传过来的集合 ◼ user：定义变量，去接收遍历${userList}集合中的一个数据◼ userStat：${userList} 循环体的信息◼ 其中 user 及 userStat 自己可以随便取名◼ userStat 是循环体的信息，通过该变量可以获取如下信息 index: 当前迭代对象的 index （从 0 开始计算） count: 当前迭代对象的个数（从 1 开始计算） 这两个用的较多size: 被迭代对象的大小current: 当前迭代变量even&#x2F;odd: 布尔值，当前循环是否是偶数&#x2F;奇数（从 0 开始计算）first: 布尔值，当前循环是否是第一个last: 布尔值，当前循环是否是最后一个息 注意：循环体信息 userStat 也可以不定义，则默认采用迭代变量加上 Stat 后缀，即 userStat2.1.2 *{…} 简单表达式变量表达式$&#123;&#125;是面向整个上下文的，而选择变量表达式*&#123;&#125;的上下文是父标签（th:object）所选择的对象： 12345&lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p th:text=&quot;*&#123;name&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;*&#123;sex&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt; 它相当于： 123456&lt;div&gt; &lt;p th:text=&quot;$&#123;session.user.name&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;session.user.sex&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;session.user.age&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt;如果对象没有被选择，那么，*&#123;&#125;和$&#123;&#125;表达式所达到的效果是完全相同的： @{…}链接表达式@&#123;&#125;是专门用来处理 URL 链接地址的。 绝对地址示例： 12&lt;!-- https://fanlychie.github.io --&gt;&lt;p th:text=&quot;@&#123;https://fanlychie.github.io&#125;&quot;&gt;&lt;/p&gt; 页面相对地址示例： 12&lt;!-- commons/base.html --&gt;&lt;p th:text=&quot;@&#123;commons/base.html&#125;&quot;&gt;&lt;/p&gt; 上下文相对地址（相对于当前的服务）示例： 12&lt;!-- /css/mian.css --&gt;&lt;p th:text=&quot;@&#123;/css/mian.css&#125;&quot;&gt;&lt;/p&gt; 服务器相对地址（相对于部署在同一个服务器中的不同服务）示例： 12&lt;!-- /image/upload --&gt;&lt;p th:text=&quot;@&#123;~/image/upload&#125;&quot;&gt;&lt;/p&gt; 代码的移用 1&lt;div th:replace=&quot;banner::swiper($&#123;banners&#125;)&quot;&gt;&lt;/div&gt; 转载一篇我认为很牛的一个Thymeleaf 教程（防丢失）菜鸟教程：https://blog.csdn.net/baiduwenku112/article/details/120071356 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455目录1. 创建模板文件2. 标准表达式语法2.1 简单表达式 2.1.1 $&#123;…&#125; 2.1.2 *&#123;…&#125;2.1.3 #&#123;…&#125;2.1.4 @&#123;…&#125;2.1.5 ~&#123;…&#125;2.1.6 内置对象2.1.7 工具类2.2 字面值2.2.1 文字字面值2.2.2 数字字面值2.2.3 布尔字面值2.2.4 空字面值2.2.5 字面令牌2.3 文本操作2.3.1 字符串连接2.3.2 字面值替换2.4 算术运算2.5 布尔运算2.6 比较和相等2.7 条件运算2.8 无操作符3. 使用文本3.1 th:text3.2 th:utext4. 设置属性值4.1 th:attr4.2 th:*4.3 th:*-*4.4 th:attrappend &amp; th:attrprepend4.5 布尔属性5. 遍历6. 条件判断6.1 th:if6.2 th:unless6.3 th:swith7. 定义局部变量8. 注释8.1 标准注释8.1.1 单行注释8.1.2 多行注释8.2 解析器级注释8.2.1 单行注释：8.2.2 多行注释9. 内联表达式9.1 [[…]]9.2 [(…)]9.3 th:inline9.3.1 none 9.3.2 text9.3.3 css9.3.4 javascript Thymeleaf 是一个服务器端 Java 模板引擎，能够处理 HTML、XML、CSS、JAVASCRIPT 等模板文件。Thymeleaf 模板可以直接当作静态原型来使用，它主要目标是为开发者的开发工作流程带来优雅的自然模板，也是 Java 服务器端 HTML5 开发的理想选择。 1. 创建模板文件创建一个 HTML 模板文件： 12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Index Page&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;Welcome to BeiJing!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 通过&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;引入 Thymeleaf 命名空间。th:text用于处理p标签体的文本内容。该模板文件直接在任何浏览器中正确显示，浏览器会自动忽略它们不能理解的属性th:text。但这不是一个真正有效的 HTML5 文档，因为 HTML5 规范是不允许使用th:*这些非标准属性的。我们可以切换到 Thymeleaf 的data-th-*语法，以此来替换th:*语法： 12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Index Page&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p data-th-text=&quot;$&#123;message&#125;&quot;&gt;Welcome to BeiJing!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML5 规范是允许data-*这样自定义的属性的。th:*和data-th-*这两个符号是完全等效且可以互换的。但为了简单直观和代码的紧凑性，本文采用th:*的表示形式。 2. 标准表达式语法Thymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类： 简单表达式 字面值 文本操作 算术运算 布尔运算 比较和相等 条件运算 无操作符 2.1 简单表达式 2.1.1 ${…}1234567@GetMapping(&quot;/standard-expression-syntax/variables&quot;)public String variables(ModelMap model, HttpSession session) &#123; model.put(&quot;now&quot;, new Date()); model.put(&quot;message&quot;, &quot;Welcome to BeiJing!&quot;); session.setAttribute(&quot;user&quot;, new User(&quot;fanlychie&quot;, &quot;男&quot;, 24)); ... ...&#125; 通过变量表达式$&#123;&#125;取出上下文环境中的message变量： 12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt; 它相当于： 1ctx.getVariable(&quot;message&quot;); 2.1.2 *{…}变量表达式$&#123;&#125;是面向整个上下文的，而选择变量表达式*&#123;&#125;的上下文是父标签（th:object）所选择的对象： 12345&lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p th:text=&quot;*&#123;name&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;*&#123;sex&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt; 它相当于： 12345678&lt;div&gt; &lt;p th:text=&quot;$&#123;session.user.name&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;session.user.sex&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;session.user.age&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt;如果对象没有被选择，那么，*&#123;&#125;和$&#123;&#125;表达式所达到的效果是完全相同的：&lt;p th:text=&quot;*&#123;session.user.name&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;session.user.name&#125;&quot;&gt;&lt;/p&gt; 2.1.3 #{…}消息表达式可用于国际化文字信息。首先我们来了解一下 i18n 资源文件的命名规则： basename.properties basename_language.properties basename_language_country.properties basename是自定义的资源文件名称，language和country必须是 Java 支持的语言和国家。basename.properties是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。 创建文件src/main/resources/messages.properties 1welcome.message = 北京欢迎你！ 创建文件src/main/resources/messages_en_US.properties 1welcome.message = Welcome to BeiJing! 在 IntelliJ IDEA 编辑视图： messages是 Spring Boot 加载资源文件默认采用的名称（basename），如果你所使用的资源文件名称不是以messages命名或所使用的资源文件不是在src/main/resources根目录，你可以通过spring.messages.basename属性来做具体的配置。如，资源文件messages.properties和messages_en_US.properties假设它们所在的目录位置是src/main/resources/i18n。 application.properties 配置示例： 1spring.messages.basename:i18n/messages application.yml 配置示例： 123spring messages basename: i18n/messages 静态文本消息示例： 12&lt;!-- 北京欢迎你！ --&gt;&lt;p th:text=&quot;#&#123;welcom.message&#125;&quot;&gt;&lt;/p&gt; 消息表达式#&#123;&#125;是不允许直接处理非静态的文本消息的，但是你可以在资源文件中通过使用占位符&#123;&#125;来处理非静态的文本消息： messages.properties 配置示例： 1welcome.user.message = &#123;0&#125;, 北京欢迎你！ messages_en_US.properties 配置示例： 1welcome.user.message = &#123;0&#125;, Welcome to BeiJing! 非静态文本消息，以参数的形式传递变量的值： 12&lt;!-- fanlychie, 北京欢迎你！ --&gt;&lt;p th:text=&quot;#&#123;welcome.user.message($&#123;session.user.name&#125;)&#125;&quot;&gt;&lt;/p&gt; 2.1.4 @{…}链接表达式@&#123;&#125;是专门用来处理 URL 链接地址的。 绝对地址示例： 12&lt;!-- https://fanlychie.github.io --&gt;&lt;p th:text=&quot;@&#123;https://fanlychie.github.io&#125;&quot;&gt;&lt;/p&gt; 页面相对地址示例： 12&lt;!-- commons/base.html --&gt;&lt;p th:text=&quot;@&#123;commons/base.html&#125;&quot;&gt;&lt;/p&gt; 上下文相对地址（相对于当前的服务）示例： 12&lt;!-- /css/mian.css --&gt;&lt;p th:text=&quot;@&#123;/css/mian.css&#125;&quot;&gt;&lt;/p&gt; 服务器相对地址（相对于部署在同一个服务器中的不同服务）示例： 12&lt;!-- /image/upload --&gt;&lt;p th:text=&quot;@&#123;~/image/upload&#125;&quot;&gt;&lt;/p&gt; 参数使用示例： 12345678&lt;!-- /css/mian.css?v=1.0 --&gt;&lt;p th:text=&quot;@&#123;/css/mian.css(v=1.0)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- /user/order?username=fanlychie --&gt;&lt;p th:text=&quot;@&#123;/user/order(username=$&#123;session.user.name&#125;)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- /user/order?username=fanlychie&amp;status=PAIED --&gt;&lt;p th:text=&quot;@&#123;/user/order(username=$&#123;session.user.name&#125;,status=&#x27;PAIED&#x27;)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- /user/fanlychie/info --&gt;&lt;p th:text=&quot;@&#123;/user/&#123;username&#125;/info(username=$&#123;session.user.name&#125;)&#125;&quot;&gt;&lt;/p&gt; 2.1.5 ~{…}片段表达式~&#123;&#125;可以用来引用一段公共的 HTML 代码片段。 在 Thymeleaf 模板文件中，你可以使用th:fragment属性来定义一段公共的代码片段，然后你可以通过使用th:insert、th:replace、th:include（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。 src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;base.html，通过th:fragment属性定义一段公共的代码片段： 1&lt;div id=&quot;footer&quot; th:fragment=&quot;footerFragment&quot;&gt;&amp;copy; 2017 fanlychie&lt;/div&gt; src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;index.html，通过th:insert属性引用一段公共的代码片段： 1&lt;div th:insert=&quot;~&#123;base :: footerFragment&#125;&quot;&gt;&lt;/div&gt; 其中，~&#123;&#125;是可选的，我们可以去掉这层的包裹： 1&lt;div th:insert=&quot;base :: footerFragment&quot;&gt;&lt;/div&gt; 若 index.html 与 base.html 不在同级目录，如 templates&#x2F;commons&#x2F;base.html： 1&lt;div th:insert=&quot;~&#123;commons/base :: footerFragment&#125;&quot;&gt;&lt;/div&gt; 使用th:fragment属性定义代码片段时，你还可以声明一组参数： 12345678&lt;div th:fragment=&quot;crumbs(parent, child)&quot;&gt; &lt;i th:text=&quot;$&#123;parent&#125;&quot;&gt;&lt;/i&gt; &lt;i th:text=&quot;$&#123;child&#125;&quot;&gt;&lt;/i&gt;&lt;/div&gt;&lt;!--&lt;i&gt;用户中心&lt;/i&gt;&lt;i&gt;我的订单&lt;/i&gt;--&gt;&lt;div th:insert=&quot;::crumbs(&#x27;用户中心&#x27;, &#x27;我的订单&#x27;)&quot;&gt;&lt;/div&gt; 此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段： 1&lt;div th:insert=&quot;~&#123;base :: #footer&#125;&quot;&gt;&lt;/div&gt; 除了th:insert属性th:replace也可以用来引用公共的代码片段。不同的是，th:insert是直接将代码片段插入到标签体内，而th:replace则是用代码片段直接替换标签体内容。 12345678910&lt;!--&lt;div&gt; &lt;div id=&quot;footer&quot;&gt;© 2017 fanlychie&lt;/div&gt;&lt;/div&gt;--&gt;&lt;div th:insert=&quot;~&#123;base :: footerFragment&#125;&quot;&gt;&lt;/div&gt;&lt;!--&lt;div id=&quot;footer&quot;&gt;© 2017 fanlychie&lt;/div&gt;--&gt;&lt;div th:replace=&quot;~&#123;base :: footerFragment&#125;&quot;&gt;&lt;/div&gt; 2.1.6 内置对象 #ctx示例： 123456&lt;!-- zh_CN --&gt;&lt;p th:text=&quot;$&#123;#ctx.getLocale()&#125;&quot;&gt;&lt;/p&gt;&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=&quot;$&#123;#ctx.getVariable(&#x27;message&#x27;)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- true --&gt;&lt;p th:text=&quot;$&#123;#ctx.containsVariable(&#x27;message&#x27;)&#125;&quot;&gt;&lt;/p&gt; #vars示例： 12345678910111213141516171819&lt;!-- zh_CN --&gt;&lt;p th:text=&quot;$&#123;#vars.getLocale()&#125;&quot;&gt;&lt;/p&gt;&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=&quot;$&#123;#vars.getVariable(&#x27;message&#x27;)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- true --&gt;&lt;p th:text=&quot;$&#123;#vars.containsVariable(&#x27;message&#x27;)&#125;&quot;&gt;&lt;/p&gt;#locale示例&lt;!-- zh_CN --&gt;&lt;p th:text=&quot;$&#123;#locale&#125;&quot;&gt;&lt;/p&gt;&lt;!-- CN --&gt;&lt;p th:text=&quot;$&#123;#locale.country&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 中国 --&gt;&lt;p th:text=&quot;$&#123;#locale.displayCountry&#125;&quot;&gt;&lt;/p&gt;&lt;!-- zh --&gt;&lt;p th:text=&quot;$&#123;#locale.language&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 中文 --&gt;&lt;p th:text=&quot;$&#123;#locale.displayLanguage&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 中文 (中国) --&gt;&lt;p th:text=&quot;$&#123;#locale.displayName&#125;&quot;&gt;&lt;/p&gt; #request示例： 12345678910111213141516171819202122&lt;!-- HTTP/1.1 --&gt;&lt;p th:text=&quot;$&#123;#request.protocol&#125;&quot;&gt;&lt;/p&gt;&lt;!-- http --&gt;&lt;p th:text=&quot;$&#123;#request.scheme&#125;&quot;&gt;&lt;/p&gt;&lt;!-- localhost --&gt;&lt;p th:text=&quot;$&#123;#request.serverName&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 8080 --&gt;&lt;p th:text=&quot;$&#123;#request.serverPort&#125;&quot;&gt;&lt;/p&gt;&lt;!-- GET --&gt;&lt;p th:text=&quot;$&#123;#request.method&#125;&quot;&gt;&lt;/p&gt;&lt;!-- /standard-expression-syntax/variables --&gt;&lt;p th:text=&quot;$&#123;#request.requestURI&#125;&quot;&gt;&lt;/p&gt;&lt;!-- http://localhost:8080/standard-expression-syntax/variables --&gt;&lt;p th:text=&quot;$&#123;#request.requestURL&#125;&quot;&gt;&lt;/p&gt;&lt;!-- /standard-expression-syntax/variables --&gt;&lt;p th:text=&quot;$&#123;#request.servletPath&#125;&quot;&gt;&lt;/p&gt;&lt;!-- java.util.Collections$3@203646fe --&gt;&lt;p th:text=&quot;$&#123;#request.parameterNames&#125;&quot;&gt;&lt;/p&gt;&lt;!-- &#123;q=[Ljava.lang.String;@3308c69f&#125; --&gt;&lt;p th:text=&quot;$&#123;#request.parameterMap&#125;&quot;&gt;&lt;/p&gt;&lt;!-- q=expression --&gt;&lt;p th:text=&quot;$&#123;#request.queryString&#125;&quot;&gt;&lt;/p&gt; 注意，请求地址的 URL 参数直接通过#request.x是取不出来的，需要使用param.x语法来取出。如，URL：/standard-expression-syntax/variables?q=expression，取出 q 参数的正确姿势： 1&lt;p th:text=&quot;$&#123;param.q&#125;&quot;&gt;&lt;/p&gt; #response示例： 12345678&lt;!-- 200 --&gt;&lt;p th:text=&quot;$&#123;#response.status&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 8192 --&gt;&lt;p th:text=&quot;$&#123;#response.bufferSize&#125;&quot;&gt;&lt;/p&gt;&lt;!-- UTF-8 --&gt;&lt;p th:text=&quot;$&#123;#response.characterEncoding&#125;&quot;&gt;&lt;/p&gt;&lt;!-- text/html;charset=UTF-8 --&gt;&lt;p th:text=&quot;$&#123;#response.contentType&#125;&quot;&gt;&lt;/p&gt; #session示例： 123456&lt;!-- 2BCB2A0EACFF2D9D249D9799431B5127 --&gt;&lt;p th:text=&quot;$&#123;#session.id&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 1499786693244 --&gt;&lt;p th:text=&quot;$&#123;#session.lastAccessedTime&#125;&quot;&gt;&lt;/p&gt;&lt;!-- fanlychie --&gt;&lt;p th:text=&quot;$&#123;#session.getAttribute(&#x27;user&#x27;).name&#125;&quot;&gt;&lt;/p&gt; 注意，放到会话里面的对象直接通过#session.x是取不出来的，需要使用session.x语法来取出。如，取出会话里面的 user 对象的正确姿势： 1&lt;p th:text=&quot;$&#123;session.user.name&#125;&quot;&gt;&lt;/p&gt; 2.1.7 工具类 1234&lt;!-- false --&gt;&lt;p th:text=&quot;$&#123;#strings.isEmpty(message)&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 2017-07-12 00:37:25 --&gt;&lt;p th:text=&quot;$&#123;#dates.format(now, &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;&lt;/p&gt; 2.2 字面值所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：18、&#39;welcome&#39;等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。 2.2.1 文字字面值文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义： 1234&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=&quot;&#x27;Welcome to BeiJing!&#x27;&quot;&gt;&lt;/p&gt;&lt;!-- &#x27;Welcome to BeiJing!&#x27; --&gt;&lt;p th:text=&quot;&#x27;\\&#x27;Welcome to BeiJing!\\&#x27;&#x27;&quot;&gt;&lt;/p&gt; 2.2.2 数字字面值1234&lt;!-- 2017 --&gt;&lt;p th:text=&quot;2017&quot;&gt;&lt;/p&gt;&lt;!-- 2018 --&gt;&lt;p th:text=&quot;2017 + 1&quot;&gt;&lt;/p&gt; 2.2.3 布尔字面值1234&lt;!-- false --&gt;&lt;p th:text=&quot;1 &gt; 2&quot;&gt;&lt;/p&gt;&lt;!-- 否 --&gt;&lt;p th:text=&quot;1 &gt; 2 ? &#x27;是&#x27; : &#x27;否&#x27;&quot;&gt;&lt;/p&gt; 2.2.4 空字面值12&lt;!-- false --&gt;&lt;p th:text=&quot;$&#123;user == null&#125;&quot;&gt;&lt;/p&gt; 2.2.5 字面令牌字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）： 大写或小写的字母、中文等不含空格和特殊符号的文本 0 到 9 的数字 中括号 下划线 连字符（-） 点符号（.） 实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉： 1&lt;p th:text=&quot;Welcome to BeiJing!&quot;&gt;&lt;/p&gt; 它等效于： 1&lt;p th:text=&quot;&#x27;Welcome to BeiJing!&#x27;&quot;&gt;&lt;/p&gt; 2.3 文本操作我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换。 2.3.1 字符串连接不管是字面值还是表达式的结果，我们都可以使用+符号将它们连接起来： 12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=&quot;&#x27;Welcome to &#x27; + $&#123;location&#125; + &#x27;!&#x27;&quot;&gt;&lt;/p&gt; 2.3.2 字面值替换符号||可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用+连接符： 12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=&quot;|Welcome to $&#123;location&#125;!|&quot;&gt;&lt;/p&gt; 2.4 算术运算支持+（加）、-（减）、*（乘）、/（除）、%（模）运算： 1234567891011121314&lt;!-- 6 --&gt;&lt;p th:text=&quot;4 + 2&quot;&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=&quot;4 - 2&quot;&gt;&lt;/p&gt;&lt;!-- 8 --&gt;&lt;p th:text=&quot;4 * 2&quot;&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=&quot;4 / 2&quot;&gt;&lt;/p&gt;&lt;!-- 0 --&gt;&lt;p th:text=&quot;4 % 2&quot;&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=&quot;$&#123;pagination.page + 1&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=&quot;$&#123;pagination.page&#125; + 1&quot;&gt;&lt;/p&gt; 2.5 布尔运算支持and（且）、or（或）、!（非）、not（非）运算： 1234&lt;p th:text=&quot;$&#123;user.online and user.vip&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;user.online or user.vip&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;!user.online&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;not user.online&#125;&quot;&gt;&lt;/p&gt; 2.6 比较和相等支持&lt;（lt）、&gt;（gt）、&lt;=（le）、&gt;=（ge）、==（eq）、！=（ne）： 123456&lt;p th:text=&quot;$&#123;user.age &lt; 60&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;user.age &lt;= 60&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;user.age &gt; 18&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;user.age &gt;= 18&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;user.age == 18&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;user.age != 18&#125;&quot;&gt;&lt;/p&gt; 2.7 条件运算三元运算符：(if) ? (then) : (else) 12&lt;p th:text=&quot;$&#123;user.online ? &#x27;在线&#x27; : &#x27;离线&#x27;&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;user.online ? (user.vip ? &#x27;VIP用户在线&#x27; : &#x27;普通用户在线&#x27;) : &#x27;离线&#x27;&#125;&quot;&gt;&lt;/p&gt; 二元运算符：(value) ?: (defaultValue)。 其中，value非空（null）即真，条件为真时输出value，否则输出defaultValue。假设token = null，user.email = fanlychie@gmail.com 1234&lt;!-- 你还没有登录，请先登录 --&gt;&lt;p th:text=&quot;$&#123;token&#125; ?: &#x27;你还没有登录，请先登录&#x27;&quot;&gt;&lt;/p&gt;&lt;!-- fanlychie@gmail.com --&gt;&lt;p th:text=&quot;$&#123;user.email&#125; ?: &#x27;你还没有绑定邮箱&#x27;&quot;&gt;&lt;/p&gt; 2.8 无操作符当模板运行在服务器端时，Thymeleaf 会解析th:*属性的具体值替换标签体的内容。无操作符（_）则允许你使用原型标签体的内容作为默认值： 12&lt;!-- 你还没有登录，请先登录 --&gt;&lt;p th:text=&quot;$&#123;token&#125; ?: _&quot;&gt;你还没有登录，请先登录&lt;/p&gt; 3. 使用文本首先介绍两个最基础的th:*属th:text和th:utext，它们都是用于处理文本消息内容。 3.1 th:text在标签体中展示表达式评估结果的文本内容： 1&lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt; 使用外部化的文本内容： 1&lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;Welcome to BeiJing!&lt;/p&gt; 当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的th:text属性，而显示&lt;p&gt;标签体的文本内容Welcome to BeiJing! 当它作为模板文件运行在服务器端时，th:text属性的具体值将会替换&lt;p&gt;标签体的文本内容。 3.2 th:utext属性th:utext与th:text的区别在于： th:text默认会对含有 HTML 标签的内容进行字符转义； th:utext（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义； 假设：message = &quot;&lt;b&gt;Welcome to BeiJing!&lt;/b&gt;&quot;。 使用th:text属性： 1&lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt; th:text效果：Welcome to BeiJing! 使用th:utext属性： 1&lt;p th:utext=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt; th:utext效果：Welcome to BeiJing! 4. 设置属性值在 Thymeleaf 模板文件中，你可以使用th:*（或者使用th:attr属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以th:*-*来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用th:attrappend和th:attrprepend来追加新的值到现有的标签属性值中。 4.1 th:attr这种方式是不被推荐的，了解一下就行。下面是用th:attr=&quot;href=...&quot;来设置标签href属性的值： 1&lt;a th:attr=&quot;href=@&#123;https://www.google.com.hk&#125;&quot;&gt;谷歌一下你就知道&lt;/a&gt; 4.2 th:*显然th:attr=&quot;href=@&#123;http://www.baidu.com&#125;&quot;不够简洁，我们更推荐下面的这种语法： 1&lt;a th:href=&quot;@&#123;https://www.google.com.hk&#125;&quot;&gt;谷歌一下你就知道&lt;/a&gt; 其中th:*中的*可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的： 12&lt;!-- &lt;div item-id=&quot;1001&quot;&gt;Welcome to BeiJing!&lt;/div&gt; --&gt;&lt;div th:item-id=&quot;$&#123;user.id&#125;&quot;&gt;Welcome to BeiJing!&lt;/div&gt; 4.3 th:-如果想要同时为标签的多个不同属性设置相同的一个值，可以使用th:*-*的语法： 1&lt;img src=&quot;logo.png&quot; th:alt-title=&quot;LOGO图片&quot;&gt; 它相当于： 1&lt;img src=&quot;logo.png&quot; th:alt=&quot;LOGO图片&quot; th:title=&quot;LOGO图片&quot;&gt; 4.4 th:attrappend &amp; th:attrprependth:attrappend和th:attrprepend可以将表达式的结果分别追加到指定的属性值之后和之前。 1234&lt;!-- &lt;button class=&quot;btn enable&quot;&gt;购买&lt;/button&gt; --&gt;&lt;button class=&quot;btn&quot; th:attrappend=&quot;class=$&#123;outOfStock&#125; ? &#x27; enable&#x27; : &#x27; disable&#x27;&quot;&gt;购买&lt;/button&gt;&lt;!-- &lt;button class=&quot;enable btn&quot;&gt;购买&lt;/button&gt; --&gt;&lt;button class=&quot;btn&quot; th:attrprepend=&quot;class=$&#123;outOfStock&#125; ? &#x27;enable &#x27; : &#x27;disable &#x27;&quot;&gt;购买&lt;/button&gt; 另外，还有两个常用的具体附加属性th:classappend=&quot;...&quot;和th:styleappend=&quot;&quot;。 它们分别用来代替th:attrappend=&quot;class=...&quot;和th:attrappend=&quot;style=...&quot;。 12&lt;!-- &lt;button class=&quot;btn enable&quot;&gt;购买&lt;/button&gt; --&gt;&lt;button class=&quot;btn&quot; th:classappend=&quot;$&#123;outOfStock&#125; ? &#x27; enable&#x27; : &#x27; disable&#x27;&quot;&gt;购买&lt;/button&gt; 4.5 布尔属性在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如readonly、checked、selected等。它们若存在那就意味着值为 true。 12345678910&lt;input type=&quot;checkbox&quot; name=&quot;rememberme&quot; checked /&gt; 记住我&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; checked&gt; 男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt; 女&lt;input type=&quot;text&quot; name=&quot;appId&quot; value=&quot;J123654&quot; readonly&gt;&lt;select&gt; &lt;option selected&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt;&lt;/select&gt; Thymeleaf 也允许我们通过th:*（这里的*表示任意的布尔属性） 来选择是否使用这些布尔属性。 1&lt;input type=&quot;checkbox&quot; name=&quot;rememberme&quot; ch:checked=&quot;$&#123;rememberme&#125;&quot; /&gt; 记住我 正如你所见，如果表达式的结果为true，则自动勾选复选框，若为false，则不会自动勾选。 5. 遍历遍历（迭代）的语法th:each=&quot;自定义的元素变量名称 : $&#123;集合变量名称&#125;&quot;： 123456&lt;div&gt; &lt;spn&gt;你所在城市：&lt;/spn&gt; &lt;select name=&quot;mycity&quot;&gt; &lt;option th:each=&quot;city : $&#123;cities&#125;&quot; th:text=&quot;$&#123;city.name&#125;&quot;&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 属性th:each提供了一个用于跟踪迭代的状态变量，它包含以下几个属性： 状态变量的使用语法：th:each=&quot;自定义的元素变量名称, 自定义的状态变量名称 : $&#123;集合变量名称&#125;&quot;： 123456&lt;div&gt; &lt;spn&gt;所在城市：&lt;/spn&gt; &lt;select name=&quot;mycity&quot;&gt; &lt;option th:each=&quot;city, status : $&#123;cities&#125;&quot; th:text=&quot;$&#123;city.name&#125;&quot; th:item-index=&quot;$&#123;status.count&#125;&quot;&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 不管什么时候，Thymeleaf 始终会为每个th:each创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加Stat字符串组成： 123456&lt;div&gt; &lt;spn&gt;所在城市：&lt;/spn&gt; &lt;select name=&quot;mycity&quot;&gt; &lt;option th:each=&quot;city : $&#123;cities&#125;&quot; th:text=&quot;$&#123;city.name&#125;&quot; th:item-index=&quot;$&#123;cityStat.count&#125;&quot;&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 6. 条件判断条件判断语句有三种，分别是：th:if、th:unless、th:swith。 6.1 th:if当表达式的评估结果为真时则显示内容，否则不显示： 1&lt;a th:href=&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot; th:if=&quot;$&#123;user != null&#125;&quot;&gt;我的订单&lt;/a&gt; 真假评估的依据： 当表达式的值不为空（null）时 如果表达式的值是一个布尔类型，且值为true评估为真，否则为假 如果表达式的值是一个数字类型，且值为非0评估为真，否则为假 如果表达式的值是一个字符类型，且值为非0评估为真，否则为假 如果表达式的值是一个字符串类型，且值为非&quot;false&quot;、&quot;off&quot;、&quot;no&quot;评估为真，否则为假 如果表达式的值不是一个布尔、数字、字符或字符串评估为真 当表达式的值为空（null）时，评估结果为假 因此，上面代码我们也可以简写成： 1&lt;a th:href=&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot; th:if=&quot;$&#123;user&#125;&quot;&gt;我的订单&lt;/a&gt; 但是，为了代码的可读性，我们并不建议这样使用。 6.2 th:unlessth:unless与th:if判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示： 1&lt;a th:href=&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot; th:unless=&quot;$&#123;user == null&#125;&quot;&gt;我的订单&lt;/a&gt; 6.3 th:swith多路选择语句，它需要搭配th:case来使用： 1234&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt; &lt;p th:case=&quot;admin&quot;&gt;管理员&lt;/p&gt; &lt;p th:case=&quot;user&quot;&gt;普通用户&lt;/p&gt;&lt;/div&gt; 7. 定义局部变量使用th:with属性可以定义局部变量： 123&lt;p th:with=&quot;name=&#x27;fanlychie&#x27;&quot;&gt; &lt;span th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt; 同时定义多个局部变量时，用英文,号分隔开： 123&lt;p th:with=&quot;name=$&#123;user.name&#125;,age=&#123;user.age&#125;&quot;&gt; ......&lt;/p&gt; 8. 注释下面介绍常见的两种注释： 8.1 标准注释语法：&lt;!-- ... ---&gt;，注释的代码块会在文件源代码中显示出来。 8.1.1 单行注释1&lt;!-- &lt;span&gt;$&#123;message&#125;&lt;/span&gt; ---&gt; 8.1.2 多行注释123456&lt;!--&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt; &lt;p th:case=&quot;admin&quot;&gt;管理员&lt;/p&gt; &lt;p th:case=&quot;user&quot;&gt;普通用户&lt;/p&gt;&lt;/div&gt;---&gt; 8.2 解析器级注释语法：&lt;!--/* ... */--&gt;，注释的代码块会在引擎解析的时候抹去。 8.2.1 单行注释：1&lt;!--/* &lt;span&gt;$&#123;message&#125;&lt;/span&gt; */--&gt; 8.2.2 多行注释123456&lt;!--/*--&gt;&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt; &lt;p th:case=&quot;admin&quot;&gt;管理员&lt;/p&gt; &lt;p th:case=&quot;user&quot;&gt;普通用户&lt;/p&gt;&lt;/div&gt;&lt;!--*/--&gt; 9. 内联表达式内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用th:*标签属性。 9.1 [[…]][[]]相当于th:text，对含有 HTML 标签的内容自动进行字符转义。 1&lt;p&gt;The message is : [[$&#123;htmlContent&#125;]]&lt;/p&gt; 9.2 [(…)][()]相当于th:utext，对含有 HTML 标签的内容不进行字符转义。 1&lt;p&gt;The message is : [($&#123;htmlContent&#125;)]&lt;/p&gt; 9.3 th:inline我们已经了解到，使用[[]]和[()]语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用th:inline属性来激活，它的取值如下： 9.3.1 none12&lt;!-- [[1, 2], [3, 4]] --&gt;&lt;p th:inline=&quot;none&quot;&gt;[[1, 2], [3, 4]]&lt;/p&gt; 9.3.2 text123456&lt;!-- 北京 上海 广州 深圳 --&gt;&lt;p th:inline=&quot;text&quot;&gt; [# th:each=&quot;city : $&#123;cities&#125;&quot;] [($&#123;city.name&#125;)] [/]&lt;/p&gt; 9.3.3 css12345&lt;style th:inline=&quot;css&quot;&gt; body &#123; background-color:[[$&#123;bgColor&#125;]]; &#125;&lt;/style&gt; 9.3.4 javascript1234&lt;script th:inline=&quot;javascript&quot;&gt; var user = [[$&#123;user&#125;]]; alert(&quot;用户名：&quot; + user.name);&lt;/script&gt;","path":"2022/06/29/Spring-boot中前后端数据交互之前端对后端数据的调用-Thymeleaf的用法/","date":"06-29","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Spring boot中前后端数据交互之后端对前端数据的获取","text":"1.Springboot前后台数据传输类似于 1234567891011121314151617181920@Controller@RequestMapping(&quot;/qing&quot;)public class Controler &#123; @Autowired private Server mus; @GetMapping(&quot;/login&quot;) public String Login(Model model,HttpServletRequest request) throws Exception &#123; //oneclass,twoclass分别代表着一级分类与二级分类 String oneclass=request.getParameter(&quot;oneclass&quot;);//从前端请求到输入的数据 String twoclass=request.getParameter(&quot;twoclass&quot;);//从前端请求到输入的数据 //request.getSession().setAttribute(&quot;oneclass&quot;,oneclass); //request.getSession().setAttribute(&quot;twoclass&quot;,twoclass); //调用的业务层（server）进行处理 ArrayList&lt;Music&gt; music=mus.data(Integer.parseInt(oneclass)); //数据会存放到Model对象中，当需要生成HTML的时候，模板引擎会根据名字来定位数据 model.addAttribute(&quot;music&quot;,music); return &quot;Index02.html&quot;; &#125; 前端 1234&lt;form action=&quot;login&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;一级分类（0-12）&quot; name=&quot;oneclass&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;二级分类（名字）&quot;name=&quot;twoclass&quot;&gt; &lt;input type=&quot;submit&quot;&gt; 也可以 1234567891011121314151617用户触发点击事件&lt;div&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;一级分类&quot; onclick=&quot;creationRanking(&#x27;content&#x27;)&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;二级分类&quot; onclick=&quot;cloudWorld(&#x27;content&#x27;)&quot;&gt; &lt;/div&gt;&lt;/div&gt;去执行JS代码function creationRanking(id) &#123; $.get(&#123; url: &quot;/analyze/creation/ranking&quot;, dataType: &quot;json&quot;, method: &quot;get&quot;, ... ... &#125;) &#125; 获取前端参数的方式Model在控制器中，数据会存放到Model对象中，当需要生成HTML的时候，模板引擎会根据名字来定位数据 Attribute特征，特性，属性; Parameter界限;参数 从广义上来说，Model指的是MVC中的M，即Model(模型)。从狭义上讲，Model就是个key-value集合。实际上，上图home方法得到的model对象就是一个 java.util.Map ，你可以将Model类型替换为Map&lt;String, Object&gt; ，或者ModelMap——一个实现了Model接口的java.util.HashMap。 1234567891011public interface Model &#123; Model addAttribute(String attributeName, @Nullable Object attributeValue); Model addAttribute(Object attributeValue); Model addAllAttributes(Collection&lt;?&gt; attributeValues); Model addAllAttributes(Map&lt;String, ?&gt; attributes); Model mergeAttributes(Map&lt;String, ?&gt; attributes); boolean containsAttribute(String attributeName); @Nullable Object getAttribute(String attributeName); Map&lt;String, Object&gt; asMap();&#125; 意味着model.addattribute可以往前台传数据，可以传对象，可以传List，通过表达式 ${}可以获取到 ModelAndView的用法 123456789@RequestMapping(&quot;model&quot;)public ModelAndView testModel(String name) &#123; //构建ModelAndView实例，并设置跳转地址 ModelAndView view = new ModelAndView(&quot;test&quot;); //将数据放置到ModelAndView对象view中,第二个参数可以是任何java类型 view.addObject(&quot;name&quot;,name); //返回ModelAndView对象view return view;&#125; 当然还可以这样设置跳转地址 123ModelAndView view = new ModelAndView();view.setViewName(&quot;test&quot;);//其中的test表示templates中的test.html，springboot默认的模版文件一般都在resources/templates下 后端获取前端数据三种方式Param参数;Variable变量; 参考：http://www.javashuo.com/article/p-kkkebbuc-mv.html @RequestParam12345678910111213141516前端发出的请求：path?id=1;@RequestMapper(value=&quot;path&quot;)public void test(@RequestParam(&quot;id&quot;) int id)&#123; System.out.println(id);&#125;获取前端传来的非json格式的数据// 单个数据,@RequestParam中的值必定要与前端属性名一致public void test(@RequestParam(&quot;name)&quot; String name)&#123; System.out.println(params);&#125;// 数组数据@RequestMapper(value=&quot;path&quot;)public void test(@RequestParam Map&lt;String,Object&gt; params)&#123; System.out.println(params);&#125; @PathVariable123456789101112前端发出的请求：path/&#123;id&#125;;@RequestMapper(value=&quot;path/&#123;id&#125;&quot;)public void test(@PathVariable(&quot;id&quot;) int id)&#123; System.out.println(id);&#125;@GetMapping(&quot;/ting&quot;) public String homePageController(Model model,@PathVariable(&quot;currentIndex&quot;) int currentIndex) throws Exception&#123; ArrayList&lt;Music&gt; music=mus.data(currentIndex); model.addAttribute(&quot;music&quot;,music); // model.addAttribute(&quot;index&quot;,currentIndex); return &quot;Index01.html&quot;; &#125; @RequestBody获取前台出来的json格式的数据javascript 1234567891011121314151617181920212223242526272829303132333435363738394041424344$.ajax(&#123; type: &#x27;POST&#x27;,//方法类型 url: url, contentType: &#x27;application/json&#x27;, data: &#123; &quot;username&quot;:&quot;小明&quot;, &quot;sex&quot;:&quot;男&quot;, &quot;age&quot;:&quot;18&quot; &#125;, success: function (result) &#123; if (result == 200) &#123; $(&#x27;#goodsModal&#x27;).modal(&#x27;hide&#x27;); swal(&#123; title: swlMessage, type: &#x27;success&#x27;, showCancelButton: false, confirmButtonColor: &#x27;#1baeae&#x27;, confirmButtonText: &#x27;返回商品列表&#x27;, confirmButtonClass: &#x27;btn btn-success&#x27;, buttonsStyling: false &#125;).then(function () &#123; window.location.href = &quot;/admin/goods&quot;; &#125;) &#125; else &#123; $(&#x27;#goodsModal&#x27;).modal(&#x27;hide&#x27;); swal(result.message, &#123; icon: &quot;error&quot;, &#125;); &#125; ; &#125; &#125;);// beanpublic class User&#123; private String username; private String sex; ..&#125;// Controller中代码片断@RequestMapper(value=&quot;path/&#123;id&#125;&quot;,method = RequestMethod.POST)public void test(@RequestBody User user)&#123; System.out.println(user);&#125; 2 HttpServletRequest方法原文链接：https://blog.csdn.net/qq_43656233/article/details/103000794 很古老的方法，简单来说就是通过调用request的getParameter方法来获取参数，不建议使用 123456789101112131415161718192021222324 @Controllerpublic class indexController &#123; @GetMapping(&quot;/login&quot;) public String Login(HttpServletRequest request)&#123; String username=request.getParameter(&quot;username&quot;); String password=request.getParameter(&quot;password&quot;); Student student = new Student(username,password); request.getSession().setAttribute(&quot;username&quot;,username); request.getSession().setAttribute(&quot;password&quot;,password); return &quot;Result&quot;; &#125; @GetMapping(&quot;/&quot;) public String index()&#123; return &quot;Login&quot;; &#125;&#125;/*①getParameter()获取的是客户端设置的数据。getAttribute()获取的是服务器设置的数据。②getParameter()永远返回字符串getAttribute()返回值是任意类型*/ login页面 1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Getting Started: Handling Form Submission&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;login&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;input type=&quot;passwod&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Result页面 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;title&gt;Getting Started: Handling Form Submission&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;/head&gt; 123 &lt;p th:text=&quot;$&#123;session.username&#125;&quot;/&gt; &lt;p th:text=&quot;$&#123;session.password&#125;&quot;/&gt;&lt;/body&gt;&lt;/html&gt; HttpServletRequest与Model的区别原文链接：https://blog.csdn.net/weixin_47872288/article/details/122362891 1.1 HttpServletRequestHttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息 具体其功能函数有如下： 函数 功能getRequestURL 返回客户端请求时的完整URLgetQueryString 返回请求行中的参数部分getPathInfo 返回请求URL中的额外路径信息getRemoteAddr 返回发出请求的客户机的IP地址getRemoteHost 返回发出请求的客户机的完整主机名getRemotePort 返回客户机所使用的网络端口号getLocalAddr 返回WEB服务器的IP地址getLocalName 返回WEB服务器的主机名 model 关于model的这个类 只传输数据而不会自动寻址，由于model的每次请求会自动创建对象，所以不用newModelAndView会自动寻址，就会链接到WebCotent下的view，modelandview请求不会自动创建对象，每次使用都要new srpingMVC内部机制决定的,请求处理方法执行完成后，最终返回一个 ModelAndView 对象。 model数据最终还是写到HttpServletRequest属性中，只是model的写法更体现了MVC思想减少各层间耦合 总结Model是每次请求中都存在的默认参数，利用其addAttribute()方法即可将服务器的值传递到jsp页面中；ModelAndView包含model和view两部分，使用时需要自己实例化，利用ModelMap用来传值，也可以设置view的名称关于其写法的具体展示具体如下： 1.request.setAttribute(“name”,”manongyanjiuseng”);&#x2F;&#x2F;把值存到request其取值具体是通过request.getAttribute(“manongyanjiuseng”)2.modelMap.addAttribute(“name”,”manongyanjiuseng”);&#x2F;&#x2F;把值存到modelMap其取值具体是通过${manongyanjiuseng}3.model.addAttribute(“name”,”manongyanjiuseng”);&#x2F;&#x2F;把值存到model其取值具体是通过${manongyanjiuseng}4.request.getSession.setAttribute(“name”,”manongyanjiuseng”);&#x2F;&#x2F;先获取，在把值存到Session其取值具体是通过request.getSession().getAttribute(“manongyanjiuseng”) 以上取值中${manongyanjiuseng}这种方式是最快的 也就是model和HttpServletRequest，model的取值比较快","path":"2022/06/29/Spring-boot中前后端数据交互之后端对前端数据的获取/","date":"06-29","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"17.Springboot之Mybatis注解开发单表操作与多表联查","text":"一.Springboot之Mybatis注解开发单表操作1.1 MyBatis的常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样更加便利了操作。 @Insert：实现新增 @Update：实现更新 @Delete：实现删除 @Select：实现查询 @Result：实现结果集封装 @Results：可以与@Result 一起使用，封装多个结果集 @One：实现一对一结果集封装 @Many：实现一对多结果集封装 1.2 MyBatis的增删改查我们完成简单的student表的增删改查的操作 步骤一:持久层，在dao中创建mapper接口，Student对象类省略 12345678910111213141516171819@Mapperpublic interface StudentMapper &#123; //查询全部 @Select(&quot;SELECT * FROM student&quot;) public List&lt;Student&gt; selectAll(); //新增操作 @Insert(&quot;INSERT INTO student VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)&quot;) public Integer insert(Student stu); //修改操作 @Update(&quot;UPDATE student SET name=#&#123;name&#125;,age=#&#123;age&#125; WHERE id=#&#123;id&#125;&quot;) public Integer update(Student stu); //删除操作 @Delete(&quot;DELETE FROM student WHERE id=#&#123;id&#125;&quot;) public Integer delete(Integer id);&#125; 步骤二：业务层，Server类 1234567891011121314151617181920212223@Servicepublic class Server&#123; @Autowired private StudentMapper studentMapper; //查询全部 public List&lt;Student&gt; selectstu() &#123; return studentMapper.selectAll(); &#125; //新增操作 public Integer insertstu(Student stu)&#123; return studentMapper.insert(stu); &#125; //修改操作 public Integer updatestu(Student stu)&#123; return studentMapper.update(stu); &#125; //删除操作 public Integer delete(Integer id)&#123; return studentMapper.delete(id); &#125;&#125; 步骤三：打开springboot测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@SpringBootTestclass MybatisApplicationTests &#123; @Autowired private Server server; @Test void contextLoads() &#123; &#125; //添加测试方法 @Test void selectdome()&#123; //1.调用实现类对象中的方法，接收结果 List&lt;Student&gt; list = server.selectstu(); //2.处理结果 for (Student student : list) &#123; System.out.println(student); &#125; &#125; @Test void insertdome()&#123; //1.调用实现类对象中的方法，接收结果 Student stu = new Student(4,&quot;赵六&quot;,26); Integer result = server.insertstu(stu); //2.处理结果 System.out.println(result); &#125; @Test void updatedome()&#123; //1.调用实现类对象中的方法，接收结果 Student stu = new Student(4,&quot;赵六&quot;,26); Integer result = server.updatestu(stu); //2.处理结果 System.out.println(result); &#125; @Test void deletedome()&#123; //1.调用实现类对象中的方法，接收结果 Integer result = server.deletestu(4); //2.处理结果 System.out.println(result); &#125; &#125; 1.3 注解开发总结注解可以简化开发操作，省略映射配置文件的编写。 常用注解 @Select(“查询的 SQL 语句”)：执行查询操作注解 @Insert(“查询的 SQL 语句”)：执行新增操作注解 @Update(“查询的 SQL 语句”)：执行修改操作注解 @Delete(“查询的 SQL 语句”)：执行删除操作注解 二.MyBatis注解开发的多表操作2.1 MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 通常在@Results(………,fetchType&#x3D; FetchType.EAGER) 123456@Select(&quot;select * from test where level = 1&quot;) @Results(value = &#123; @Result(id = true,column = &quot;pid0&quot;,property = &quot;pid0&quot;), @Result(column = &quot;pid0&quot;, property = &quot;child&quot;, many = @Many(select = &quot;com.example.demo.Database.Dataselect.getpid&quot;,fetchType= FetchType.EAGER)) &#125;) List&lt;Classdify&gt; getclassification(); 2.2 一对一查询2.2.1 一对一查询的模型一对一查询的需求：查询一个用户信息，与此同时查询出该用户对应的身份证信息 2.2.2 一对一查询的语句对应的sql语句： 123SELECT * FROM card；SELECT * FROM person WHERE id=#&#123;id&#125;; 2.2.3 创建PersonMapper接口123456public interface PersonMapper &#123; //根据id查询 @Select(&quot;SELECT * FROM person WHERE id=#&#123;id&#125;&quot;) public abstract Person selectById(Integer id);&#125; 2.2.4 使用注解配置Mapper12345678910111213141516171819public interface CardMapper &#123; //查询全部 @Select(&quot;SELECT * FROM card&quot;) @Results(&#123; @Result(column = &quot;id&quot;,property = &quot;id&quot;), @Result(column = &quot;number&quot;,property = &quot;number&quot;), @Result( property = &quot;p&quot;, // 被包含对象的变量名 javaType = Person.class, // 被包含对象的实际数据类型 column = &quot;pid&quot;, // 根据查询出的card表中的pid字段来查询person表 /* one、@One 一对一固定写法 select属性：指定调用哪个接口中的哪个方法 */ one = @One(select = &quot;com.itheima.one_to_one.PersonMapper.selectById&quot;) ) &#125;) public abstract List&lt;Card&gt; selectAll();&#125; 2.2.5 测试类省略2.2.6 一对一配置总结123456789@Results：封装映射关系的父注解。 Result[] value()：定义了 Result 数组@Result：封装映射关系的子注解。 column 属性：查询出的表中字段名称 property 属性：实体对象中的属性名称 javaType 属性：被包含对象的数据类型 one 属性：一对一查询固定属性 @One：一对一查询的注解。 select 属性：指定调用某个接口中的方法 2.3 一对多查询2.3.1 一对多查询的模型一对多查询的需求：查询一个课程，与此同时查询出该该课程对应的学生信息 2.3.2 一对多查询的语句对应的sql语句： 123SELECT * FROM classesSELECT * FROM student WHERE cid=#&#123;cid&#125; 2.3.3 创建StudentMapper接口123456public interface StudentMapper &#123; //根据cid查询student表 @Select(&quot;SELECT * FROM student WHERE cid=#&#123;cid&#125;&quot;) public abstract List&lt;Student&gt; selectByCid(Integer cid);&#125; 2.3.4 使用注解配置Mapper12345678910111213141516171819public interface ClassesMapper &#123; //查询全部 @Select(&quot;SELECT * FROM classes&quot;) @Results(&#123; @Result(column = &quot;id&quot;,property = &quot;id&quot;), @Result(column = &quot;name&quot;,property = &quot;name&quot;), @Result( property = &quot;students&quot;, // 被包含对象的变量名 javaType = List.class, // 被包含对象的实际数据类型 column = &quot;id&quot;, // 根据查询出的classes表的id字段来查询student表 /* many、@Many 一对多查询的固定写法 select属性：指定调用哪个接口中的哪个查询方法 */ many = @Many(select = &quot;com.itheima.one_to_many.StudentMapper.selectByCid&quot;) ) &#125;) public abstract List&lt;Classes&gt; selectAll();&#125; 2.3.5 测试类省略2.3.6 一对多配置总结123456789@Results：封装映射关系的父注解。 Result[] value()：定义了 Result 数组@Result：封装映射关系的子注解。 column 属性：查询出的表中字段名称 property 属性：实体对象中的属性名称 javaType 属性：被包含对象的数据类型 many 属性：一对多查询固定属性@Many：一对多查询的注解。 select 属性：指定调用某个接口中的方法 2.4 多对多查询2.4.1 多对多查询的模型多对多查询的需求：查询学生以及所对应的课程信息 2.4.2 多对多查询的语句对应的sql语句： 12SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.idSELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125; 2.4.3 添加CourseMapper 接口方法123456public interface CourseMapper &#123; //根据学生id查询所选课程 @Select(&quot;SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;&quot;) public abstract List&lt;Course&gt; selectBySid(Integer id);&#125; 2.4.4 使用注解配置Mapper123456789101112131415161718192021public interface StudentMapper &#123; //查询全部 @Select(&quot;SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id&quot;) @Results(&#123; @Result(column = &quot;id&quot;,property = &quot;id&quot;), @Result(column = &quot;name&quot;,property = &quot;name&quot;), @Result(column = &quot;age&quot;,property = &quot;age&quot;), @Result( property = &quot;courses&quot;, // 被包含对象的变量名 javaType = List.class, // 被包含对象的实际数据类型 column = &quot;id&quot;, // 根据查询出student表的id来作为关联条件，去查询中间表和课程表 /* many、@Many 一对多查询的固定写法 select属性：指定调用哪个接口中的哪个查询方法 */ many = @Many(select = &quot;com.itheima.many_to_many.CourseMapper.selectBySid&quot;) ) &#125;) public abstract List&lt;Student&gt; selectAll();&#125; 2.4.5 测试类省略2.4.6 多对多配置总结123456789@Results：封装映射关系的父注解。 Result[] value()：定义了 Result 数组@Result：封装映射关系的子注解。 column 属性：查询出的表中字段名称 property 属性：实体对象中的属性名称 javaType 属性：被包含对象的数据类型 many 属性：一对多查询固定属性@Many：一对多查询的注解。 select 属性：指定调用某个接口中的方法 三.构建sql3.1 SQL 构建对象介绍 我们之前通过注解开发时，相关 SQL 语句都是自己直接拼写的。一些关键字写起来比较麻烦、而且容易出错。 MyBatis 给我们提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句 3.2 查询功能的实现 定义功能类并提供获取查询的 SQL 语句的方法。  @SelectProvider：生成查询用的 SQL 语句注解。 type 属性：生成 SQL 语句功能类对象 method 属性：指定调用方法 3.3 新增功能的实现 定义功能类并提供获取新增的 SQL 语句的方法。 @InsertProvider：生成新增用的 SQL 语句注解。 type 属性：生成 SQL 语句功能类对象 method 属性：指定调用方法 3.4 修改功能的实现 定义功能类并提供获取修改的 SQL 语句的方法。 @UpdateProvider：生成修改用的 SQL 语句注解。 type 属性：生成 SQL 语句功能类对象 method 属性：指定调用方法 3.5 删除功能的实现 定义功能类并提供获取删除的 SQL 语句的方法。 @DeleteProvider：生成删除用的 SQL 语句注解。 type 属性：生成 SQL 语句功能类对象 method 属性：指定调用方法","path":"2022/05/15/Springboot之Mybatis注解开发单表操作/","date":"05-15","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"16.Mysql常用语句","text":"Mysql数据基础语句一，基础语句1.创建数据库 1CREATE DATABASE 数据库名; 2.创建数据库表 123456789CREATE TABLE IF NOT EXISTS `webdome`( `id` VARCHAR(100) NOT NULL, `name` VARCHAR(100), `url` VARCHAR(40), `pid` VARCHAR(100), `path` VARCHAR(100), `createtime` VARCHAR(100), PRIMARY KEY ( `id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8; 实例解析： 如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。 AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。 PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 ENGINE 设置存储引擎，CHARSET 设置编码。 3.删除数据库 1drop database &lt;数据库名&gt;; 4.选择数据库 1use &lt;数据库名&gt;; 5.删除MySQL数据表 1drop table table_name 6.显示某个数据库所有表 1show tables; 7.删除 MySQL 数据表中的记录。 1delete from table_name [where clause] 8.插入数据 123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 9.查询数据通用的 SELECT 语法： 123SELECT column_name,column_nameFROM table_name[WHERE Clause] 实例： 查询某张表某列所有数据： 1select * from dept; having,用于过滤分组 1234select swjg_dm , sum(se) se from sb_zsxx group by swjg_dm having sum(se)&gt;500000 12345select * from 队员表select 姓名, 所在城市 as 球队所在城市 from 队员表,球队表where 队员表.球队名 = (select 反方球队 from 比赛表 where 比赛编号=&#x27;比赛001&#x27;)and 球队表.球队名 = (select 反方球队 from 比赛表 where 比赛编号=&#x27;比赛001&#x27;) 10.修改表中的数据 1update 表名称 set 列名称=新值 where 更新条件; 以下是在表 students 中的实例: 12345678将 id 为 5 的手机号改为默认的: update students settel=default where id=5;将所有人的年龄增加 1: update students set age=age+1;将手机号为 13288097888 的姓名改为 &quot;小明&quot;, 年龄改为 19:update students setname=&quot;小明&quot;, age=19 wheretel=&quot;13288097888&quot;; 二，连接Join1、joinjoin，其实就是“inner join”，为了简写才写成join，两个是表示一个的，内连接，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出来，这个用的情况也是挺多的，如下 12select * from kemujoin score on kemu.id = score.id 在kemu中加入score表 2、left join顾名思义，就是“左连接”，表1左连接表2，以左为主，表示以表1为主，关联上表2的数据，查出来的结果显示左边的所有数据，然后右边显示的是和左边有交集部分的数据。如下： 12select * from kemuleft join score on kemu.id = score.id 完全显示kemu表的内容，score表仅展示交集部分 2、right join “右连接”，表1右连接表2，以右为主，表示以表2为主，关联查询表1的数据，查出表2所有数据以及表1和表2有交集的数据，如下： 12select * from kemuright join score on kemu.id = score.id","path":"2022/05/15/Mysql常用语句/","date":"05-15","excerpt":"","tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"15.Java运行非Web的Springboot项目的两种方法","text":"Java运行非Web的Springboot项目的两种方法一、创建打开一个Springboot项目使用idea，选择Spring Initializr进行创建 next，这一步不要勾选 Spring Web 依赖，不然就是个 Web 项目了 1.用测试类先新建一个Server类 12345678@Servicepublic class Server &#123; public void dome() &#123; System.out.println(&quot;hello,world&quot;); &#125;&#125; 然后，在包test里有一个ApplicationTests 12345678910111213@SpringBootTestclass MybatisApplicationTests &#123; @Autowired private Server server; @Test void contextLoads() &#123; &#125; @Test void dome1()&#123; server.dome(); &#125;&#125; 运行测试类就可 2.持续运行不停止（定时任务、自动执行）如果想要让项目不停止，一直打印HelloWorld，可以在启动类 UseToTestApplication 上添加注解 @EnableScheduling ，意思为开启定时任务，这个时候启动类就不能修改成上面的getBean那样了，要改回原来的样子 然后在 controller 层的DemoControlelr里面加上注解 @Component 可以确保这个类会被定时任务扫描到，然后在下面的 demo 方法上加上 @Scheduled(fixedRate &#x3D; 1000)，意思为每1000毫秒执行一次 demo 方法1.设置启动类（加@EnableScheduling注解） 12345678910@SpringBootApplication@EnableSchedulingpublic class MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisApplication.class, args); &#125;&#125; 2.在controller类中，设置定时时间（可以设置的久一点） 12345678910@Controllerpublic class Controler &#123; @Autowired private Server server; @Scheduled(fixedRate = 100000) public void test()&#123; server.dome(); &#125;&#125; 运行启动类就可","path":"2022/05/12/Java运行非Web的Springboot项目的两种方法/","date":"05-12","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"14.SpringBoot 常用的基础注解","text":"SpringBoot 常用的基础注解什么是 Spring Boot1. Spring Boot 入门（一个简单上手的微服务框架） Spring Boot是Spring社区较新的一个项目。该项目的目的是帮助开发者更容易的创建基于Spring的应用程序和服务，让更多人的人更快的对Spring进行入门体验，让Java开发也能够实现Ruby on Rails那样的生产效率。为Spring生态系统提供了一种固定的、约定优于配置风格的框架。 Spring Boot框架的核心就是自动配置，只要存在相应的jar包，Spring就帮我们自动配置。如果默认配置不能满足需求，我们还可以替换掉自动配置类，使用我们自己的配置。另外，Spring Boot还集成了嵌入式的Web服务器，系统监控等很多有用的功，让我们快速构建企业及应用程序。 为基于Spring的开发提供更快的入门体验 开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求。 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。 Spring Boot并不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式。 基础注解介绍注入到spring容器的常见5个注解 @RestController:用于标注控制层组件(如struts中的action)，包含@Controller和@ResponseBody，当使用此注解时，不需要再在方法上使用@ResponseBody注解。 @ResponseBody 表示该方法的返回结果直接写入HTTP response body中 @Controller:用于标注是控制层组件，需要返回页面时请用@Controller而不是@RestController； 12345678@RestControllerpublic class ControllerTest &#123; @RequestMapping(&quot;/test&quot;) public String home() &#123; return &quot;home&quot;; &#125;&#125;//此时返回字符串home 12345678@Controllerpublic class ControllerTest &#123; @RequestMapping(&quot;/test&quot;) public String home() &#123; return &quot;home.html&quot;; &#125;&#125;//此时是跳转到home.html页面 @Component @Component注解用于标注一个普通的组件类，它没有明确的业务范围，只是通知Spring被此注解的类需要被纳入到Spring Bean容器中并进行管理。常与@Bean注解联用，@Bean主要的作用是告知Spring，被此注解所标注的类将需要纳入到Bean管理工厂中。@Bean注解的用法很简单，重点是@Bean注解中initMethod和destroyMethod的用法。具体请百度 @Service @Service注解是@Component的一个延伸（特例），它用于标注业务逻辑类。与@Component注解一样，被此注解标注的类，会自动被Spring所管理。 @Mapper注解的的作用 1:为了把mapper这个DAO交给Spring管理 http://412887952-qq-com.iteye.com/blog/2392672 2:为了不再写mapper映射文件 https://blog.csdn.net/weixin_39666581/article/details/103899495 3:为了给mapper接口 自动根据一个添加@Mapper注解的接口生成一个实现类 在@Mapper的接口中可用@select，@Insert，@Update，@Delete，对数据库进行增删改查通常，控制层加@Controller，业务层加@Service，持久层接口里用@Mapper，其他需要注入到spring中的用@Component@AutoWired： 它可以对类成员变量、方法及构造函数进行标注，让 spring 完成 bean 自动装配的工作。自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required&#x3D;false）时，就算找不到bean也不报错。 看dome，Man是数据库的属性类 1.Dataselect，接口类 1234567@Mapperpublic interface Dataselect &#123; //1级查询 @Select(&quot;select * from test where level = 1&quot;) List&lt;Man&gt; getclassificationFirst();&#125; 用@Autowired实例化一个私有的对象 1234567891011@Servicepublic class Servser &#123; @Autowired private Dataselect dataselect;public void selectdata() throws Exception &#123; ........... .......... dataselect.方法 //进行逻辑处理&#125;&#125; 3.Control类 1234567891011@Controller@RequestMapping(&quot;/hello&quot;)public class Control &#123; @Autowired private Servser servser; @RequestMapping(&quot;/wx&quot;) public String onPiece() throws Exception &#123; //servser.selectdata(); return &quot;dome.html&quot;; &#125; @SpringBootApplication放置在Springboot启动类上，表明该类是开启Springboot容器的入口，它是一个复合注解。里面包含了包扫描，自动注入，配置注入的功能 @RequestMapping： @RequestMapping注解的主要用途是将Web请求与请求处理类中的方法进行映射。Spring MVC和Spring WebFlux都通过RquestMappingHandlerMapping和RequestMappingHndlerAdapter两个类来提供对@RequestMapping注解的支持。 @RequestMapping注解对请求处理类中的请求处理方法进行标注；@RequestMapping注解拥有以下的六个配置属性： value:映射的请求URL或者其别名 method:兼容HTTP的方法名 params:根据HTTP参数的存在、缺省或值对请求进行过滤 header:根据HTTP Header的存在、缺省或值对请求进行过滤 consume:设定在HTTP请求正文中允许使用的媒体类型 product:在HTTP响应体中允许使用的媒体类型 最常用的是 123456789@Controller//也可@RequestMapping(value=&quot;/hi&quot;)@RequestMapping(&quot;/hi&quot;)public class ControllerTest &#123; @RequestMapping(&quot;/test&quot;) public String home() &#123; return &quot;/home.html&quot;; &#125;&#125; GetMapping@GetMapping用于将HTTP get请求映射到特定处理程序的方法注解具体来说，@GetMapping是一个组合注解，是@RequestMapping(method &#x3D; RequestMethod.GET)的缩写。 1、@RequestMapping和@GetMapping区别 @RequestMapping可以指定GET、POST请求方式 @GetMapping等价于@RequestMapping的GET请求方式 12345678910@RestController@RequestMappingpublic class HelloController &#123; //@RequestMapping(value = &quot;hello&quot;, method= RequestMethod.GET ) @GetMapping(&quot;hello&quot;) public String hello() &#123; return &quot;hello spring boot&quot;; &#125;&#125; 和前端get按钮相呼应 1234&lt;form action=&quot;login&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;一级分类（0-12）&quot; name=&quot;oneclass&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;二级分类（名字）&quot;name=&quot;twoclass&quot;&gt; &lt;input type=&quot;submit&quot;&gt; 点击会直接跳转到&#x2F;login?oneclass&#x3D;&amp;twoclass&#x3D;~页面 PostMapping@PostMapping用于将HTTP post请求映射到特定处理程序的方法注解具体来说，@PostMapping是一个组合注解，是@RequestMapping(method &#x3D; RequestMethod.POST)的缩写 @Configuration 指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上。 @Bean 相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。","path":"2022/05/12/SpringBoot-常用的基础注解/","date":"05-12","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"13.JavaEE软件开发体系的三层架构与Spring","text":"标准的JAVAEE开发是按照三层架构来的，即表现层，业务层，持久层。 表现层，常见的mvc1234也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求 web 层，web 需要接收 http 请求，完成 http 响应。表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） mvc（ model模型层，View视图层，controller控制层） 这里介绍一下spring mvc 1234SpringMVC是基于Spring的，是Spring中的一个模块，专门用来做web开发使用的。 SpringMVC 也叫 Spring web mvc。是 Spring 框架的一部分，是在Spring3.0 后发布的。基于 MVC 架构，功能分工明确、解耦合。SpringMVC也是一个容器，使用IoC核心技术，管理界面层中的控制器对象。SpringMVC的底层就是servlet，以servlet为核心，接收请求、处理请求，显示处理结果给用户。在此之前这个功能是由Servlet来实现的，现在使用SpringMVC来代替Servlet行驶控制器的角色和功能。其核心Servlet是：DispatcherServlet 12345优点：1. 基于 MVC 架构，功能分工明确。解耦合。2.容易理解，上手快；使用简单。就可以开发一个注解的 SpringMVC 项目，SpringMVC 也是轻量级的，jar 很小。不依赖的特定的接口和类。3.作为 Spring 框架一部分，能够使用 Spring 的 IoC 和 Aop。方便整合Strtus，MyBatis，Hiberate, JPA 等其他框架。4.SpringMVC 强化注解的使用，在控制器，Service，Dao 都可以使用注解。方便灵活。使用@Controller 创建处理器对象,@Service 创建业务对象，@Autowired 或者@Resource 在控制器类中注入 Service, Service 类中注入Dao。 spring mvc原文链接：https://blog.csdn.net/liuhaiyang98/article/details/119617803 业务层12也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制） （Struts2+Spring+Hibernate）（也就是SSH），（Spring+SpringMVC+MyBatis）SSM 持久层12也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。 持久层框架是对JDBC代码进行了封装，这样是Java程序员写起来就比较容易，我了解的有jpa，mybatis，Hibernate几种 数据库持久层，这三者是主流，这三者到底有什么区别和优略呢？ 一、技术简述 1、Spring Data JPA与Hibernate Spring Data JPA是Spring Data的子模块。使用Spring Data，使得基于“repositories”概念的JPA实现更简单和容易。Spring Data JPA的目标是大大简化数据访问层代码的编码。作为使用者，我们只需要编写自己的repository接口，接口中包含一些个性化的查询方法，Spring Data JPA将自动实现查询方法。 JPA默认使用Hibernate作为ORM实现，所以，一般使用Spring Data JPA即会使用Hibernate。 我们再看看Hibernate的官方概念，Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的ORM框架，Hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 2、MyBatis MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Objects,普通的 Java对象)映射成数据库中的记录。 持久层具体请看，原文链接：https://blog.csdn.net/xihuanyuye/article/details/81201441 持久层详细参考： https://blog.csdn.net/qq897958555/article/details/53208002 个人推荐，MyBatis 总结​ 分层的目的是为了解耦，解耦就是为了降低代码的耦合度，方便项目后期的维护和升级。 ​ 参考：https://blog.csdn.net/m0_52994499/article/details/120443982 标准的包名，类名12345678910controller(控制台)service（业务层接口）serviceimpl（业务层实现）dao(持久层接口)daoimpl（持久层实现）action（action）util（工具类包）bean（实体类包）filter（过滤器）interceptor（拦截器） 简单介绍一下SpringSpring是一个开放源代码的设计层面框架，解决业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。上述总结来说，Spring是一个分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源框架。 Spring框架特征Spring是一个轻量级且非侵入式的开源框架 。Spring是包含并管理应用对象的配置和生命周期的一种容器。Spring是可以将简单的组件配置、组合成为复杂的应用的框架。Spring通过控制反转(IoC) 促进了低耦合。Spring提供了面向切面编程(AOP) 的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发。 总结： Spring是一个轻量级非侵入式的控制反转(IoC)和面向切面(AOP)的开源容器（框架）。Spring框架组成Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式. 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 1234567Spring Core(核心容器)：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。Spring Context(上下文)：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。Spring AOP(面向切片)：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 重要拓展：Spring Boot与Spring CloudSpring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务。Spring Cloud是基于Spring Boot实现的。Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架。Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。","path":"2022/05/09/JavaEE软件开发体系的三层架构/","date":"05-09","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"12.Java用反射获取jar包中的属性和方法","text":"1.使用概要：1234File file =new File(jar文件全路径); URL url = file.toURI().toURL();URLClassLoader loader = new URLClassLoader(new URL[] &#123;url&#125;); Class tidyClazz = loader.loadClass(所需class的含包名的全名); 详细说明： 我们知道，Java利用ClassLoader将类载入内存，并且在同一应用中，可以有很多个ClassLoader，通过委派机制，把装载的任务传递给上级的装载器的，依次类推，直到启动类装载器（没有上级类装载器）。如果启动类装载器能够装载这个类，那么它会首先装载。如果不能，则往下传递。当父类为null时，JVM内置的类(称为:bootstrap class loader)就会充当父类。想想眼下的越来越多用XML文件做配置文件或者是描述符、部署符。其实这些通过XML文档描述的配置信息最终都要变成Java类，其实都是通过ClassLoader来完成的。URLClassLoader是ClassLoader的子类，它用于从指向 JAR 文件和目录的 URL 的搜索路径加载类和资源。也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中 2.另一种方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package dome;import java.lang.reflect.Method;import java.util.Enumeration;import java.util.jar.JarEntry;import java.util.jar.JarFile;/** * @author cb * @create 2022-05-2022/5/7 23:55 */public class Hook &#123; public static void main(String[] args) throws Exception &#123; String path = &quot;C:\\\\Users\\\\26257\\\\Desktop\\\\&quot;; String fileName = &quot;dome-1.0-SNAPSHOT.jar&quot;; //通过jarFile和JarEntry得到所有的类 JarFile jarFile = new JarFile(path + fileName); //返回zip文件条目的枚举 Enumeration&lt;JarEntry&gt; e = jarFile.entries(); JarEntry entry; //测试此枚举是否包含更多的元素 while (e.hasMoreElements()) &#123; entry = (JarEntry) e.nextElement(); //下文介绍，判断是否时完整的jar包 if (entry.getName().indexOf(&quot;META-INF&quot;) &lt; 0 &amp;&amp; entry.getName().indexOf(&quot;.class&quot;) &gt;= 0) &#123; String classFullName = entry.getName(); //去掉后缀.class String className = classFullName.substring(0, classFullName.length() - 6).replace(&quot;/&quot;, &quot;.&quot;); System.out.println(className); Class&lt;?&gt; c = Class.forName(className); Method[] methods = c.getDeclaredMethods(); /*System.out.println(methods); //取消Java语言访问权限检查 methods[1].setAccessible(true); for (Method method : methods) &#123; String methodName = method.getName(); System.out.println(&quot;方法名称:&quot; + methodName); System.out.println(&quot;返回值类型&quot; + method.getReturnType()); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); for (Class&lt;?&gt; clas : parameterTypes) &#123; // String parameterName = clas.getName(); String parameterName = clas.getSimpleName(); System.out.println(&quot;参数类型:&quot; + parameterName); &#125; System.out.println(&quot;==========================&quot;); &#125; &#125; &#125; &#125;&#125; dome并还未替换其原有方法，测试了一下方法的调用 总结如下：执行jar包的main方法时，注意main方法的参数： 123//可取消Java语言访问权限检查method.setAccessible(true);method.invoke(null, new Object[]&#123;new String[]&#123;&#125;&#125;); 其他方法时 12Object obj = c.newInstance();method.invoke(obj,无参不写); 123if (entry.getName().indexOf(&quot;META-INF&quot;) &lt; 0 &amp;&amp; entry.getName().indexOf(&quot;.class&quot;) &gt;= 0) &#123;...........&#125; 无论是在打jar或war包时，都会生成META-INFO这个文件夹。我们需要了解这个路径，丰富自己的知识框架。 官方一点的说法：META-INF 相当于一个信息包，目录中的文件和目录获得 Java 2 平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务manifest.mf文件，在打包时自动生成。 简单的说法：就是存储了项目的元信息，其中文件manifest.mf仅此一份，描述了程序的基本信息、Main-Class的入口、jar依赖路径Class-Path。","path":"2022/05/09/Java用反射获取jar包中的属性和方法/","date":"05-09","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"11.Java 反射机制之Hook实例","text":"Java 反射之Hook 实例Hook 机制主要是通过反射机制，在运行时改变某个对象的属性或者行为 参考：https://www.jianshu.com/p/a69983752f29 实例 1234567891011一.首先三个类1.Weapon类，武器类2.Hero类，英雄类3.Game类，游戏开始，实现方法游戏过程是英雄拿着不同的武器会有不同的伤害值二.Hook开始（替换原有的方法，使伤害值增加，加一个监听，获取数据）1.Hero类保存不变2.WeaponHook 继承Weapon， 并且在attack方法中设置回调3.GameHook 反射注入 WeaponHook对象三.防止Hook1.HeroPro 增加hashcode判断 1.Weapon类，武器类 1234567891011package com.hook;/** * @author cb * @create 2022-05-2022/5/9 14:06 */public class Weapon &#123; protected int damage = 10; public void attack()&#123; System.out.println(&quot;对目标形成&quot;+damage+&quot;点伤害&quot;); &#125;&#125; 2.Hero类，英雄类 1234567891011121314package com.hook;/** * @author cb * @create 2022-05-2022/5/9 14:07 */public class Hero &#123; private Weapon weaponMain; public Hero(Weapon weaponMain) &#123; this.weaponMain = weaponMain; &#125; public void attack()&#123; weaponMain.attack(); &#125;&#125; 3.Game类，游戏开始，实现方法 123456public class Game &#123; public static void main(String[] args)&#123; Hero hero = new Hero(new Weapon()); hero.attack(); &#125;&#125; 结果: 12对目标形成10点伤害Process finished with exit code 0 Hook开始 1.Hero类保存不变2.WeaponHook 继承Weapon， 并且在attack方法中设置回调 12345678910111213141516171819202122232425//对于上面这段程序，游戏对咱们隐藏了Weapon的伤害值，但如今咱们想要在每次攻击的时候知道这个伤害值是多少。//下面看看使用Hook机制如何来实现。//首先咱们经过观察，发现切入点就是weaponMain，咱们要对它下手。//建立一个Weapon的复制品WeaponHook，咱们须要用本身的人WeaponHook打入内部。//WeaponHook一切看起来都和Weapon那么类似，可是咱们给它留了一个后门，使得咱们能够进行监控。public class WeaponHook extends Weapon &#123; private OnUseWeaponAttackListener onUseWeaponAttackListener; @Override public void attack()&#123; //修改伤害数值 damage+=5; super.attack(); System.out.println(&quot;WeaponHook has called Weapon.attach&quot;); if (onUseWeaponAttackListener != null)&#123; onUseWeaponAttackListener.onUseWeaponAttack(damage); &#125; &#125; public void setOnUseWeaponAttackListener(OnUseWeaponAttackListener onUseWeaponAttackListener) &#123; this.onUseWeaponAttackListener = onUseWeaponAttackListener; &#125; //这就是咱们的后门 public static interface OnUseWeaponAttackListener &#123; int onUseWeaponAttack(int damage); &#125;&#125; 3.GameHook 反射注入 WeaponHook对象 1234567891011121314151617181920212223242526272829303132import java.lang.reflect.Field;/** * @author cb * @create 2022-05-2022/5/9 14:31 */public class GameHook &#123; public static void main(String[] args)&#123; Hero hero = new Hero(new Weapon()); //HeroPro heropro = new HeroPro(new Weapon()); try &#123; //Field weapon = ReflectUtils.getVariable(hero.getClass(), &quot;weaponMain&quot;); Class&lt;?&gt; heroClass = hero.getClass(); //Field weapon = heroClass.getField(&quot;weaponMain&quot;);// 不包含私有属性 Field weapon = heroClass.getDeclaredField(&quot;weaponMain&quot;);// 包含私有属性 weapon.setAccessible(true); Weapon weaponHook = new WeaponHook(); ((WeaponHook) weaponHook).setOnUseWeaponAttackListener(damage -&gt; &#123; //经过后门进行操做，这其实就是咱们注入的代码 System.out.println(&quot;damage = &quot; + damage); return damage; &#125;); weapon.set(hero, weaponHook); //偷天换日 &gt;&gt;&gt; 关键操作，替换掉原来的成员变量 (属性.set(对象，新的成员变量的对象)) hero.attack(); //最终调用的是 weaponHook &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果: 1234对目标形成15点伤害WeaponHook has called Weapon.attachdamage = 15Process finished with exit code 0 三.防止Hook1.HeroPro 增加hashcode判断 12345678910111213141516public class HeroPro &#123; private Weapon weaponMain; private final int weaponMainId; public HeroPro(Weapon weaponMain) &#123; this.weaponMain = weaponMain; weaponMainId = this.weaponMain.hashCode();//记录原始Weapon对象的Id，hashCode对于每一个对象而言都是惟一的。 &#125; public void attack() &#123; if (this.weaponMain.hashCode() != weaponMainId) &#123; //关键位置检查是否遭到替换 throw new IllegalAccessError(String.format(&quot;警告！遭到入侵！入侵者身份:%d&quot;, this.weaponMain.hashCode())); &#125; weaponMain.attack(); &#125;&#125; 再次Hook实验 12345678910111213141516171819202122232425public class GameHook &#123; public static void main(String[] args)&#123; //Hero hero = new Hero(new Weapon()); HeroPro heropro = new HeroPro(new Weapon()); try &#123; //Field weapon = ReflectUtils.getVariable(hero.getClass(), &quot;weaponMain&quot;); Class&lt;?&gt; heroClass = heropro.getClass(); //Field weapon = heroClass.getField(&quot;weaponMain&quot;);// 不包含私有属性 Field weapon = heroClass.getDeclaredField(&quot;weaponMain&quot;);// 包含私有属性 weapon.setAccessible(true); Weapon weaponHook = new WeaponHook(); ((WeaponHook) weaponHook).setOnUseWeaponAttackListener(damage -&gt; &#123; //经过后门进行操做，这其实就是咱们注入的代码 System.out.println(&quot;damage = &quot; + damage); return damage; &#125;); weapon.set(heropro, weaponHook); //偷天换日 &gt;&gt;&gt; 关键操作，替换掉原来的成员变量 (属性.set(对象，新的成员变量的对象)) heropro.attack(); //最终调用的是 weaponHook &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果： 123456Exception in thread &quot;main&quot; java.lang.IllegalAccessError: 警告！遭到入侵！入侵者身份:363771819 at com.hook.HeroPro.attack(HeroPro.java:18) at com.hook.GameHook.main(GameHook.java:26)Process finished with exit code 1","path":"2022/05/09/Java-反射机制之Hook实例/","date":"05-09","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"10.反射机制","text":"1.反射1.1反射的概述 反射机制 是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意属性和方法；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。 1.2获取Class类对象的三种方式【应用】 三种方式分类 类名.class属性 对象名.getClass()方法 Class.forName(全类名)方法 示例代码 123456789101112131415161718192021222324252627282930313233343536373839public class Student &#123; private String name; private int age; //无参加有参构造方法省略 //set,get方法省略 public void study()&#123; System.out.println(&quot;学生在学习&quot;); &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //1.Class类中的静态方法forName(&quot;全类名&quot;) //全类名:包名 + 类名 Class clazz = Class.forName(&quot;dome1.Student&quot;); System.out.println(clazz); //2.通过class属性来获取 Class clazz2 = Student.class; System.out.println(clazz2); //3.利用对象的getClass方法来获取class对象 //getClass方法是定义在Object类中. Student s = new Student(); Class clazz3 = s.getClass(); System.out.println(clazz3); System.out.println(clazz == clazz2); System.out.println(clazz2 == clazz3); &#125;&#125; 结果 12345class dome1.Studentclass dome1.Studentclass dome1.Studenttruetrue 1.3反射获取构造方法并使用【应用】1.3.1Class类获取构造方法对象的方法 方法介绍 方法名 说明 Constructor&lt;?&gt;[] getConstructors() 返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回所有构造方法对象的数组 Constructor getConstructor(Class&lt;?&gt;… parameterTypes) 返回单个公共构造方法对象 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回单个构造方法对象 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package dome1;import java.lang.reflect.Constructor;/** * @author cb * @create 2022-05-2022/5/7 22:42 */public class Student &#123; private String name; private int age; //私有的有参构造方法 private Student(String name) &#123; System.out.println(&quot;name的值为:&quot; + name); System.out.println(&quot;private...Student...有参构造方法&quot;); &#125; //公共的无参构造方法 public Student() &#123; System.out.println(&quot;public...Student...无参构造方法&quot;); &#125; //公共的有参构造方法 public Student(String name, int age) &#123; System.out.println(&quot;name的值为:&quot; + name + &quot;age的值为:&quot; + age); System.out.println(&quot;public...Student...有参构造方法&quot;); &#125;&#125; class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; System.out.println(&quot;方法1：&quot;); method1(); System.out.println(&quot;方法2：&quot;); method2(); //method3(); System.out.println(&quot;方法4：&quot;); method4(); &#125; private static void method1() throws ClassNotFoundException &#123; // Constructor&lt;?&gt;[] getConstructors()：// 返回所有公共构造方法对象的数组 //1.获取Class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); Constructor[] constructors = clazz.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; &#125; private static void method2() throws ClassNotFoundException &#123; // Constructor&lt;?&gt;[] getDeclaredConstructors()：// 返回所有构造方法对象的数组 //1.获取Class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; &#125; private static void method3() throws ClassNotFoundException, NoSuchMethodException &#123; // Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：// 返回单个公共构造方法对象 //1.获取Class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //小括号中,一定要跟构造方法的形参保持一致. Constructor constructor1 = clazz.getConstructor(); System.out.println(constructor1); Constructor constructor2 = clazz.getConstructor(String.class, int.class); System.out.println(constructor2); //因为Student类中,没有只有一个int的构造,所以这里会报错. Constructor constructor3 = clazz.getConstructor(int.class); System.out.println(constructor3); &#125; private static void method4() throws ClassNotFoundException, NoSuchMethodException &#123; // Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)：// 返回单个构造方法对象 //1.获取Class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); Constructor constructor = clazz.getDeclaredConstructor(String.class); System.out.println(constructor); &#125; &#125; 结果 123456789方法1：public dome1.Student()public dome1.Student(java.lang.String,int)方法2：private dome1.Student(java.lang.String)public dome1.Student()public dome1.Student(java.lang.String,int)方法4：private dome1.Student(java.lang.String) 1.3.2Constructor类用于创建对象的方法 方法介绍 方法名 说明 T newInstance(Object…initargs) 根据指定的构造方法创建对象 setAccessible(boolean flag) 设置为true,表示取消访问检查 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Student类同上一个示例,这里就不在重复提供了public class ReflectDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; //T newInstance(Object... initargs)：根据指定的构造方法创建对象 //method1(); //method2(); //method3(); //method4(); &#125; private static void method4() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; //获取一个私有的构造方法并创建对象 //1.获取class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //2.获取一个私有化的构造方法. Constructor constructor = clazz.getDeclaredConstructor(String.class); //被private修饰的成员,不能直接使用的 //如果用反射强行获取并使用,需要临时取消访问检查 constructor.setAccessible(true); //3.直接创建对象 Student student = (Student) constructor.newInstance(&quot;zhangsan&quot;); System.out.println(student); &#125; private static void method3() throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; //简写格式 //1.获取class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //2.在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象 Student student = (Student) clazz.newInstance();//这个方法现在已经过时了,了解一下 System.out.println(student); &#125; private static void method2() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; //1.获取class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //2.获取构造方法对象 Constructor constructor = clazz.getConstructor(); //3.利用空参来创建Student的对象 Student student = (Student) constructor.newInstance(); System.out.println(student); &#125; private static void method1() throws ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; //1.获取class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //2.获取构造方法对象 Constructor constructor = clazz.getConstructor(String.class, int.class); //3.利用newInstance创建Student的对象 Student student = (Student) constructor.newInstance(&quot;zhangsan&quot;, 23); System.out.println(student); &#125;&#125; 2.3.3小结 获取class对象 三种方式: Class.forName(“全类名”), 类名.class, 对象名.getClass() 获取里面的构造方法对象 getConstructor (Class... parameterTypes) getDeclaredConstructor (Class… parameterTypes) 如果是public的，直接创建对象 newInstance(Object… initargs) 如果是非public的，需要临时取消检查，然后再创建对象 setAccessible(boolean) 暴力反射 1.4反射获取成员变量并使用【应用】1.4.1Class类获取成员变量对象的方法 方法分类 方法名 说明 Field[] getFields() 返回所有公共成员变量对象的数组 Field[] getDeclaredFields() 返回所有成员变量对象的数组 Field getField(String name) 返回单个公共成员变量对象 Field getDeclaredField(String name) 返回单个成员变量对象 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Student &#123; public String name; public int age; public String gender; private int money = 300; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123; // method1(); //method2(); //method3(); //method4(); &#125; private static void method4() throws ClassNotFoundException, NoSuchFieldException &#123; // Field getDeclaredField(String name)：返回单个成员变量对象 //1.获取class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //2.获取money成员变量 Field field = clazz.getDeclaredField(&quot;money&quot;); //3.打印一下 System.out.println(field); &#125; private static void method3() throws ClassNotFoundException, NoSuchFieldException &#123; // Field getField(String name)：返回单个公共成员变量对象 //想要获取的成员变量必须是真实存在的 //且必须是public修饰的. //1.获取class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //2.获取name这个成员变量 //Field field = clazz.getField(&quot;name&quot;); //Field field = clazz.getField(&quot;name1&quot;); Field field = clazz.getField(&quot;money&quot;); //3.打印一下 System.out.println(field); &#125; private static void method2() throws ClassNotFoundException &#123; // Field[] getDeclaredFields()：返回所有成员变量对象的数组 //1.获取class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //2.获取所有的Field对象 Field[] fields = clazz.getDeclaredFields(); //3.遍历 for (Field field : fields) &#123; System.out.println(field); &#125; &#125; private static void method1() throws ClassNotFoundException &#123; // Field[] getFields()：返回所有公共成员变量对象的数组 //1.获取class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //2.获取Field对象. Field[] fields = clazz.getFields(); //3.遍历 for (Field field : fields) &#123; System.out.println(field); &#125; &#125;&#125; 1.4.2Field类用于给成员变量赋值的方法 方法介绍 方法名 说明 void set(Object obj, Object value) 赋值 Object get(Object obj) 获取值 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Student类同上一个示例,这里就不在重复提供了public class ReflectDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException &#123;// Object get(Object obj) 返回由该 Field表示的字段在指定对象上的值。 //method1(); //method2(); &#125; private static void method2() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException &#123; //1.获取class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //2.获取成员变量Field的对象 Field field = clazz.getDeclaredField(&quot;money&quot;); //3.取消一下访问检查 field.setAccessible(true); //4.调用get方法来获取值 //4.1创建一个对象 Student student = (Student) clazz.newInstance(); //4.2获取指定对象的money的值 Object o = field.get(student); //5.打印一下 System.out.println(o); &#125; private static void method1() throws ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException &#123; // void set(Object obj, Object value)：给obj对象的成员变量赋值为value //1.获取class对象 Class clazz = Class.forName(&quot;dome1.Student&quot;); //2.获取name这个Field对象 Field field = clazz.getField(&quot;name&quot;); //3.利用set方法进行赋值. //3.1先创建一个Student对象 Student student = (Student) clazz.newInstance(); //3.2有了对象才可以给指定对象进行赋值 field.set(student,&quot;zhangsan&quot;); System.out.println(student); &#125;&#125; 1.5反射获取成员方法并使用【应用】1.5.1Class类获取成员方法对象的方法 方法分类 方法名 说明 Method[] getMethods() 返回所有公共成员方法对象的数组，包括继承的 Method[] getDeclaredMethods() 返回所有成员方法对象的数组，不包括继承的 Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回单个公共成员方法对象 Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回单个成员方法对象 示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class Student &#123; //私有的，无参无返回值 private void show() &#123; System.out.println(&quot;私有的show方法，无参无返回值&quot;); &#125; //公共的，无参无返回值 public void function1() &#123; System.out.println(&quot;function1方法，无参无返回值&quot;); &#125; //公共的，有参无返回值 public void function2(String name) &#123; System.out.println(&quot;function2方法，有参无返回值,参数为&quot; + name); &#125; //公共的，无参有返回值 public String function3() &#123; System.out.println(&quot;function3方法，无参有返回值&quot;); return &quot;aaa&quot;; &#125; //公共的，有参有返回值 public String function4(String name) &#123; System.out.println(&quot;function4方法，有参有返回值,参数为&quot; + name); return &quot;aaa&quot;; &#125;&#125;public class ReflectDemo1 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; //method1(); //method2(); //method3(); //method4(); //method5(); &#125; private static void method5() throws ClassNotFoundException, NoSuchMethodException &#123; // Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)：// 返回单个成员方法对象 //1.获取class对象 Class clazz = Class.forName(&quot;com.itheima.myreflect5.Student&quot;); //2.获取一个成员方法show Method method = clazz.getDeclaredMethod(&quot;show&quot;); //3.打印一下 System.out.println(method); &#125; private static void method4() throws ClassNotFoundException, NoSuchMethodException &#123; //1.获取class对象 Class clazz = Class.forName(&quot;com.itheima.myreflect5.Student&quot;); //2.获取一个有形参的方法function2 Method method = clazz.getMethod(&quot;function2&quot;, String.class); //3.打印一下 System.out.println(method); &#125; private static void method3() throws ClassNotFoundException, NoSuchMethodException &#123; // Method getMethod(String name, Class&lt;?&gt;... parameterTypes) ：// 返回单个公共成员方法对象 //1.获取class对象 Class clazz = Class.forName(&quot;com.itheima.myreflect5.Student&quot;); //2.获取成员方法function1 Method method1 = clazz.getMethod(&quot;function1&quot;); //3.打印一下 System.out.println(method1); &#125; private static void method2() throws ClassNotFoundException &#123; // Method[] getDeclaredMethods()：// 返回所有成员方法对象的数组，不包括继承的 //1.获取class对象 Class clazz = Class.forName(&quot;com.itheima.myreflect5.Student&quot;); //2.获取Method对象 Method[] methods = clazz.getDeclaredMethods(); //3.遍历一下数组 for (Method method : methods) &#123; System.out.println(method); &#125; &#125; private static void method1() throws ClassNotFoundException &#123; // Method[] getMethods()：返回所有公共成员方法对象的数组，包括继承的 //1.获取class对象 Class clazz = Class.forName(&quot;com.itheima.myreflect5.Student&quot;); //2.获取成员方法对象 Method[] methods = clazz.getMethods(); //3.遍历 for (Method method : methods) &#123; System.out.println(method); &#125; &#125;&#125; 1.5.2Method类用于执行方法的方法 方法介绍 方法名 说明 Object invoke(Object obj, Object… args) 运行方法 参数一: 用obj对象调用该方法 参数二: 调用方法的传递的参数(如果没有就不写) 返回值: 方法的返回值(如果没有就不写) 示例代码 1234567891011121314151617181920public class ReflectDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;// Object invoke(Object obj, Object... args)：运行方法// 参数一：用obj对象调用该方法// 参数二：调用方法的传递的参数（如果没有就不写）// 返回值：方法的返回值（如果没有就不写） //1.获取class对象 Class clazz = Class.forName(&quot;com.itheima.myreflect5.Student&quot;); //2.获取里面的Method对象 function4 Method method = clazz.getMethod(&quot;function4&quot;, String.class); //3.运行function4方法就可以了 //3.1创建一个Student对象,当做方法的调用者 Student student = (Student) clazz.newInstance(); //3.2运行方法 Object result = method.invoke(student, &quot;zhangsan&quot;); //4.打印一下返回值 System.out.println(result); &#125;&#125;","path":"2022/05/07/反射机制/","date":"05-07","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"9.ServerSocket与Socket之间的通讯Dome","text":"1.ServerSocket 123456789101112131415161718192021222324252627282930313233343536373839import java.io.*;import java.net.ServerSocket;import java.net.Socket;public class Main &#123; public static void main(String[] args) throws IOException &#123; try&#123; ServerSocket server=null; try&#123; //创建一个ServerSocket在端口2105监听客户请求 server=new ServerSocket(2105); &#125;catch(Exception e)&#123; e.printStackTrace();//出错，打印出错信息 &#125; Socket socket=null; try&#123; //使用accept()阻塞等待客户请求，有客户 socket=server.accept();//请求到来则产生一个Socket对象，并继续执行 &#125;catch(Exception e)&#123; e.printStackTrace();//出错，打印出错信息 &#125; BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream())); //由Socket对象得到输出流，并构造PrintWriter对象 PrintWriter os=new PrintWriter(socket.getOutputStream()); //由系统标准输入设备构造BufferedReader对象 while(true)&#123; String s = is.readLine(); System.out.println(&quot;Client:&quot;+s); os.println(&quot;收到！&quot;); os.flush(); &#125; &#125;catch(Exception e)&#123; e.printStackTrace();//出错，打印出错信息 &#125; &#125;&#125; 2.Socket 1234567891011121314151617181920212223242526272829303132333435363738import java.io.*;import java.net.Socket;public class Socket01 &#123; public static void main(String[] args) throws IOException &#123; try&#123; //向本机的2105端口发出客户请求 Socket socket=new Socket(&quot;192.168.31.162&quot;,2105); //由系统标准输入设备构造BufferedReader对象 BufferedReader sin=new BufferedReader(new InputStreamReader(System.in)); //由Socket对象得到输出流，并构造PrintWriter对象 PrintWriter os=new PrintWriter(socket.getOutputStream()); //由Socket对象得到输入流，并构造相应的BufferedReader对象 BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream())); String readline; readline=sin.readLine(); //从系统标准输入读入一字符串 //若从标准输入读入的字符串为 &quot;bye&quot;则停止循环 while(!readline.equals(&quot;bye&quot;))&#123; //将从系统标准输入读入的字符串输出到Server os.println(readline); //刷新输出流，使Server马上收到该字符串 os.flush(); //在系统标准输出上打印读入的字符串 System.out.println(&quot;Client:&quot;+readline); //从Server读入一字符串，并打印到标准输出上 System.out.println(&quot;Server:&quot;+is.readLine()); readline=sin.readLine(); //从系统标准输入读入一字符串 &#125; os.close(); //关闭Socket输出流 is.close(); //关闭Socket输入流 socket.close(); //关闭Socket &#125;catch(Exception e)&#123; e.printStackTrace();//出错，打印出错信息 &#125; &#125; &#125;","path":"2022/05/07/ServerSocket与Socket之间的通讯Dome/","date":"05-07","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"8.Java线程池","text":"Java线程池1、new Thread的弊端 123a. 每次new Thread新建对象性能差。 b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom（out of memory）。 c. 缺乏更多功能，如定时执行、定期执行、线程中断。 相比new Thread，Java提供的四种线程池的好处在于： a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。 b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 c. 提供定时执行、定期执行、单线程、并发数控制等功能。 2、Java 线程池Java通过Executors提供四种线程池，分别为： 1234newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 (1) newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下： 123456789101112131415ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; try &#123; Thread.sleep(index * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; cachedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; log.info(index); &#125; &#125;); &#125; 线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。 (2) newFixedThreadPool：— 需要指定线程池的大小创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下： 12345678910111213141516ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; log.info(index); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;);&#125; 因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。 定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。 (3)newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下： 1234567ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.schedule(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;delay 3 seconds&quot;); &#125; &#125;, 3, TimeUnit.SECONDS); 表示延迟3秒执行。 定期执行示例代码如下： 123456scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;delay 1 seconds, and excute every 3 seconds&quot;); &#125; &#125;, 1, 3, TimeUnit.SECONDS); 表示延迟1秒后每3秒执行一次。 ScheduledExecutorService比Timer更安全，功能更强大 (4)newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下： 12345678910111213141516ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();for (int i = 0; i &lt; 10; i++) &#123; final int index = i; singleThreadExecutor.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; log.info(index); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;);&#125; 结果依次输出，相当于顺序执行各个任务。 线程池的作用：线程池作用就是限制系统中执行线程的数量。 根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。 为什么要用线程池:1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的 线程池接口是ExecutorService。 比较重要的几个类：ExecutorService： 真正的线程池接口。 ScheduledExecutorService： 能和Timer&#x2F;TimerTask类似，解决那些需要任务重复执行的问题。 ThreadPoolExecutor： ExecutorService的默认实现。 ScheduledThreadPoolExecutor： 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。 原文链接：https://blog.csdn.net/qq_35275233/article/details/87893337","path":"2022/05/03/Java线程池/","date":"05-03","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"7.Java多线程","text":"Java 多线程 新建状态: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态: 如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态: 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态。 死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 1.优先级 每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 12aa.setPriority(1); bb.setPriority(10); 创建一个线程Java 提供了三种创建线程的方法： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 123456class RunnableDemo implements Runnable &#123;....&#125;RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);R1.start(); RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);R2.start(); Thread 方法下表列出了Thread类的一些重要方法： 序号 方法描述 1 public void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 2 public void run() 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 public final void setName(String name) 改变线程名称，使之与参数 name 相同。 4 public final void setPriority(int priority) 更改线程的优先级。 5 public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。 6 public final void join(long millisec) 等待该线程终止的时间最长为 millis 毫秒。 7 public void interrupt() 中断线程。 8 public final boolean isAlive() 测试线程是否处于活动状态。 上述方法是被 Thread 对象调用的，下面表格的方法是 Thread 类的静态方法。 序号 方法描述 1 public static void yield() 暂停当前正在执行的线程对象，并执行其他线程。 2 public static void sleep(long millisec) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 三个类 1.Backhome 12345678910111213141516171819202122public class Backhome extends Thread&#123; String name; int count; Piao piao=new Piao(); public Backhome(String name)&#123; this.name=name;&#125; @Override public void run() &#123; while (true) if (Piao.num&gt;0)&#123; try &#123; piao.sell(this); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else return; &#125;&#125; 2.piao 123456789101112public class Piao &#123; static int num = 50; static int i=0; public synchronized void sell(Backhome backhome) throws InterruptedException &#123; System.out.println(backhome.name + &quot;开始抢了&quot;); num--; backhome.count++; System.out.println(backhome.name + &quot;抢了&quot; + backhome.count); System.out.println(&quot;还剩下&quot; + num); notifyAll(); &#125;&#125; 3.main 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Backhome aa=new Backhome(&quot;张三&quot;); Backhome bb=new Backhome(&quot;李四&quot;); Backhome cc=new Backhome(&quot;王五&quot;); aa.start(); bb.start(); cc.start(); &#125;&#125; 结果 123456789101112131415161718李四开始抢了王五开始抢了张三开始抢了王五抢了1张三抢了1李四抢了1还剩下47.....李四开始抢了李四抢了24还剩下1李四开始抢了李四抢了25张三抢了12还剩下0王五抢了13还剩下0还剩下0 1.通过线程之间的通讯方式 这个就有必要说下 wait(),notify(),以及notifyAll() 这三个方法 这三个方法都是属于Object的方法；所以所有类都可以继承这三方法； wait()方法使得当前线程必须要等待，等到另外一个线程调用notify()或者notifyAll()方法。 notify()方法会唤醒一个等待当前对象的锁的线程。而notifyAll(）顾名思义；就是唤醒所有在等待中的方法； wait()和notify()方法要求在调用时线程已经获得了对象的锁，因此对这两个方法的调用需要放在synchronized方法或synchronized块中。 线程挂起和恢复方法，sleep()方法，join()方法 线程死锁 Thread1拿着lock1，想要lock2，Thread2拿着lock2，想要lock1. 2.同步代码块 12345678910111213141516171819202122232425262728293031public class Dome1 implements Runnable&#123; static int piaonum=20; public static void main(String[] args) &#123; Dome1 d=new Dome1(); Thread t1=new Thread(d,&quot;线程1&quot;); Thread t2=new Thread(d,&quot;线程2&quot;); Thread t3=new Thread(d,&quot;线程3&quot;); t1.start(); t2.start(); t3.start(); &#125; @Override public void run() &#123; while (true)&#123; synchronized (this)&#123; if(piaonum&gt;0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;票数：&quot;+piaonum--); &#125; &#125; &#125; &#125;&#125; interrupt()线程中断 Thread.yield();线程礼让","path":"2022/05/03/Java多线程/","date":"05-03","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"6.Java面向对象","text":"面向对象概念 所有操作基于对象进行操作实现 面向对象的三大特征 封装、继承、多态 类：具有相同特征和行为物体的统称 在java中类的定义语法： 12345[修饰符] class 类名&#123; 属性; 方法;&#125; 属性和方法称为成员、分别是成员属性和成员方法 类的使用：1.创建对象结合关键字new， new 对象名(参数列表); 2.调用它的方法和属性对象名.属性对象名.方法(参数列表) 对象创建的详细过程： 1234567891011121314151617class Person&#123; private String name; private int age; public Person&#123; this.name=name; this.age=age; &#125; &#123; age=20; &#125; &#125;class Main&#123; public static void main(String[] args)&#123; Person person=new Person(&quot;XXX&quot;,18); &#125; &#125; 对象的具体创建过程：1.在堆中开辟内存空间，JVM对象进行静态初始化，就是给各个属性赋予默认值 整数(byte、short、int、long)：0小数(double、float):0.0字符(char):0&#x2F;‘ ‘布尔值(boolean):false this：出现的位置：出现在本类的构造方法中&#x2F;成员方法中 作用： 1、表示当前对象，谁调用该方法，this就指代谁 2、可以调用本类中的构造方法，减少代码重复 局部变量和成员变量的区别： 1.作用域：方法中可以直接使用成员变量(成员变量作用范围整个类，局部变量只能在方法中访问) 2.内存分配：成员变量在堆中分配内存，局部变量在栈中分配内存 3.成员变量：直接定义在类中 局部变量：定义在方法中，包括方法参数 4.生命周期：局部变量在方法执行完成就销毁，成员变量根这个对象的销毁而销毁 5.有无默认值：JVM不会给局部变量赋予默认值，JVM会给成员变量赋予默认值 如果一个类中局部变量和成员变量同名，优先访问局部变量，可以用this区分局部变量和成员变量封装的含义：定义类的过程 继承： 为什么要有继承？ 正面角度：拓展父类 反面角度：将子类中相同的代码抽象到父类中，提高代码的复用性，减少重复代码 继承语法： public class 子类名 extends 父类名&#123; &#125; 方法的重写：子类重写父类中的方法，除了方法体重写之外，其他的和父类定义的一样方法的重载：在同一个类中，方法名相同，参数列表不同(类型，顺序，个数)，和返回值相同super：1、可以在子类的构造方法中调用父类的构造方法，通过super调用父类中的构造方法必须放在子类构造方法中的第一行，如果子类构造方法没有调用父类的构造方法，默认调用无参构造2、调用父类的构造方法给父类中定义的属性赋值，或调用父类中的属性和方法 修饰符：访问修饰符、static修饰符、final修饰符 访问修饰符的作用：控制被修饰的内容(类、类的成员)在其他类中的访问情况，具体参考baidu 一般结论：属性使用private，方法使用public 在开发中，我们需要给类中每个属性提供一个getter获取方法和setter修改方法 访问修饰符：public protected default private static修饰符作用：控制被修饰的内容的加载时机 static修饰的成员就变为静态成员，而且静态成员不在属于单个对象，而是属于类 直接可以通过类名.属性&#x2F;方法名直接调用 类的加载过程： JAVA中的类都是懒加载，需要用的时候才去加载 具体过程： 1、JVM将class加载到方法区(元空间) 2、JVM对类进行静态初始化：给静态属性在方法区中的常量池开辟空间 3、JVM对类进行动态初始化：执行&lt; cinit &gt;()方法 &lt; cinit &gt;()方法组成：静态属性的赋值语句+静态代码块从上到下依次组成 类的初始化小细节： 如果父类没有初始化，首先加载父类的.class文件 然后再初始化本类 final修饰符： final修饰类：类不可被继承 final修饰方法：方法不可被重写 final修饰变量：变量变常量 修饰成员变量，成员变量要再对象初始化阶段或构造方法中完成赋值 修饰静态变量：静态变量必须在类的初始化阶段完成赋值 抽象类：抽象方法的定义语法： 1234public abstract class ClassName&#123; public abstract 返回值类型 方法名(参数列表); &#125; 抽象可以含有抽象方法，但不能被实例化 一般的普通类不可以含有抽象方法，但含有抽象方法的一定是抽象类 抽象类的构造方法作用： 给子类对象在初始化的时候给父类中定义的属性赋值接口：比抽象类更加抽象，在接口中只能含有抽象方法(接口中方法的访问修饰符默认是public abstract)和常量定义语法： 1234[访问修饰符] interface InterfaceName&#123; public static final 数据类型 常量名=值; public abstract 返回值类型 方法名(参数列表); &#125; 使用接口： 123class ClassName implement InterfaceName&#123; 重写接口中的方法 &#125; 多态： 向上转型和向下转型 向上转型：父类类型&#x2F;接口类型 对象名&#x3D;子类类型的对象&#x2F;子类类型对象的引用 父类引用指向子类的对象 通过对象名只能调用父类&#x2F;接口中定义的方法，编译看左边，运行看右边 123456789101112131415class Person&#123; String name; public void info()&#123; &#125; &#125; class Chinese extends Person&#123; @override public void info()&#123; &#125; &#125; class Main&#123; public static void main(String[] args)&#123; Person chinese=new Chinese();多态 &#125; &#125; 向下转型：语法格式：子类类型 对象名&#x3D;(子类类型)new 父类类型(); 在编译的时候，始终是正确的但在运行的时候，需要检测有边对象的真正类型，只有类型和声名类型一样才能强转成功例: 1234567891011121314class Animal&#123; class Cat&#123; &#125; class Dog&#123; &#125; class Main&#123; public static void main(String[] args)&#123; Animal animal=new Animal(); Cat cat=(Cat)animal; Dog dog=(Dog)animal；//错误 Animal01 animal01=new Dog(); Dog dog=(Dog)animal01;//正确 &#125; &#125; 补充： instanceof: A instanceof B: 判断对象A是否是B类或B的子类的实例化对象 getClass()方法，获取当前对象的类型 原文链接：https://www.cnblogs.com/Floating-dream/p/14882609.html","path":"2022/05/03/Java面向对象/","date":"05-03","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"C语言指针函数","text":"函数指针就是指向函数首地址的函数变量 定义函数指针 方法：用（*标识符）替换 函数名，剩下照抄 一般会去掉形参名 12345int Max(int a,int b)&#123; return a&gt;b?a:b;&#125;int (*p)(int ,int )=NULL; 实例 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int Max(int a,int b)&#123; return a&gt;b?a:b;&#125;int Min(int a,int b)&#123; return a&gt;b?b:a;&#125;int Sum(int a,int b)&#123; return a+b;&#125;void printData(int (*pp)(int ,int ),int a,int b)&#123; printf(&quot;%d\\n&quot;,pp(a,b));&#125;void testFuntionPoint()&#123; void (*pD)(int (*)(int,int),int,int)=printData; pD(Max,1,2); pD(Min,1,2); pD(Sum,1,2);&#125;int main()&#123; testFuntionPoint(); return 0;&#125; 与Java多线程相似，具体详见 设计一个指针函数，其功能：传入一个字符串参数，以及一套算法，使得源字符串经过算法进行加密后，函数返回一个字符串数组，数组第一个元素是原文，第二个元素是密文。要求加密算法是实现过程由该方法的调用者给出，算法要求传入一个字符串类型的参数，返回值也是字符串类型。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char modify(char a)&#123; return a=a+2;&#125;char returnData(char (*pp)(char ),char b)&#123; return pp(b);&#125;int main() &#123; char *parameter = (char *) malloc(5); printf(&quot;请输入原文\\n&quot;); /* * 开辟5字节空间，如果不足自动扩容1000 */ long long int parameterSize=5,i; for (i=0;parameter[i-1]!=&#x27;\\n&#x27;;i++) &#123; if (i==parameterSize) &#123; realloc(parameter, parameterSize); parameterSize += 1000; &#125; /* * 动态分配空间 */ parameter[i]=getchar(); &#125; parameter[i]=&#x27;\\0&#x27;; char (*pD)(char (*)(char),char)=returnData; parameter[1]=pD(modify,parameter[1]); printf(&quot;%s&quot;,parameter); return 0;&#125; 方式2 头文件 1234567891011121314#ifndef SMART_HELMET_ALGOR_H#define SMART_HELMET_ALGOR_Hchar *Algor(const char *parameter, char **passwd) &#123; int i = 0; while (parameter[i] != &#x27;\\0&#x27;) &#123; passwd[1][i] = (char)(parameter[i] + 3); i++; &#125; passwd[1][i] = &#x27;\\0&#x27;; return passwd[1];&#125;#endif //SMART_HELMET_ALGOR_H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;#include &quot;Algor.h&quot; //导入算法代码头文件char **Fun(char *parameter, char *(*ptr)(char *, char **)) &#123; char **passwd = (char **) malloc(2); passwd[0] = (char *) malloc(strlen(parameter)*sizeof (char)); passwd[1] = (char *) malloc(strlen(parameter)*sizeof (char)); passwd[0] = parameter; passwd[1] = (*ptr)(parameter, passwd); //将加密算法传入 return passwd;&#125;int main() &#123; char *parameter = (char *) malloc(5); printf(&quot;请输入原文&quot;); //scanf(&quot;%s&quot;, parameter); /* * 开辟1001空间，如果不足自动扩容1001 */ int i=0; for (int parameterSize=5;parameter[i-1]!=&#x27;\\n&#x27;;i++)&#123; if (i==5) &#123; realloc(parameter, 5); parameterSize += 5; &#125; /* * 动态分配空间 */ parameter[i]=getchar(); &#125; parameter[i]=&#x27;\\0&#x27;; /* * parameter 原码 */ char *((*ptr)(char *, char **)) = (char *(*)(char *, char **)) Algor; char **ans = Fun(parameter, ptr); printf(&quot;%s\\n%s\\n&quot;, ans[0], ans[1]); /* * ans[0]为原码 * ans[1]为密码 */ free(parameter); free(ans); //释放空间 return 0;&#125;","path":"2022/05/03/指针函数/","date":"05-03","excerpt":"","tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"自定义头文件格式","text":"#ifndef…#endif属于预处理功能中三种(宏定义，文件包含和条件编译)中的第三种—-条件编译 1.一般格式12345#ifndef _STDIO_H\\#define _STDIO_H............\\#endif 在理论上来说可以是自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的命名规则一般是头文件名全大写，前面加下划线，并把文件名中的“.”也变成下划线，如：stdio.h 2.作用(重复引用的两种情况)如果h文件里只是进行了声明工作，即使不使用#ifndef宏定义，一个c文件多次包含同一个h文件也不会报错。例如：一个工程里面，同时有a.cpp,b.h,c.h,d.h。其中，a.cpp包含了b.h和c.h的头文件，b.h和c.h又都包含了d.h的头文件，那么编译过程就会造成c.h头文件的重复引用(头文件重复引用只是增加了编译工作的工作量，不会引起太大的问题，仅仅是编译效率低一些)。这种情况下，如果头文件加了#ifndef，会避免重复编译，但不加的话也仍旧是不会报错的。 如果在h文件中定义了全局变量，一个c文件包含同一个h文件多次，例如：一个工程里面，同时有a.cpp,b.h,c.h,d.h。其中，a.cpp包含了b.h和c.h的头文件，b.h和c.h又都定义了int m(虽然这种方式不被推荐，但确实是C规范允许的)，这样m变量会被编译两次，如果头文件不加#ifndef，那么编译过程会出现变量重复定义的错误。如果头文件加了#ifndef，则不会出现这种错. 3.条件编译的几种形式(百度)“ 条件编译”命令允许对程序中的内容选择性地编译，即可以根据一定的条件选择是否编译。条件编译的命令主要有以下几种 ： 形式1 123456789\\#ifndef 标识符程序段 1\\#else程序段 2\\#endif它的作用是当 “ 标识符”没有由# define定义过了。则编译“ 程序段 1 ” 。 否则编译“ 程序段 2 ” 。其中如果不需要编译“ 程序段 2 ”。则上述形式可以变换为：\\#ifndef 标识符程序段 1\\#endif 形式2： 1234567891011\\#ifndef 标识符\\# define 标识符程序段 1\\#else程序段 2\\#endif它的作用是当 “ 标识符 没有由# define定义过。 则编译“程序段 1”。否则编译“程序段 2” 。同样当无“ 程序段2 ”时。(作用与形式1完全相同)则上述形式变换为：\\# ifndef 标识符\\# define 标识符程序段 1\\#endif 形式3： 123456789\\#if 表达式程序段 1\\#else程序段 2\\#endif它的作用是 当“表达式”值为真时。编译程序段1。否则则编译程序段2。同样 当无程序段 2时，则上述形式变换为 ：\\#if 表达式程序段 1\\#endif 以上三种形式的条件编译预处理结构都可以嵌套使用。 当#else后嵌套 #if 时,可以使用预处理命令 # elif ， 它相当于 #else#if。在程序中使用条件编译主要是为了方便程序的调试和移植。","path":"2022/05/03/自定义头文件格式/","date":"05-03","excerpt":"","tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"C语言之动态数组","text":"123目录一维动态数组二维动态数组 一维动态数组1234567头文件#include &lt;stdlib.h&gt;方法malloccallocreallocfree 1：malloc是由程序员在堆栈动态开辟空间2：返回值开辟空间的首地址，但是类型是void ，需要强制类型转换3：分配的内存空间应该能整除类型所占的字节数4：包含头文件malloc.h5：只能用free（p）来释放p所指向的动态开辟的内存空间。6：对动态内存空间的操作，用p来操作。7：可以用多个指针指向这个动态空间8：当有多个指针只向这个动态空间时，只能用free一个指针，多次重复释放要被报错9：可以将动态开辟的的内存指针作为函数参数 1234567891011int *parr=null;malloc();//开辟内存空间，malloc（int size）malloc(sizeof(int/char/doublie))parr=(int*)malloc(4);*parr=520;printf(&quot;%d&quot;,*parr); calloc(5,4);//开辟5个连续的空间，每个空间四个字节realloc()//调整内存大小parr1=(int*)realloc(parr1,28)//让parr1扩容到28字节free(p);//消除p所指向的地址的空间数据p中的存的地址不变 1.用户输入任意长度的纯数字字符串后，将字符串转成16进制字符数组，并在控制台打印16进制结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int main()&#123; int a,temp,i=0,j=0; long long int num=0,lenth=0,remainder,quotient; //定义动态数组 char *str=(char *)malloc(5); scanf(&quot;%s&quot;,str); lenth=strlen(str); //进行扩容 char *strplus=(char *)malloc(lenth+5); //字符串拷贝 strcpy(strplus,str); //释放动态数组 free(str); //字符转数字 for( int i=0;strplus[i];i++ ) &#123; a=strplus[i]-48; //printf(&quot;%d\\n&quot;, a); num=num*10+a; &#125; //printf(&quot;%d\\n&quot;,num); //释放动态数组,留下数字num free(strplus); //构造存储十六进制的动态数组 char *sixteenNumber=(char *)malloc(lenth+5); quotient=num; //十进制转十六进制 while(quotient!=0) &#123; temp = quotient % 16; if( temp &lt; 10) temp =temp + 48; else temp = temp + 55; sixteenNumber[j++]= temp; quotient = quotient / 16; &#125; printf(&quot;%s&quot;,sixteenNumber); return 0;&#125; 方法二 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;int main()&#123; long long int num=0,lenth=0; //定义动态数组 char *str=(char *)malloc(5); scanf(&quot;%s&quot;,str); lenth=strlen(str); //进行扩容 char *strplus=(char *)malloc(lenth+5); //字符串拷贝 strcpy(strplus,str); //释放动态数组 free(str); num = atoi(strplus); free(strplus); char *sixteenum=(char *)malloc(lenth); //printf(&quot;%ld&quot;,num); //itoa()不支持long long int 型参数，so行不通 itoa(num,sixteenum,16); printf(&quot;%s&quot;, sixteenum);&#125; 方法三 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;long long int sum=0;char* getstr()&#123; char* str; char* _str; int i = 1; str = (char*)malloc(sizeof(char) * (i + 1)); while(&#x27;\\n&#x27; != (str[i - 1] = getchar())) &#123; i ++; _str = (char*)malloc(strlen(str) + 1); str[i - 1] = &#x27;\\0&#x27;; strcpy(_str, str); free(str); str = (char*)malloc(sizeof(char) * (i + 1)); if(NULL == str) &#123; free(_str); printf(&quot;No enough memory!&quot;); return NULL; &#125; strcpy(str, _str); free(_str); &#125; sum=i-1; str[i - 1] = &#x27;\\0&#x27;; return str; &#125;int main() &#123; char * d,*a; long long int c=0; int i; d=getstr(); a = (char*)malloc(sizeof(char) * sum); for(int i=0;i&lt;sum;i++) &#123; c=d[i]-&#x27;0&#x27;+c*10; &#125; for(i=0;c!=0;i++) &#123; if(c%16&lt;=9) a[i]=c%16+&#x27;0&#x27;; else a[i]=c%16-10+&#x27;A&#x27;; c/=16; &#125; sum=i; a[sum]=&#x27;\\0&#x27;; for(int j=sum-1;j&gt;=0;j--) &#123; printf(&quot;%c&quot;,a[j]); &#125; free(d); return 0;&#125; 二维动态数组123456789a.声明：int **a; b.给内存：a=(int **)malloc(二维数的行数 * seizeof(int*)); for(i=0;i&lt;二维数组的行数;i++) a[i]=(int *)malloc(每行有多少个元素 * sizeof(int)); c.即可以如常规的二维数组使用； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt; void InitArray(char** a, int n)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; a[i] = (char*)malloc(sizeof(char) * n); if (a[i] == NULL) //如果没有判空操作，上一行代码则会发出警告：“取消对NULL指针的引用” &#123; return; &#125; for (j = 0; j &lt; n; j++) &#123; a[i][j] = &#x27;a&#x27;; &#125; &#125;&#125;//释放二维动态数组内存void ReleaseArray(char** a, int n)&#123; int i; for (i = 0; i &lt; n; i++) &#123; free(*(a + i)); &#125;&#125;void ShowArray(char** a, int n)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 0; j &lt; n; j++) &#123; printf(&quot;%c &quot;, a[i][j]); &#125; printf(&quot;\\n一行输出完了\\n&quot;); &#125;&#125;int main()&#123; char** a; int n = 100; a = (char**)malloc(sizeof(char*) * n); InitArray(a, n); ShowArray(a, n); ReleaseArray(a, n); return 0;&#125;","path":"2022/04/30/C语言dome/","date":"04-30","excerpt":"","tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"二叉树","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;typedef struct BiNode&#123; //二叉链表定义 char data; struct BiNode *lchild,*rchild;&#125;BiTNode,*BiTree;void PreorderTraverse(BiTree T);//先序遍历二叉树T的递归函数声明//用算法5.3 先序遍历的顺序建立二叉链表void CreateBiTree(BiTree &amp;T)&#123;//按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T char ch; cin &gt;&gt; ch; if(ch==&#x27;#&#x27;) T=NULL; //递归结束，建空树 else&#123; T=new BiTNode; T-&gt;data=ch; //生成根结点 CreateBiTree(T-&gt;lchild); //递归创建左子树 CreateBiTree(T-&gt;rchild); //递归创建右子树&#125; //else&#125; //CreateBiTreeint main()&#123; BiTree tree; //cout&lt;&lt;&quot;请输入建立二叉链表的序列：\\n&quot;; CreateBiTree(tree); //cout&lt;&lt;&quot;先序遍历的结果为：\\n&quot;; PreorderTraverse(tree); cout&lt;&lt;endl; return 0;&#125;//先序遍历void PreorderTraverse(BiTree T)&#123; if(T) &#123; cout&lt;&lt;T-&gt;data; PreorderTraverse(T-&gt;lchild); PreorderTraverse(T-&gt;rchild); &#125;&#125;//中序遍历void InOrderTraverse(BiTree T)&#123; if(T) &#123; InOrderTraverse(T-&gt;lchild); cout&lt;&lt;T-&gt;data; InOrderTraverse(T-&gt;rchild); &#125;&#125;//后序遍历void PostorderTraverse(BiTree T)&#123; if(T) &#123; PostorderTraverse(T-&gt;lchild); PostorderTraverse(T-&gt;rchild); cout&lt;&lt;T-&gt;data; &#125;&#125; 2.统计二叉树中结点的个数 12345678int NodeCount(BiTree T)&#123; if(T==NULL) return 0; else return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1;&#125; 3.统计二叉树中叶子结点的个数 123456789int Leafnum(BiTree T)&#123; if(T==NULL) return 0; if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL) return 1; return Leafnum(T-&gt;lchild)+Leafnum(T-&gt;rchild);&#125; 4.求树的深度 12345678910111213141516int Depth(BiTree T)&#123; int m,n; if(T==NULL) return 0; else &#123; m=Depth(T-&gt;lchild); n=Depth(T-&gt;rchild); if(m&gt;n) return(m+1); else return (n+1); &#125;&#125; 5.先序遍历的顺序建立二叉链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;//二叉树的二叉链表存储表示typedef struct BiNode&#123;char data; //结点数据域struct BiNode *lchild,*rchild; //左右孩子指针&#125;BiTNode,*BiTree;void CreateBiTree(BiTree &amp;T); //CreateBiTree//用算法5.1 中序遍历的递归算法void InOrderTraverse(BiTree T)&#123;//中序遍历二叉树T的递归算法if(T)&#123;InOrderTraverse(T-&gt;lchild);cout &lt;&lt; T-&gt;data;InOrderTraverse(T-&gt;rchild);&#125;&#125;int main()&#123; BiTree tree; //cout&lt;&lt;&quot;请输入建立二叉链表的序列：\\n&quot;; CreateBiTree(tree); //cout&lt;&lt;&quot;所建立的二叉链表中序序列：\\n&quot;; InOrderTraverse(tree); cout&lt;&lt;endl; return 0;&#125;void CreateBiTree(BiTree &amp;T)&#123; char ch; cin&gt;&gt;ch; if(ch==&#x27;#&#x27;) T=NULL; else &#123; T=new BiTNode; T-&gt;data=ch; CreateBiTree(T-&gt;lchild); CreateBiTree(T-&gt;rchild); &#125;&#125;","path":"2022/04/25/二叉树/","date":"04-25","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"5.本地文件处理之IO流","text":"123456789101112目录1.FileOutputStream类2.FileInputStream类3.BufferedOutputStream类4.BufferedInputStream类5.FileWriter类6.FileReader类7.BufferedWriter类8.BufferedReader类9.OutputStreamWriter类10.InputStreamReader类11.ObjectInputStream类 IO流的概念IO就是Input和Output的简写，也就是输入和输出的含义。IO流就是指读写数据时像流水一样从一端流到另外一端，因此得名为“流”。 基本分类1.按照读写数据的基本单位不同 可分为两种 字节流：其中字节流主要指以字节为单位进行数据读写的流，可以读写任意类型的文件 。(txt,jpg,avi,mp4等) 字符流：其中字符流主要指以字符(2个字节)为单位进行数据读写的流，只能读写文本文件 含有中文的文本文件推荐用 2.按照读写数据的方向不同，可分为两种（站在程序的角度）。 输入流：其中输入流主要指从文件中读取数据内容输入到程序中，也就是读文件。 输出流：其中输出流主要指将程序中的数据内容输出到文件中，也就是写文件。 1.FileOutputStream类基本概念：java.io.FileOutputStream类主要用于将图像数据之类的原始字节流写入到输出流中。 常用的方法 方法声明 功能介绍FileOutputStream(String name) 根据参数指定的文件名来构造对象FileOutputStream(String name, boolean append) 以追加的方式根据参数指定的文件名来构造对象void write(int b) 将指定字节写入此文件输出流void write(byte[] b, int off, int len) 将指定字节数组中从偏移量off开始的len个字节写入 此文件输出流void write(byte[] b) 将 b.length 个字节从指定字节数组写入此文件输出 流中void flush() 刷新此输出流并强制写出任何缓冲的输出字节void close() 关闭流对象并释放有关的资源 2.FileInputStream类基本概念：java.io.FileInputStream类主要用于从输入流中以字节流的方式读取图像数据等。 常用的方法 方法声明 功能介绍FileInputStream(String name) 根据参数指定的文件路径名来构造对象int read() 从输入流中读取单个字节的数据并返回，返回-1表示读取到末尾int read(byte[] b, int off, int len)从此输入流中将最多len个字节的数据读入字节数组中，返回读取到的字节个数返回-1表示读取到末尾int read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入字节数组中，返回读 取到的字节个数，返回-1表示读取到末尾void close() 关闭流对象并释放有关的资源int available() 获取输入流所关联文件的大小案例题目 编程实现两个文件之间的拷贝功能(异常未处理 处理异常的方式和上面相同) 拷贝方式一: 文件捎到时 拷贝效率低 public static void main(String[] args) &#123; // 1.创建字节输入流 FileInputStream 与文件 z:/c.png 进行关联 FileInputStream inputStream = new FileInputStream(&quot;z:/d.png&quot;); // 2.创建字节输出流 FileOutputStream 与文件 z:/d.png 进行关联 FileOutputStream outputStream = new FileOutputStream(&quot;z:/c.png&quot;); // 3.将字节输入流读到的数据写入到字节输出流上 int res = 0; while ((res = inputStream.read()) != -1)&#123; outputStream.write(res); &#125; // 4.关闭流信息 释放相关的资源 outputStream.close(); inputStream.close(); &#125; 拷贝方式二:准备一个和文件大小相同的数据缓冲区 一次性将文件拷贝完成(缺点是 文件太大时 无法申请和文件大小一样的缓冲区 真实的物理内存不足) // 3.将字节输入流读到的数据写入到字节输出流上 // 将下面代码改为3以后的代码 int leng = inputStream.available(); byte[] temp = new byte[leng]; outputStream.write(temp); 拷贝方式三：准备一个相对适当的缓冲区 分多次将文件拷贝完成 一般用1024的倍数或 1024 1234567// 3.将字节输入流读到的数据写入到字节输出流上 byte[] b = new byte[1024]; int res = 0; while ((res = inputStream.read(b)) != -1)&#123; outputStream.write(b,0,res); &#125; 3.BufferedOutputStream类基本概念：java.io.BufferedOutputStream类主要用于描述缓冲输出流，此时不用为写入的每个字节调用底层系统 常用的方法 方法声明 功能介绍BufferedOutputStream(OutputStream out) 根据参数指定的引用来构造对象BufferedOutputStream(OutputStream out, int size) 根据参数指定的引用和缓冲区大小来构造 对象void write(int b) 写入单个字节void write(byte[] b, int off, int len) 写入字节数组中的一部分数据void write(byte[] b) 写入参数指定的整个字节数组void flush() 刷新流void close() 关闭流对象并释放有关的资源 4.BufferedInputStream类基本概念：java.io.BufferedInputStream类主要用于描述缓冲输入流。 常用的方法 方法声明 功能介绍BufferedInputStream(InputStream in) 根据参数指定的引用构造对象BufferedInputStream(InputStream in, int size) 根据参数指定的引用和缓冲区大小构造对象int read() 读取单个字节int read(byte[] b, int off, int len) 读取len个字节int read(byte[] b) 读取b.length个字节void close() 关闭流对象并释放有关的资源使用缓冲输入输出流实现文件的拷贝（未进行异常的处理 自己也可以定义缓冲区 ）默认缓冲区为 8192 &#x3D; 1024 * 8 // 1.创建BufferedInputStream 类型与 z://c.png 文件管理 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;z:/c.png&quot;)); // 处理流 // 2.创建BufferedIOutputStream 类型与 z://d.png 文件管理 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;z/d.png&quot;)); // 处理流 // 3.不断地从输入流读取文件数据 写入到输出流中 int res = 0; while ((res = bis.read()) != -1)&#123; bos.write(res); &#125; // 4.关闭流对象 释放有关的资源 bos.close(); bis.close(); 使用： 当牵扯到文件复制是 首选 BufferedInputStream 和 BufferedOutoutStream 5.FileWriter类java.io.FileWriter类主要用于将文本内容写入到文本文件。 常用的方法 方法声明 功能介绍FileWriter(String fileName) 根据参数指定的文件名构造对象FileWriter(String fileName, boolean append) 以追加的方式根据参数指定的文件名来构造对象void write(int c) 写入单个字符void write(char[] cbuf, int off, int len) 将指定字符数组中从偏移量off开始的len个字符写入此 文件输出流void write(char[] cbuf) 将cbuf.length个字符从指定字符数组写入此文件输出 流中void flush() 刷新流 void close() 关闭流对象并释放有关的资源void close() 关闭流对象并释放有关的资源常用方法代码演示 对象的构造 需要进行异常单处理 // 1.构造FileWrite类型的对象 与 z://a.txt文件关联 // 若文件不存在创建一个新文件 // 若文件存在 该流会清空文件中原有的内容 FileWriter writer = new FileWriter(&quot;z:/a.txt&quot;); // 加true之后 文件以追加的形式创建对象 去关联文件 // 若文件不存在则自动创建新的空文件 并保留文件中原有的数据内容 FileWriter writer = new FileWriter(&quot;z:/a.txt&quot;, true); 文件的写入 // 2.通过流对象写入数据内容 writer.write(&#39;a&#39;); 写入字符数组 // 准备一个字符串并将字符串转化为char[] char[] charsArr = &quot;hello, java !!!&quot;.toCharArray(); // 将字符的一部分写入到文件中 writer.write(charsArr,6,charsArr.length-1 - 6); // java !!! // 此处不会清除文件中的内容 而是在末尾进行追加 writer.write(charsArr); // java !!hello, java !!! 流的关闭 防在捕获异常之后的finally类中 // 3.关闭流对象 并释放资源 // 如果在创建对象时发生异常 则writer为空值 可能引发空指针异常 在这进行判断防止异常的发生 if (writer != null)&#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 数刷新 flush 只有大量写入数据时才用到 // 刷新流 write.flush(); 6.FileReader类基本概念：java.io.FileReader类主要用于从文本文件读取文本数据内容 常用的方法 方法声明 功能介绍FileReader(String fileName) 根据参数指定的文件名构造对象int read() 读取单个字符的数据并返回，返回-1表示读取到末尾int read(char[] cbuf, int offset, int length) 从输入流中将最多len个字符的数据读入一个字符数组中，返回读取到的字符个数，返回-1表示读取到末尾int read(char[] cbuf) 从此输入流中将最多 cbuf.length 个字符的数据读入字符数组中，返回读取到的字符个数，返回-1表示读取到末尾void close() 关闭流对象并释放有关的资源常用方法代码演示 对象的构造并进行遍历文本文件进行打印 123456789101112131415FileReader reader = null; try &#123; // 1.构造FileReader类型的对象 与 z:/a.txt 文件关联 reader = new FileReader(&quot;z:/a.txt&quot;); // 文件中的内容是 java !!hello, java !!! // 2.读取文件内容并打印 // System.out.println(reader.read()); // 输出为 32 可能为ASCII码 // 进行数字转换为char 返回值是对应的ASCII码值 // 当读取单文件的最后位置返回为 - 1 int temp = 0; // 初始化用来接受输入流的信息 while ( (temp = reader.read()) != -1)&#123; System.out.print( (char) temp); // java !!hello, java !!! &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 将关联文件读取到字符数组中 // 1.定义一个字符串数组 长度为10 文件中的字符为java!!hellojava char[] charArr = new char[10]; reader.read(charArr,1,8); // 打印数组中的元素 System.out.println(Arrays.toString(charArr)); // [, , j, a, v, a, !, !, h, ] // 由于用的是同一个对象 指针保留到下一个字符 如果读取完毕 指针自动调用前调用方第一个字符 最后一个字符返回为空 reader.read(charArr); System.out.println(Arrays.toString(charArr)); // [e, l, l, o, j, a, v, a, h, ] 关闭流对象并释放有关的资源 finally &#123; // 3.关闭流对象并释放有关的资源 // 如果在创建对象时发生异常 则reader为空值 可能引发空指针异常 在这进行判断防止异常的发生 if (reader != null)&#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 实现文件的拷贝(单个字符) 123456789101112131415161718192021222324252627282930313233FileReader reader = null; FileWriter writer = null; try &#123; // 1.创建FileReader类型的对象 与 z:/a.txt 关联 reader = new FileReader(&quot;z:/a.txt&quot;); // 2.创建FileWriter类型的对象 与 z:/b.txt 关联 writer = new FileWriter(&quot;z:/b.txt&quot;); // 3.从输入流中读取到的数据写入到输出流 int temp = 0; while ((temp = reader.read()) != -1)&#123; writer.write(temp); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 4.关闭流信息 并释放对应的资源 // 关闭流信息一般操作是 县创建的后关闭 if (writer != null)&#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(reader != null)&#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 7.BufferedWriter类基本概念：java.io.BufferedWriter类主要用于写入单个字符、字符数组以及字符串到输出流中。 常用的方法 方法声明 功能介绍BufferedWriter(Writer out) 根据参数指定的引用来构造对象BufferedWriter(Writer out, int sz) 根据参数指定的引用和缓冲区大小来构造对象void write(int c) 写入单个字符到输出流中void write(char[] cbuf, int off, int len) 将字符数组cbuf中从下标off开始的len个字符写入输出流 中void write(char[] cbuf) 将字符串数组cbuf中所有内容写入输出流中void write(String s, int off, int len) 将参数s中下标从off开始的len个字符写入输出流中void write(String str) 将参数指定的字符串内容写入输出流中void newLine() 用于写入行分隔符到输出流中void flush() 刷新流void close() 关闭流对象并释放有关的资源 8.BufferedReader类基本概念：java.io.BufferedReader类用于从输入流中读取单个字符、字符数组以及字符串。 常用的方法 方法声明 功能介绍BufferedReader(Reader in) 根据参数指定的引用来构造对象BufferedReader(Reader in, int sz) 根据参数指定的引用和缓冲区大小来构造对象int read() 从输入流读取单个字符，读取到末尾则返回-1，否则返回实际读取到 的字符内容int read(char[] cbuf, int off, int len) 从输入流中读取len个字符放入数组cbuf中下标从off开始的位置上， 若读取到末尾则返回-1，否则返回实际读取到的字符个数int read(char[] cbuf) 从输入流中读满整个数组cbuf String readLine() 读取一行字符串并返回，返回null表示读取到末尾void close() 关闭流对象并释放有关的资源数据缓冲输入流(字符 按照行数据 )实现文件的拷贝(有异常未进行处理) 12345678910111213// 1.定义一个字符缓冲输入流 BufferedReader 与文件 z:/a.txt 文件关联 BufferedReader reader = new BufferedReader(new FileReader(&quot;z:a.txt&quot;)); // 2.定义一个字符缓冲输出流 BufferedWriter 与文件 z:/a.txt 文件关联 BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;z:/b.txt&quot;)); // 3.将读到的行数据输入流按照行输出到输出流上 String res = null; while ((res = reader.readLine()) != null)&#123; // 读取一行数据 writer.write(res); // 写入一行数据 writer.newLine(); // 新建一行 不添加此处代码 默认在末尾追加 当前系统的行分隔符是 &#125; // 4.关闭流信息 释放相关的资源 writer.close(); reader.close(); 9.OutputStreamWriter类基本概念：java.io.OutputStreamWriter类主要用于实现从字符流到字节流的转换。 常用的方法 方法声明 功能介绍OutputStreamWriter(OutputStream out) 根据参数指定的引用来构造对象OutputStreamWriter(OutputStream out, String charsetName) 根据参数指定的引用和编码构造 对象void write(String str) 将参数指定的字符串写入void flush() 刷新流void close() 用于关闭输出流并释放有关的资源 10.InputStreamReader类基本概念：java.io.InputStreamReader类主要用于实现从字节流到字符流的转换。 常用的方法 方法声明 功能介绍InputStreamReader(InputStream in) 根据参数指定的引用来构造对象InputStreamReader(InputStream in, String charsetName) 根据参数指定的引用和编码来构造对 象int read(char[] cbuf) 读取字符数据到参数指定的数组void close() 用于关闭输出流并释放有关的资源 11.ObjectInputStream类基本概念：java.io.ObjectInputStream类主要用于从输入流中一次性将对象整体读取出来。所谓反序列化主要指将有效组织的字节序列恢复为一个对象及相关信息的转化过程。常用的方法 方法声明 功能介绍ObjectInputStream(InputStream in) 根据参数指定的引用来构造对象Object readObject() 主要用于从输入流中读取一个对象并返回 无法通过返回值 来判断是否读取到文件的末尾void close() 用于关闭输入流并释放有关的资源方法使用 ObjectInputStream inputStream = null; try &#123; // 1.创建 ObjectInoutStream 对象与 z:/a.txt 文件关联 inputStream = new ObjectInputStream(new FileInputStream(&quot;z:/a.txt&quot;)); // 2.读取文件内容并打印信息 User user = (User)inputStream.readObject(); System.out.println(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3.关闭流信息 并释放对应的资源 if (inputStream != null)&#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 字符编码编码表的由来 计算机只能识别二进制数据，早期就是电信号。为了方便计算机可以识别各个国家的文字，就需要 将各个国家的文字采用数字编号的方式进行描述并建立对应的关系表，该表就叫做编码表。 常见的编码表 ASCII：美国标准信息交换码， 使用一个字节的低7位二位进制进行表示。 ISO8859-1：拉丁码表，欧洲码表，使用一个字节的8位二进制进行表示。 GB2312：中国的中文编码表，最多使用两个字节16位二进制为进行表示。 GBK：中国的中文编码表升级，融合了更多的中文文字符号，最多使用两个字节16位二进制位表 示。 Unicode：国际标准码，融合了目前人类使用的所有字符，为每个字符分配唯一的字符码。所有的 文字都用两个字节16位二进制位来表示 编码的发展 面向传输的众多 UTF（UCS Transfer Format）标准出现了，UTF-8就是每次8个位传输数据，而 UTF-16就是每次16个位。这是为传输而设计的编码并使编码无国界，这样就可以显示全世界上所 有文化的字符了。Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体 存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。 原文链接：https://blog.csdn.net/Junsunnyl/article/details/119973088","path":"2022/04/22/本地文件处理之IO流/","date":"04-22","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"4.java对本地文件的处理","text":"基本概念java.io.File类主要用于描述文件或目录路径的抽象表示信息，可以获取文件或目录的特征信息， 如：大小等常用的方法 方法声明 功能介绍 12345678910111213141516File(String pathname) 根据参数指定的路径名来构造对象File(String parent, String child) 根据参数指定的父路径和子路径信息构造对象File(File parent, String child) 根据参数指定的父抽象路径和子路径信息构造对象boolean exists() 测试此抽象路径名表示的文件或目录是否存在String getName() 用于获取文件的名称long length() 返回由此抽象路径名表示的文件的长度long lastModified() 用于获取文件的最后一次修改时间String getAbsolutePath() 用于获取绝对路径信息boolean delete() 用于删除文件，当删除目录时要求是空目录boolean createNewFile() 用于创建新的空文件boolean mkdir() 用于创建目录boolean mkdirs() 用于创建多级目录File[] listFiles() 获取该目录下的所有内容boolean isFile() 判断是否为文件boolean isDirectory() 判断是否为目录File[] listFiles(FileFilter filter) 获取目录下满足筛选器的所有内容 123//改文件名File file = new File(&quot;F:/a/b&quot;);file.renameTo(new File(&quot;F:/a/bbb&quot;)); 方法演示1. // 3.由于修改时间返回的是毫秒值 所有格式化 SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); // 1.构造File类型的对象 并用 z:/a.txt初始化 File file = new File(&quot;z:/a.txt&quot;); if (file.exists()) &#123; // 判断文件是否存在 如果存在执行以下代码 System.out.println(&quot;文件的名称是:&quot; + file.getName()); // a.txt System.out.println(&quot;文件的大小是:&quot; + file.length()); // 0 System.out.println(&quot;文件的最后一次次改时间是&quot; + format.format(new Date(file.lastModified()))); // 2021年08月19日 22:23:10 System.out.println(&quot;文件的绝对路径是:&quot; + file.getAbsolutePath()); // z:/a.txt System.out.println(file.delete() ? &quot;文件删除成功&quot; : &quot;文件删除失败&quot;); // 文件删除成功 &#125; else &#123; // 3.如果文件不存在 创建文件 try &#123; System.out.println(file.createNewFile() ? &quot;文件创建成功&quot; : &quot;文件创建失败&quot;); // 文件创建成功 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 创建目录2. // 4.实现单多级目录的创建 File file1 = new File(&quot;z:/java/css/html&quot;); if (file1.exists()) &#123; System.out.println(&quot;目录名称是:&quot; + file1.getName()); System.out.println(file1.delete() ? &quot;目录删除成功&quot; : &quot;目录删除失败&quot;); &#125; else &#123; // System.out.println(file1.mkdir() ? &quot;目录创建成功&quot; : &quot;目录创建失败&quot;); // 创建单单极目录 System.out.println(file1.mkdirs() ? &quot;目录创建成功&quot; : &quot;目录创建失败&quot;); // 创建多单极目录 &#125; 遍历目录结构3. // 5.获取文件目录的文件及文件夹 并遍历 File file2 = new File(&quot;z:/java&quot;); File[] filesArr = file2.listFiles(); // 5.1遍历file数组 for (File file3 : filesArr) &#123; String name = file3.getName(); // 判读是否为文件 如果是打印文件名 if (file3.isFile())&#123; System.out.println(name); &#125; // 判断是否为目录 如果是 打印目录名 并按照格式&#123;&#125; if (file3.isDirectory())&#123; System.out.println(&quot;&#123;&quot; + name + &quot;&#125;&quot;); &#125; &#125; 文件过滤器的使用123456789101112131415// 6.实现目录中的所有内容获取的通时 进行过滤 获取.png为后缀名的所有 // 6.1 使用匿名内部类 File[] files = file2.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; return pathname.getName().endsWith(&quot;.png&quot;); &#125; &#125;); // 6.1 使用lambda表达式 FileFilter filter = (File pathname) -&gt; pathname.getName().endsWith(&quot;.mp4&quot;); // 6.1 传入lambda表达式 File[] file5 = file2.listFiles((File pathname) -&gt; pathname.getName().endsWith(&quot;.png&quot;)); // 6.2过滤之后进行打印 System.out.println(Arrays.toString(file5)); &#125; 使用递归的思想实现层层目录的打印1234567891011121314151617public static void show(File file)&#123; // 5.获取文件目录的文件及文件夹 并遍历 File[] filesArr = file.listFiles(); // 5.1遍历file数组 for (File file3 : filesArr) &#123; String name = file3.getName(); // 判读是否为文件 如果是打印文件名 if (file3.isFile())&#123; System.out.println(name); &#125; // 判断是否为目录 如果是 打印目录名 并按照格式&#123;&#125; if (file3.isDirectory())&#123; System.out.println(&quot;&#123;&quot; + name + &quot;&#125;&quot;); show(file3); &#125; &#125; &#125; 原文链接：https://blog.csdn.net/Junsunnyl/article/details/119973088","path":"2022/04/22/java对本地文件的处理/","date":"04-22","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"稀疏矩阵的转置","text":"1.稀疏矩阵的转置方法一 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdio.h&gt;#define MAXSIZE 50#define MAXRC 10//三元组结构体typedef struct&#123; //所在行数，列数 int i,j; //值 int e;&#125;triple;//存储矩阵的三元组顺序表typedef struct&#123; //存储数据 triple data[MAXSIZE + 1]; //存储矩阵的行数，列数和非 0 元的个数 int mu,nu,tu;&#125;TSMatrix;//初始化三元组顺序表TSMatrix tcreate(int m,int n,int t)&#123; TSMatrix M; int k; M.mu = m; M.nu = n; M.tu = t; printf(&quot;input %d data&quot;,M.tu); printf(&quot;i j e &quot;); for(k=1;k&lt;=M.tu;k++)&#123; scanf(&quot;%d%d%d&quot;,&amp;M.data[k].i,&amp;M.data[k].j,&amp;M.data[k].e); &#125; return M;&#125;//输出矩阵 M 的函数，以二维的格式呈现void printt(TSMatrix M)&#123; int i,j,k=1; //输出矩阵的每一行 for(i=0;i&lt;M.mu;i++)&#123; printf(&quot;\\n&quot;); //输出矩阵的每一列 for(j=0;j&lt;M.nu;j++)&#123; //判断矩阵中是否有非 0 元存在 if(k&gt;M.tu)&#123; printf(&quot;%3d&quot;,0); &#125; else&#123; //如果对应位置为非 0 元，则输出 if((i==M.data[k].i) &amp;&amp; (j == M.data[k].j))&#123; printf(&quot;%3d&quot;,M.data[k].e); k++; &#125;else&#123; //否输出 0 printf(&quot;%3d&quot;,0); &#125; &#125; &#125; &#125; printf(&quot;\\n&quot;);&#125;//矩阵的转置函数TSMatrix transpose(TSMatrix a)&#123; TSMatrix b; int col,p,q; //将矩阵 a 存储的行数、列数和非0 元个数赋值给转置矩阵 b b.mu=a.nu; b.nu=a.mu; b.tu=a.tu; //如果存在非 0 元，则逐个对其进行转置 if(b.tu)&#123; q = 1; //从列依次遍历 for(col=0;col&lt;a.nu;col++)&#123; for(p=1;p&lt;=a.tu;p++)&#123; if(a.data[p].j == col)&#123; b.data[q].i=a.data[p].j; b.data[q].j=a.data[p].i; b.data[q].e=a.data[p].e; q++; &#125; &#125; &#125; &#125; return b;&#125;int main()&#123; int m,n,t; TSMatrix E,F; printf(&quot;input m,n,t:\\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;t); E = tcreate(m,n,t); printt(E); F = transpose(E); printt(F);&#125; 2.方法二 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#define MAXSIZE 50#define MAXRC 10//三元组结构体typedef struct&#123; //所在行数，列数 int i,j; //值 int e;&#125;triple;//存储矩阵的三元组顺序表typedef struct&#123; //存储数据 triple data[MAXSIZE + 1]; //存储矩阵的行数，列数和非 0 元的个数 int mu,nu,tu;&#125;TSMatrix;//初始化三元组顺序表TSMatrix tcreate(int m,int n,int t)&#123; TSMatrix M; int k; M.mu = m; M.nu = n; M.tu = t; printf(&quot;input %d data&quot;,M.tu); printf(&quot;i j e \\n&quot;); for(k=1;k&lt;=M.tu;k++)&#123; scanf(&quot;%d%d%d&quot;,&amp;M.data[k].i,&amp;M.data[k].j,&amp;M.data[k].e); &#125; return M;&#125;//输出矩阵 M 的函数，以二维的格式呈现void printt(TSMatrix M)&#123; int i,j,k=1; //输出矩阵的每一行 for(i=0;i&lt;M.mu;i++)&#123; printf(&quot;\\n&quot;); //输出矩阵的每一列 for(j=0;j&lt;M.nu;j++)&#123; //判断矩阵中是否有非 0 元存在 if(k&gt;M.tu)&#123; printf(&quot;%3d&quot;,0); &#125; else&#123; //如果对应位置为非 0 元，则输出 if((i==M.data[k].i) &amp;&amp; (j == M.data[k].j))&#123; printf(&quot;%3d&quot;,M.data[k].e); k++; &#125;else&#123; //否输出 0 printf(&quot;%3d&quot;,0); &#125; &#125; &#125; &#125; printf(&quot;\\n&quot;);&#125;//矩阵的转置函数TSMatrix fasttrans(TSMatrix a)&#123; TSMatrix b; int col,p,q,t; int num[MAXSIZE]; int cpot[MAXSIZE]; //转置行数、列数和非 0 元个数 b.mu = a.nu; b.nu = a.mu; b.tu = a.tu; //如果存在非 0 元 if(b.tu)&#123; //num数组全置为 0 for(col = 0;col&lt;a.nu;col++)&#123; num[col] = 0; &#125; //根据矩阵 a ，对num数组进行初始化 for(t=1;t&lt;=a.tu;t++)&#123; num[a.data[t].j]++; &#125; //初始化cpot数组 cpot[0]=1; for(col=1;col&lt;a.nu;col++)&#123; cpot[col] = cpot[col-1]+num[col-1]; &#125; //结束num和cpot，对矩阵 a 进行转置 for(p=1;p&lt;=a.tu;p++)&#123; col =a.data[p].j; q = cpot[col]; b.data[q].i = a.data[p].j; b.data[q].j = a.data[p].i; b.data[q].e = a.data[p].e; cpot[col]++; &#125; &#125; return b;&#125;int main()&#123; int m,n,t; TSMatrix E,F; printf(&quot;input m,n,t:\\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;t); E = tcreate(m,n,t); printt(E); F = fasttrans(E); printt(F);&#125; 3.快速转制 1234567891011121314151617181920212223242526272829303132333435363738//实现快速转置算法的函数TSMatrix fastTransposeMatrix(TSMatrix M,TSMatrix T)&#123; //第1步：行和列置换 T.m=M.n; T.n=M.m; T.num=M.num; if (T.num) &#123; //计算array数组 int array[number]; for (int col=1; col&lt;=M.m; col++) &#123; array[col]=0; &#125; for (int t=0; t&lt;M.num; t++) &#123; int j=M.data[t].j; array[j]++; &#125; //创建并初始化cpot数组 int cpot[T.m+1]; cpot[1]=1;//第一列中第一个非0元素的位置默认为1 for (int col=2; col&lt;=M.m; col++) &#123; cpot[col]=cpot[col-1]+array[col-1]; &#125; //遍历一次即可实现三元组表的转置 for (int p=0; p&lt;M.num; p++) &#123; //提取当前三元组的列数 int col=M.data[p].j; //根据列数和cpot数组，找到当前元素需要存放的位置 int q=cpot[col]; //转置矩阵的三元组默认从数组下标0开始，而得到的q值是单纯的位置，所以要减1 T.data[q-1].i=M.data[p].j; T.data[q-1].j=M.data[p].i; T.data[q-1].data=M.data[p].data; //存放完成后，cpot数组对应的位置要+1，以便下次该列存储下一个三元组 cpot[col]++; &#125; &#125; return T;&#125;","path":"2022/04/22/稀疏矩阵的转置/","date":"04-22","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"字符串查找KMP算法","text":"1.输出next 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAXLEN 255void getnext(char P[], int next[],int m);int KMP(char T[],char P[],int next[],int n,int m);int main()&#123;char P[100];cin&gt;&gt;P;int m=strlen(P);int next[m];getnext(P,next,m);for(int i=0;i&lt;m;i++)cout&lt;&lt;next[i];return 0;&#125;void getnext(char P[], int next[],int m)&#123; next[0] = -1; int j = 0; int k = -1; while (j &lt; m-1) &#123; if (k == -1 || P[j] == P[k]) &#123; j++; k++; if(P[j] == P[k]) next[j]=next[k]; else next[j] = k; &#125; else k = next[k]; &#125;&#125; 2.输出nextval 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAXLEN 255void getnext(char P[], int next[],int m);int KMP(char T[],char P[],int next[],int n,int m);int main()&#123;char P[100];cin&gt;&gt;P;int m=strlen(P);int next[m];getnext(P,next,m);for(int i=0;i&lt;m;i++)cout&lt;&lt;next[i];return 0;&#125;void getnext(char P[], int next[],int m)&#123; next[0] = -1; int j = 0; int k = -1; while (j &lt; m-1) &#123; if (k == -1 || P[j] == P[k]) &#123; j++; k++; if(P[j] == P[k]) next[j]=next[k]; else next[j] = k; &#125; else k = next[k]; &#125;&#125; 3.在KMP算法中，进行模式匹配，在匹配失败时，主串的位置i不回溯，模式串需要根据失败函数next[j]的值，j转移到next[j]位置继续进行比较。 12345678910111213141516void getnext(char P[], int next[],int m)&#123; next[0] = -1; int j = 0; int k = -1; while (j &lt; m-1) &#123; if (k == -1 || P[j] == P[k]) &#123; j++; k++; next[j] = k; &#125; else k = next[k]; &#125;&#125; 4.在KMP算法中，进行模式匹配，在匹配失败时，主串的位置i不回溯，模式串需要根据改进的失败函数nextval[j]的值，j转移到nextval[j]位置继续进行比较。 12345678910111213141516171819void getnextval(char P[], int nextval[],int m)&#123; nextval[0] = -1; int j = 0; int k = -1; while (j &lt; m-1) &#123; if (k == -1 || P[j] == P[k]) &#123; j++; k++; if(P[j] == P[k]) nextval[j]=nextval[k]; else nextval[j] = k; &#125; else k = nextval[k]; &#125;&#125; 5.KMP算法的具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAXLEN 255void getnext(char P[], int next[],int m);int KMP(char T[],char P[],int next[],int n,int m);int main()&#123;char T[100],P[100];cin&gt;&gt;T&gt;&gt;P;int n=strlen(T),m=strlen(P);int next[m];getnext(P,next,m);for(int i=0;i&lt;m;i++)cout&lt;&lt;next[i]&lt;&lt;endl;cout&lt;&lt;&quot;主串和子串在第&quot;&lt;&lt;KMP(T,P,next,n,m)&lt;&lt;&quot;个字符处首次匹配\\n&quot;;//下标从0计return 0;&#125;void getnext(char P[], int next[],int m)&#123; next[0] = -1; int j = 0; int k = -1; while (j &lt; m-1) &#123; if (k == -1 || P[j] == P[k]) &#123; j++; k++; next[j] = k; &#125; else &#123; k = next[k]; &#125; &#125;&#125;int KMP(char T[],char P[],int next[],int n,int m)&#123; int i=0; int j=0; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (j == -1 || T[i] == P[j]) &#123; i++; j++; &#125; else &#123; j=next[j]; &#125; &#125; if (j == m) &#123; return i-j; &#125; return -1;&#125;","path":"2022/04/22/字符串查找KMP算法/","date":"04-22","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"循环队列与链式队列","text":"1.循环队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;#define MAXQSIZE 100#define OK 1#define ERROR 0#define OVERFLOW -2typedef char QElemType;typedef char SElemType;typedef int Status;typedef struct &#123;QElemType *base;//初始化时动态分配存储空间 int front;//头指针 int rear;//尾指针&#125; SqQueue;Status EnQueue(SqQueue &amp;Q, QElemType e);Status DeQueue(SqQueue &amp;Q, QElemType &amp;e);//算法3.11 循环队列的初始化Status InitQueue(SqQueue &amp;Q) &#123;//构造一个空队列Q Q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间 //存储分配失败 Q.front = Q.rear = 0; //头指针和尾指针置为零，队列为空 return OK;&#125;int main() &#123; SqQueue Q; QElemType e, j; int n,i; InitQueue(Q); cin&gt;&gt;n; //输入n的值 for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;e; //输入e的值 EnQueue(Q, e); &#125; while (DeQueue(Q, e))&#123; cout &lt;&lt; e &lt;&lt;endl; //输出e的值 &#125; return 0;&#125;//入队Status EnQueue(SqQueue &amp;Q, QElemType e) &#123;//插入元素e为Q的新的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满 return ERROR; Q.base[Q.rear] = e; //新元素插入队尾 Q.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1 return OK;&#125;//出队Status DeQueue(SqQueue &amp;Q, QElemType &amp;e)&#123; if(Q.front==Q.rear) return ERROR; e=Q.base[Q.front]; Q.front=(Q.front+1)%MAXQSIZE; return OK;&#125; 2.链式队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;#define OK 1#define ERROR 0#define OVERFLOW -2typedef char QElemType;typedef int Status;typedef char SElemType;//- - - - - 队列的链式存储结构- - - - - typedef struct QNode &#123; QElemType data; struct QNode *next;&#125; QNode, *QueuePtr;typedef struct &#123; QueuePtr front; //队头指针 QueuePtr rear; //队尾指针&#125; LinkQueue;Status EnQueue(LinkQueue &amp;Q, QElemType e); Status DeQueue(LinkQueue &amp;Q, QElemType &amp;e);//算法3.16 链队的初始化Status InitQueue(LinkQueue &amp;Q) &#123;//构造一个空队列Q Q.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点 Q.front-&gt;next = NULL; //头结点的指针域置空 return OK;&#125;int main() &#123; LinkQueue Q; QueuePtr p; QElemType e, j; int n,i; InitQueue(Q); cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;e; EnQueue(Q, e); &#125; while(DeQueue(Q,e)) cout&lt;&lt;e&lt;&lt;endl; return 0;&#125;//算法3.17 链队的入队Status EnQueue(LinkQueue &amp;Q, QElemType e) &#123; //插入元素e为Q的新的队尾元素 QueuePtr p; p = new QNode; //为入队元素分配结点空间，用指针p指向 p-&gt;data = e; //将新结点数据域置为e p-&gt;next = NULL; Q.rear-&gt;next = p; //将新结点插入到队尾 Q.rear = p; //修改队尾指针 return OK;&#125;//出队Status DeQueue(LinkQueue &amp;Q, QElemType &amp;e)&#123; QueuePtr p; p=new QNode; if(Q.front==Q.rear) return ERROR; p=Q.front-&gt;next; e=p-&gt;data; Q.front-&gt;next=p-&gt;next; if(Q.rear==p) Q.rear=Q.front; delete p; return OK;&#125;","path":"2022/04/22/循环队列与链式队列/","date":"04-22","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"顺序栈与链栈","text":"1.顺序栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;//顺序栈定义#define OK 1#define ERROR 0#define OVERFLOW -2#define MAXSIZE 100//顺序栈存储空间的初始分配量typedef int Status;typedef char SElemType;typedef struct &#123; SElemType *base;//栈底指针 SElemType *top;//栈顶指针 int stacksize;//栈可用的最大容量&#125; SqStack;Status InitStack(SqStack &amp;S);Status Push(SqStack &amp;S, SElemType e);//算法3.1 顺序栈的初始化Status InitStack(SqStack &amp;S) &#123;//构造一个空栈S S.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间 //存储分配失败 S.top = S.base; //top初始为base，空栈 S.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE return OK;&#125;int main() &#123; SqStack s; int n,i; SElemType x,t; InitStack(s); cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;x; Push(s,x); &#125; while (Pop(s, t))&#123; cout &lt;&lt; t &lt;&lt;endl;&#125; return 0;&#125;//入栈Status Push(SqStack &amp;S, SElemType e)&#123; if(S.top-S.base==S.stacksize) return ERROR; *S.top=e; S.top++; return OK;&#125;//出栈Status Pop(SqStack &amp;S, SElemType &amp;e)&#123; if(S.top==S.base) return ERROR; e=*--S.top; return OK;&#125; 2.链栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;#define OK 1#define ERROR 0#define OVERFLOW -2typedef int Status;typedef char SElemType;typedef struct StackNode &#123; SElemType data; struct StackNode *next;&#125; StackNode, *LinkStack;Status Push(LinkStack &amp;S, SElemType e) ;Status Pop(LinkStack &amp;S, SElemType &amp;e);//算法 链栈的初始化Status InitStack(LinkStack &amp;S) &#123; // 构造一个空栈 S，栈顶指针置空 S = NULL; return OK;&#125;int main() &#123; LinkStack s,p; int n,i; SElemType x,t; InitStack(s); cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;x; Push(s,x); &#125; while(Pop(s,t)) &#123; cout&lt;&lt;t&lt;&lt;endl; &#125; return 0;&#125;//算法 链栈的入栈Status Push(LinkStack &amp;S, SElemType e) &#123;//在栈顶插入元素e LinkStack p; p = new StackNode; //生成新结点 p-&gt;data = e; //将新结点数据域置为e p-&gt;next = S; //将新结点插入栈顶 S = p; //修改栈顶指针为p return OK;&#125;//出栈Status Pop(LinkStack &amp;S, SElemType &amp;e)&#123; if(S==NULL) return ERROR; e=S-&gt;data; LinkStack p; p=S; S=S-&gt;next; delete p; return OK;&#125;","path":"2022/04/22/顺序栈与链栈/","date":"04-22","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"3.Jsoup实现高效率爬虫","text":"Jsoup我们抓取到页面之后，还需要对页面进行解析。可以使用字符串处理工具解析页面，也可以使用正则表达式，但是这些方法都会带来很大的开发成本，所以我们需要使用一款专门解析html页面的技术。 1234567目录1.1 jsoup介绍1.2 使用dom方式遍历文档1.3 使用选择器语法查找元素1.4 Selector选择器概述1.5 Selector选择器组合使用2.0 实现案例 1.1 jsoup介绍jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 jsoup的主要功能如下： 从一个URL，文件或字符串中解析HTML； 使用DOM或CSS选择器来查找、取出数据； 可操作HTML元素、属性、文本； Jsoup工程准备maven工程 给pom.xml加入依赖 123456&lt;dependency&gt; &lt;!-- jsoup HTML parser library @ https://jsoup.org/ --&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.14.3&lt;/version&gt; &lt;/dependency&gt; 1 Jsoup可以直接输入字符串，并封装为Document对象 两种方式：1.解析文件 123456789101112public void testJsoupString() throws Exception &#123; //读取文件获取 String html = FileUtils.readFileToString(new File(&quot;D:\\\\jsoup.html&quot;), &quot;UTF-8&quot;); // 解析字符串 Document document = Jsoup.parse(html); //获取title的内容 Element title = document.getElementsByTag(&quot;title&quot;).first(); System.out.println(title.text());&#125; 2.获取网络资源 12String url=&quot;http://........&quot;; Document doc = Jsoup.connect(url).get(); 1.2 使用dom方式遍历文档元素获取（.first表示获取第一个） 123456789101112//1. 根据id查询元素getElementByIdElement element = document.getElementById(&quot;city_bj&quot;);//2. 根据标签获取元素getElementsByTagelement = document.getElementsByTag(&quot;title&quot;).first();//3. 根据class获取元素getElementsByClasselement = document.getElementsByClass(&quot;s_name&quot;).last();//4. 根据属性获取元素getElementsByAttributeelement = document.getElementsByAttribute(&quot;abc&quot;).first();element = document.getElementsByAttributeValue(&quot;class&quot;, &quot;city_con&quot;).first(); 1.3使用选择器语法查找元素jsoup elements对象支持类似于CSS (或jquery)的选择器语法，来实现非常强大和灵活的查找功能。这个select 方法在Document, Element,或Elements对象中都可以使用。且是上下文相关的，因此可实现指定元素的过滤，或者链式选择访问。 Select方法将返回一个Elements集合，并提供一组方法来抽取和处理结果。 1.4 Selector选择器概述tagname: 通过标签查找元素，比如：span #id: 通过ID查找元素，比如：# city_bj .class: 通过class名称查找元素，比如：.class_a [attribute]: 利用属性查找元素，比如：[abc] [attr&#x3D;value]: 利用属性值来查找元素，比如：[class&#x3D;s_name] 1234567891011121314151617//tagname: 通过标签查找元素，比如：spanElements span = document.select(&quot;span&quot;);for (Element element : span) &#123; System.out.println(element.text());&#125;//#id: 通过ID查找元素，比如：#city_bjjString str = document.select(&quot;#city_bj&quot;).text();//.class: 通过class名称查找元素，比如：.class_astr = document.select(&quot;.class_a&quot;).text();//[attribute]: 利用属性查找元素，比如：[abc]str = document.select(&quot;[abc]&quot;).text();//[attr=value]: 利用属性值来查找元素，比如：[class=s_name]str = document.select(&quot;[class=s_name]&quot;).text(); 1.5 Selector选择器组合使用el#id: 元素+ID，比如： h3#city_bj el.class: 元素+class，比如： li.class_a el[attr]: 元素+属性名，比如： span[abc] 任意组合: 比如：span[abc].s_name ancestor child: 查找某个元素下子元素，比如：.city_con li 查找”city_con”下的所有li parent &gt; child: 查找某个父元素下的直接子元素，比如： .city_con &gt; ul &gt; li 查找city_con第一级（直接子元素）的ul，再找所有ul下的第一级li parent &gt; *: 查找某个父元素下所有直接子元素 123456789101112131415161718192021//el#id: 元素+ID，比如： h3#city_bjString str = document.select(&quot;h3#city_bj&quot;).text();//el.class: 元素+class，比如： li.class_astr = document.select(&quot;li.class_a&quot;).text();//el[attr]: 元素+属性名，比如： span[abc]str = document.select(&quot;span[abc]&quot;).text();//任意组合，比如：span[abc].s_namestr = document.select(&quot;span[abc].s_name&quot;).text();//ancestor child: 查找某个元素下子元素，比如：.city_con li 查找&quot;city_con&quot;下的所有listr = document.select(&quot;.city_con li&quot;).text();//parent &gt; child: 查找某个父元素下的直接子元素，//比如：.city_con &gt; ul &gt; li 查找city_con第一级（直接子元素）的ul，再找所有ul下的第一级listr = document.select(&quot;.city_con &gt; ul &gt; li&quot;).text();//parent &gt; * 查找某个父元素下所有直接子元素.city_con &gt; *str = document.select(&quot;.city_con &gt; *&quot;).text(); 实现案例 12345678910111213141516171819202122232425262728293031public class Dome4 &#123; public static void main(String[] args) throws IOException &#123; String url=&quot;http://........&quot;; Document doc = Jsoup.connect(url).get(); Elements picture=doc.select(&quot;img[src$=.jpg]&quot;); Elements urlpath= doc.select(&quot;a[href]&quot;); Elements title =doc.select(&quot;h2&quot;); int j=0; String photo[]=new String[50]; String path[]=new String[50]; String name[]=new String[50]; for (Element link : picture) &#123; //System.out.println(link.attr(&quot;abs:src&quot;)); photo[j]=link.attr(&quot;abs:src&quot;); j++; &#125; j=0; for (Element link : urlpath) &#123; //System.out.println(link.attr(&quot;abs:href&quot;)); path[j]=link.attr(&quot;abs:href&quot;); j++; &#125; j=0; for (Element link : title) &#123; //System.out.println(link.text()); name[j]=link.text(); j++; &#125; &#125; &#125; 2.对象类 123456789public class Attribute &#123; String name; String pid0; String pid; int level; String url; //类属性的set，get方法省略&#125; 1234567891011121314151617181920212223242526272829public class Dome5 &#123; public static void main(String[] args) throws Exception &#123; String url = &quot;https://.........&quot;; Document doc = Jsoup.connect(url).get(); Elements doc1 = doc.select(&quot;div[class=\\&quot;navigation-box\\&quot;]&quot;); ArrayList&lt;Attribute&gt; list = new ArrayList&lt;&gt;(); for (Element path : doc1) &#123; Elements doc2 = path.select(&quot;a[href]&quot;); Elements doc3 = path.select(&quot;h4&quot;); String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); for (Element path1 : doc2) &#123; Attribute attribute = new Attribute(); String id = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); attribute.pid0 = id; attribute.level = 2; attribute.pid = uuid; attribute.url = path1.attr(&quot;abs:href&quot;); attribute.name = path1.text(); for (Element path2 : doc3) &#123; if (path2.toString().contains(path1.toString())) &#123; attribute.setPid0(&quot;0&quot;); attribute.setLevel(1); &#125; &#125; list.add(attribute); &#125; &#125; &#125;&#125; 具体详解请看 https://www.cnblogs.com/zhangyinhua/p/8037599.html","path":"2022/04/21/Jsoup实现高效率爬虫/","date":"04-21","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"2.JAVA实现http请求的三种方式","text":"JAVA实现http请求的三种方式1、HttpURLConnection： HttpURLConnection是java的标准类，什么都没封装，用起来太原始，不方便，比如重访问的自定义，以及一些高级功能等。 2、java.net.http.HttpClientjdk11正式启用自带HttpClient，代替之前比较旧的HttpURLConnection。其实从java9的jdk.incubator.httpclient模块迁移到java.net.http模块，包名由jdk.incubator.http改为java.net.http。 3、Apache HttpClient：在Android中，AndroidSDK中集成了Apache的HttpClient模块，HttpClient就是一个增强版的HttpURLConnection，它只是关注于如何发送请求、接收响应，以及管理HTTP连接。 1.HttpURLConnection 12345678910111213141516171819202122public class Dome3 &#123; public static void main(String[] args) throws IOException &#123; //1.构造网络资源实例 String urlPath = &quot;https://www.360kuai.com/&quot;; URL url = new URL(urlPath); //2.获取输入流，准备向内存读入数据 URLConnection urlConnection = url.openConnection(); InputStream in = urlConnection.getInputStream(); //3.读取数据逻辑实现 InputStreamReader reader = new InputStreamReader(in, StandardCharsets.UTF_8); char[] b = new char[1024]; int i = 0; StringBuilder sb = new StringBuilder(); while (-1 != (i = reader.read(b))) &#123; sb.append(String.valueOf(b, 0, i)); &#125; in.close(); System.out.println(sb); &#125;&#125; 2.java.net.http.HttpClient 123456789101112131415161718192021222324public class Dome01 &#123; public static void main(String[] args) throws IOException &#123; String url=&quot;https://www.360kuai.com/&quot;; HttpClient client = new DefaultHttpClient(); HttpGet get = new HttpGet(url); //发起请求 HttpResponse response = client.execute(get); //获取响应体 HttpEntity entity = response.getEntity(); if (entity != null) &#123; InputStream instream = entity.getContent(); try &#123; BufferedReader reader = new BufferedReader(new InputStreamReader(instream, &quot;UTF-8&quot;)); System.out.println(reader.readLine()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; instream.close(); &#125; &#125; // 关闭连接. client.getConnectionManager().shutdown(); &#125;&#125; 3.Apache HttpClient： 123456789101112131415161718192021222324252627282930313233public class Dome2 &#123; public static void main(String[] args) throws IOException &#123; //创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); //创建HttpGet请求 HttpGet httpGet = new HttpGet(&quot;http://www.itcast.cn/&quot;); CloseableHttpResponse response = null; try &#123; //使用HttpClient发起请求 response = httpClient.execute(httpGet); //判断响应状态码是否为200 if (response.getStatusLine().getStatusCode() == 200) &#123; //如果为200表示请求成功，获取返回数据 String content = EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;); //打印数据长度 System.out.println(content); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //释放连接 if (response == null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 总结：​ CloseableHttpClient是在HttpClient的扩展的，是目前推荐的用法。不仅可以简单设置请求头，还可以利用fastjson转换请求或返回结果字符串为json格式。HttpClient是一个简单的HTTP客户端（不是浏览器），可以看做一个增强版的HttpURLConnection，它关注于如何发送请求、接收响应，以及管理HTTP连接，但不会缓存服务器的响应，不能执行HTML页面中嵌入的Javascript代码；也不会对页面内容进行任何解析、处理。","path":"2022/04/16/JAVA实现http请求的三种方式/","date":"04-16","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"1.爬虫实例-存储到本地与传到数据库","text":"爬虫实例12345678910111213141516171819202122目录一.获取有用数据1.构造网络资源实例2.获取输入流3.读取数据逻辑实现4.对数据进行处理（每个资源不同的部分）4.1 把html文件中的实体转化为用户可读的字符4.2 因为带有换行和制表符的字符串不利于后期处理，所以把字符串中的空白都消除掉4.3 根据规律截取目标字符串4.4 将目标字符串按照规律进行切分成一组数据二.将处理结果中的声音资源下载到本地1.获取网络文件的地址2.创建网络资源对象3.获取输入流，向内存存储数据4.创建本地文件，必须先创建目录，再创建文件，除非是单文件，创建过程中勿忘判断目录是否存在5.创建内存连接到磁盘文件的流，因为要把内存数据写到磁盘上，所以是输出流三.将最终结果连同本地文件路径持久化到数据库1.注册数据库的驱动2.获取数据库连接3.需要执行的sql语句4.获取预处理对象，并依次给参数赋值5.执行sql语句 1234567用到的知识1.输入输出流2.字符串的处理3.ArrayList&lt;&gt;4.HashMap&lt;key,value&gt;5.连接数据库的准备6.sql语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import org.apache.commons.lang.StringEscapeUtils;import java.io.*;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.HashMap;public class MainClass &#123; public static void main(String[] args) throws IOException &#123; //1.构造网络资源实例，爬取网址音频仅供学习参考 String urlPath = &quot;http://.............&quot;; URL url = new URL(urlPath); //2.获取输入流，准备向内存读入数据 URLConnection urlConnection = url.openConnection(); InputStream in = urlConnection.getInputStream(); //3.读取数据逻辑实现 InputStreamReader reader = new InputStreamReader(in,StandardCharsets.UTF_8); char[] b = new char[1024]; int i = 0; StringBuilder sb = new StringBuilder(); while(-1!=(i=reader.read(b)))&#123; sb.append(String.valueOf(b,0,i)); &#125; in.close();//sb中的部分网页源码如下 /*&lt;script type=&quot;text/javascript&quot;&gt;$(document).ready(function()&#123; new jPlayerPlaylist(&#123; jPlayer: &quot;#jquery_jplayer_1&quot;, cssSelectorAncestor: &quot;#jp_container_1&quot;//截取开始字符 &#125;, [&#123;title:&quot;&amp;#22823;&amp;#24754;&amp;#21650;(&amp;#32463;&amp;#20856;&amp;#29256;)&quot;, m4a:&quot;http://23.225.35.235:26/a/3/53.m4a&quot;,&#123;title:&quot;&amp;#20845;&amp;#23383;&amp;#22823;&amp;#26126;&amp;#21650;(&amp;#32768;&amp;#19968;&amp;#27861;&amp;#24072;)&quot;,...title:&quot;[&amp;#20934;&amp;#25552;&amp;#21650;] &amp;#20256;&amp;#21916;&amp;#27861;&amp;#24072;-&amp;#20934;&amp;#25552;&amp;#21650;&quot;, m4a:&quot;http://23.225.35.235:26/a/3/20.m4a&quot;,&#125;,], &#123; swfPath: &quot;js/j.swf&quot;,//结束字符 supplied: &quot;m4a, mp3&quot;, wmode: &quot;window&quot;, useStateClassSkin: true, autoBlur: false, smoothPlayBar: true, keyEnabled: true &#125;);&#125;);*/ //4.对数据进行处理 //4.1 把html文件中的实体转化为用户可读的字符 String result = StringEscapeUtils.unescapeHtml(sb.toString()); //4.2 因为带有换行和制表符的字符串不利于后期处理，所以把字符串中的空白都消除掉 String s = result.replaceAll(&quot;\\\\s*&quot;, &quot;&quot;); //4.3 根据规律截取目标字符串 String begin = &quot;cssSelectorAncestor:\\&quot;#jp_container_1\\&quot;&#125;,[&quot;; String end = &quot;,&#123;swfPath:\\&quot;js/j.swf\\&quot;&quot;; int start = s.indexOf(begin) + begin.length(); int finish = s.indexOf(end); String substring = s.substring(start, finish-1); //4.4 将目标字符串按照规律进行切分成一组数据 ArrayList&lt;HashMap&lt;String,String&gt;&gt; list = new ArrayList&lt;&gt;(); String[] split = substring.split(&quot;,&#125;,&quot;); for (String item:split ) &#123; String[] items = item.split(&quot;\\&quot;&quot;); //System.out.println(item); HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;title&quot;,items[1]); map.put(&quot;path&quot;,items[3]); list.add(map); &#125; System.out.print(list); //5 将处理结果中的声音资源下载到本地 TODO //单个例子 //5.1 获取网络文件的地址 String path = list.get(0).get(&quot;path&quot;);//网络文件地址 System.out.println(path); //5.2 创建网络资源对象 URL urlFile = new URL(path); URLConnection fileConnect = urlFile.openConnection(); int contentLength = fileConnect.getContentLength();//文件总长度 int finishLength = 0; //5.3 获取输入流，向内存存储数据 InputStream inputStream = fileConnect.getInputStream(); byte[] fileBytes = new byte[2048*2048*100];//文件有点大，用个大点的数组，读取速度快 //5.4 创建本地文件，必须先创建目录，再创建文件，除非是单文件，创建过程中勿忘判断目录是否存在 File destDict = new File(&quot;D://buddhist_scripture&quot;);//先创建文件夹 if(!destDict.exists())&#123; destDict.mkdirs(); &#125; // String filename = list.get(0).get(&quot;title&quot;); File destFile = new File(destDict.getPath()+File.separator+filename+&quot;.m4a&quot;); //5.5 创建内存连接到磁盘文件的流，因为要把内存数据写到磁盘上，所以是输出流 FileOutputStream fileOutputStream = new FileOutputStream(destFile); System.out.println(&quot;保存到文件&quot;+destFile.getPath()); //开始边读边写 int len = 0; while (-1 !=(len = inputStream.read(fileBytes))) &#123; finishLength+=len; fileOutputStream.write(fileBytes,0,len); System.out.println(&quot;总大小：&quot;+contentLength+&quot;,已经下载：&quot;+finishLength+&quot;下载进度:&quot;+((float)finishLength/(float)contentLength)*100+&quot;%&quot;); &#125; fileOutputStream.flush(); fileOutputStream.close(); inputStream.close(); System.out.println(&quot;下载完成&quot;); //6 将最终结果连同本地文件路径持久化到数据库 TODO &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536 private static HashMap&lt;String, String&gt;[] resultList=list; List&lt;HashMap&lt;String,String&gt;&gt; resultList=new List&lt;HashMap&lt;String, String&gt;&gt;(list); static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;; static final String DB_URL = &quot;jdbc:mysql://localhost:3306/fx_db(数据库名)? useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;; // 数据库的用户名与密码，需要根据自己的设置 static final String USER = &quot;root&quot;;//数据库用户名，默认是root static final String PASS = &quot;&quot;;//数据库密码 public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //1.注册数据库的驱动 Class.forName(JDBC_DRIVER); //2.获取数据库连接（里面内容依次是：&quot;jdbc:mysql://主机名:端口号/数据库名&quot;,&quot;用户名&quot;,&quot;登录密码&quot;） Connection connection = DriverManager.getConnection(DB_URL, USER, PASS); //3.需要执行的sql语句（?是占位符，代表一个参数） //String sql = &quot;insert into stu(id,name,age) values(?,?,?)&quot;; String sql = &quot;insert into fx_audio(数据库表名) (id, name, path,create_time,type) values (?,?,?,?,?)&quot;; //4.获取预处理对象，并依次给参数赋值 PreparedStatement stmt = connection.prepareStatement(sql); for(HashMap&lt;String,String&gt; map:resultList) &#123; String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); stmt.setString(1,uuid); stmt.setString(2,map.get(&quot;name&quot;)); stmt.setString(3,map.get(&quot;path&quot;)); stmt.setDate(4,new java.sql.Date(new Date().getTime())); stmt.setString(5,map.get(&quot;type&quot;)); stmt.executeUpdate(); &#125; //5.执行sql语句（执行了几条记录，就返回几） //int i = stmt.executeUpdate(); System.out.println(&quot;完成&quot;); //6.关闭jdbc连接 stmt.close(); connection.close(); &#125;&#125;","path":"2022/04/06/爬虫实例-存储到本地与传到数据库/","date":"04-06","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"数据与结构之链表","text":"1234目录一，链式存储结构的逻辑二，链式存储结构的图书信息表的实现三，test：基于链式存储结构的图书信息表的创建和输出 一，链式存储结构的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;using namespace std;#define ERROR 0typedef struct LNode &#123;int data; //结点的数据域struct LNode *next; //结点的指针域&#125; LNode, *List; //LinkList为指向结构体LNode的指针类型void InitList(List &amp;L)&#123; L=new LNode; L-&gt;next=NULL;&#125;void ListInput(List &amp;L, int n) //链表数据的输入&#123; int i=1; List p, r; r = L; while (i&lt;=n) &#123; p = new LNode; cin &gt;&gt; p-&gt;data; p-&gt;next = NULL; r-&gt;next = p; r = p; i++; &#125;&#125;void ListOutput(List L) //输出List&#123; List p; p = L-&gt;next; cout &lt;&lt; &quot;The List is:&quot;&lt;&lt;endl; while (p != NULL) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125;//查找bool LocateElem(List L, int e)&#123; List p; bool flag=false; p = L-&gt;next; while(p!=NULL)&#123; if(p-&gt;data==e) flag=true; p=p-&gt;next; &#125; return flag;&#125;//插入void ListInsert(List &amp;L, int i,int e)&#123; List p; p=L; int j=0; while(p&amp;&amp;(j&lt;i-1))&#123; p=p-&gt;next; ++j; &#125; List s; s=new LNode; s-&gt;data=e; s-&gt;next; s-&gt;next=p-&gt;next; p-&gt;next=s;&#125;//删除void ListDelete(List &amp;L, int i)&#123; List p; p=L; int j=0; while(p&amp;&amp;(j&lt;i-1))&#123; p=p-&gt;next; ++j; &#125; List q; q=p-&gt;next; p-&gt;next=q-&gt;next; delete q;&#125; 二，链式存储结构的图书信息表的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;iomanip&gt;#include&lt;fstream&gt;using namespace std;#define OK 1#define ERROR 0#define OVERFLOW -2typedef int Status; //Status 是函数返回值类型，其值是函数结果状态代码。typedef int ElemType; //ElemType 为可定义的数据类型，此设为int类型struct Book &#123; string id;//ISBN string name;//书名 double price;//定价&#125;;typedef struct LNode &#123; Book data; //结点的数据域 struct LNode *next; //结点的指针域&#125; LNode, *LinkList; //LinkList为指向结构体LNode的指针类型string head_1, head_2, head_3;int length;Status InitList_L(LinkList &amp;L) &#123; //算法2.6 单链表的初始化 //构造一个空的单链表L L = new LNode; //生成新结点作为头结点，用头指针L指向头结点 L-&gt;next = NULL; //头结点的指针域置空 return OK;&#125;Status GetElem_L(LinkList L, int i, Book &amp;e) &#123; //算法2.7 单链表的取值 //在带头结点的单链表L中查找第i个元素 //用e返回L中第i个数据元素的值 int j; LinkList p; p = L-&gt;next; j = 1; //初始化，p指向第一个结点，j为计数器 while (j &lt; i &amp;&amp; p) &#123; //顺链域向后扫描，直到p指向第i个元素或p为空 p = p-&gt;next; //p指向下一个结点 ++j; //计数器j相应加1 &#125; if (!p || j &gt; i) return ERROR; //i值不合法i＞n或i&lt;=0 e = p-&gt;data; //取第i个结点的数据域 return OK;&#125; //GetElem_LLNode *LocateElem_L(LinkList L, int e) &#123; //算法2.8 按值查找 //在带头结点的单链表L中查找值为e的元素 LinkList p; p = L-&gt;next; while (p &amp;&amp; p-&gt;data.price != e)//顺链域向后扫描，直到p为空或p所指结点的数据域等于e p = p-&gt;next; //p指向下一个结点 return p; //查找成功返回值为e的结点地址p，查找失败p为NULL &#125; //LocateElem_LStatus ListInsert_L(LinkList &amp;L, int i, Book &amp;e) &#123; //算法2.9 单链表的插入 //在带头结点的单链表L中第i个位置插入值为e的新结点 int j; LinkList p, s; p = L; j = 0; while (p &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; ++j; &#125;//查找第i?1个结点，p指向该结点 if (!p || j &gt; i - 1) return ERROR; //i＞n+1或者i＜1 s = new LNode; //生成新结点*s s-&gt;data = e; //将结点*s的数据域置为e s-&gt;next = p-&gt;next; //将结点*s的指针域指向结点ai p-&gt;next = s; //将结点*p的指针域指向结点*s ++length; return OK;&#125; //ListInsert_LStatus ListDelete_L(LinkList &amp;L, int i) &#123; //算法2.9 单链表的删除 //在带头结点的单链表L中，删除第i个位置 LinkList p, q; int j; p = L; j = 0; while ((p-&gt;next) &amp;&amp; (j &lt; i - 1)) //查找第i?1个结点，p指向该结点 &#123; p = p-&gt;next; ++j; &#125; if (!(p-&gt;next) || (j &gt; i - 1)) return ERROR; //当i&gt;n或i&lt;1时，删除位置不合理 q = p-&gt;next; //临时保存被删结点的地址以备释放 p-&gt;next = q-&gt;next; //改变删除结点前驱结点的指针域 delete q; //释放删除结点的空间 --length; return OK;&#125; //ListDelete_Lvoid CreateList_H(LinkList &amp;L, int n) &#123; //算法2.11 前插法创建单链表 //逆位序输入n个元素的值，建立到头结点的单链表L LinkList p; L = new LNode; L-&gt;next = NULL; //先建立一个带头结点的空链表 length = 0; fstream file; file.open(&quot;book.txt&quot;); if (!file) &#123; cout &lt;&lt; &quot;未找到相关文件，无法打开！&quot; &lt;&lt; endl; exit(ERROR); &#125; file &gt;&gt; head_1 &gt;&gt; head_2 &gt;&gt; head_3; while (!file.eof()) &#123; p = new LNode; //生成新结点*p file &gt;&gt; p-&gt;data.id &gt;&gt; p-&gt;data.name &gt;&gt; p-&gt;data.price; //输入元素值赋给新结点*p的数据域 p-&gt;next = L-&gt;next; L-&gt;next = p; //将新结点*p插入到头结点之后 length++;//同时对链表长度进行统计 &#125; file.close();&#125; //CreateList_Fvoid CreateList_R(LinkList &amp;L, int n) &#123; //算法2.12 后插法创建单链表 //正位序输入n个元素的值，建立带表头结点的单链表L LinkList p, r; L = new LNode; L-&gt;next = NULL; //先建立一个带头结点的空链表 r = L; //尾指针r指向头结点 length = 0; fstream file; //打开文件进行读写操作 file.open(&quot;book.txt&quot;); if (!file) &#123; cout &lt;&lt; &quot;未找到相关文件，无法打开！&quot; &lt;&lt; endl; exit(ERROR); &#125; file &gt;&gt; head_1 &gt;&gt; head_2 &gt;&gt; head_3; while (!file.eof()) &#123; //将文件中的信息运用后插法插入到链表中 p = new LNode;//生成新结点 file &gt;&gt; p-&gt;data.id &gt;&gt; p-&gt;data.name &gt;&gt; p-&gt;data.price;//输入元素值赋给新结点*p的数据域 p-&gt;next = NULL; r-&gt;next = p;//将新结点*p插入尾结点*r之后 r = p;//r指向新的尾结点*p length++; //同时对链表长度进行统计 &#125; file.close();&#125; //CreateList_Lint main() &#123; int a, n, choose; double price; Book e; LinkList L, p; cout &lt;&lt; &quot;1. 建立\\n&quot;; cout &lt;&lt; &quot;2. 输入\\n&quot;; cout &lt;&lt; &quot;3. 取值\\n&quot;; cout &lt;&lt; &quot;4. 查找\\n&quot;; cout &lt;&lt; &quot;5. 插入\\n&quot;; cout &lt;&lt; &quot;6. 删除\\n&quot;; cout &lt;&lt; &quot;7. 输出\\n&quot;; cout &lt;&lt; &quot;0. 退出\\n\\n&quot;; choose = -1; while (choose != 0) &#123; cout &lt;&lt; &quot;请选择:&quot;; cin &gt;&gt; choose; switch (choose) &#123; case 1: //建立一个单链表 if (InitList_L(L)) cout &lt;&lt; &quot;成功建立链表!\\n\\n&quot;; break; case 2: //使用后插法创建单链表 CreateList_R(L, length); cout &lt;&lt; &quot;输入 book.txt 信息完毕\\n\\n&quot;; break; case 3: //单链表的按序号取值 cout &lt;&lt; &quot;请输入一个位置用来取值:&quot;; cin &gt;&gt; a; if (GetElem_L(L, a, e)) &#123; cout &lt;&lt; &quot;查找成功\\n&quot;; cout &lt;&lt; &quot;第&quot; &lt;&lt; a &lt;&lt; &quot;本图书的信息是：\\n&quot;; cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; e.id &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(50) &lt;&lt; e.name &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(5) &lt;&lt; e.price &lt;&lt; endl &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;查找失败\\n\\n&quot;; break; case 4: //单链表的按值查找 cout &lt;&lt; &quot;请输入所要查找价格:&quot;; cin &gt;&gt; price; if (LocateElem_L(L, price) != NULL) &#123; cout &lt;&lt; &quot;查找成功\\n&quot;; cout &lt;&lt; &quot;该价格对应的书名为：&quot; &lt;&lt; LocateElem_L(L, price)-&gt;data.name &lt;&lt; endl &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;查找失败! 定价&quot; &lt;&lt; price &lt;&lt; &quot; 没有找到\\n\\n&quot;; break; case 5: //单链表的插入 cout &lt;&lt; &quot;请输入插入的位置和书的信息，包括：编号 书名 价格（用空格隔开）:&quot;; cin &gt;&gt; a; cin &gt;&gt; e.id &gt;&gt; e.name &gt;&gt; e.price; if (ListInsert_L(L, a, e)) cout &lt;&lt; &quot;插入成功.\\n\\n&quot;; else cout &lt;&lt; &quot;插入失败!\\n\\n&quot;; break; case 6: //单链表的删除 cout &lt;&lt; &quot;请输入所要删除的书籍的位置:&quot;; cin &gt;&gt; a; if (ListDelete_L(L, a)) cout &lt;&lt; &quot;删除成功!\\n\\n&quot;; else cout &lt;&lt; &quot;删除失败!\\n\\n&quot;; break; case 7: //单链表的输出 cout &lt;&lt; &quot;当前图书系统信息（链表）读出:\\n&quot;; p = L-&gt;next; while (p) &#123; cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; p-&gt;data.id &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw( 50) &lt;&lt; p-&gt;data.name &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(5) &lt;&lt; p-&gt;data.price &lt;&lt; endl; p = p-&gt;next; &#125; cout &lt;&lt; endl; break; &#125; &#125; return 0;&#125; 三，基于链式存储结构的图书信息表的创建和输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;iomanip&gt;using namespace std;#define ERROR 0typedef struct LNode &#123; string id;//ISBN string name;//书名 double price;//结点的数据域struct LNode *next; //结点的指针域&#125; LNode, *List; //LinkList为指向结构体LNode的指针类型void InitList(List &amp;L); //创建链表(带头结点)void ListInput(List &amp;L); //链表数据的输入void ListOutput(List L); //输出Listint main()&#123;List LA;InitList(LA);ListInput(LA);ListOutput(LA);return 0;&#125;void InitList(List &amp;L)&#123; L=new LNode; L-&gt;next=NULL;&#125;void ListInput(List &amp;L) //链表数据的输入&#123;int i=0;List p,r;r = L;p = new LNode;cin&gt;&gt;p-&gt;id&gt;&gt;p-&gt;name&gt;&gt;p-&gt;price;while(p-&gt;id!=&quot;0&quot;&amp;&amp;p-&gt;name!=&quot;0&quot;&amp;&amp;p-&gt;price!=0)&#123; p-&gt;next = NULL; r-&gt;next = p; r = p; p = new LNode;cin&gt;&gt;p-&gt;id&gt;&gt;p-&gt;name&gt;&gt;p-&gt;price; i++; &#125; cout &lt;&lt; i&lt;&lt;endl;&#125;void ListOutput(List L) //输出List&#123;List p;p = L-&gt;next;while (p != NULL) &#123;cout&lt;&lt;p-&gt;id&lt;&lt;&#x27; &#x27;&lt;&lt;p-&gt;name&lt;&lt;&#x27; &#x27;&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;p-&gt;price&lt;&lt;endl;p = p-&gt;next;&#125;cout &lt;&lt; endl;&#125;","path":"2022/04/05/数据与结构之链表/","date":"04-05","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"数据与结构之顺序表","text":"1234目录一，顺序表的逻辑二，顺序表的实现三，基于顺序存储结构的图书信息表的创建和输出（C++版） 一，顺序表的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;stdio.h&gt;#include&lt;malloc.h&gt; //头文件包含命令#define List_init_size 100 //符号常量的定义#define Listincrement 100#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2typedef int Elemtype;//抽象数据类型elemtype具体化为int类型typedef int Status;typedef struct &#123; //定义结构体 Elemtype *elem; int length; int listsize;&#125;Sqlist;Status Initlist_sq(Sqlist *l) //函数（初始化顺序表）初始化失败则返回-2&#123; l-&gt;elem =(Elemtype*)malloc(sizeof(Elemtype)); if(!l-&gt;elem ) return(OVERFLOW); l-&gt;length =0; l-&gt;listsize =List_init_size; return OK;&#125;Status Creatlist_sq(Sqlist *l,int n) //初始化顺序表为含有n个元素的顺序表&#123; int i; printf(&quot;Input %d numbers:\\n&quot;,n); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;(l-&gt;elem [i])); l-&gt;length =n; return OK;&#125;void Outputlist_sq(Sqlist *l) //函数（输出顺序表的元素）&#123; int i; for(i=0;i&lt;l-&gt;length ;i++) &#123; printf(&quot;%5d&quot;,l-&gt;elem [i]); if((i+1)%5==0) printf(&quot;\\n&quot;); &#125; printf(&quot;\\n&quot;);&#125;void Destroylist_sq(Sqlist*l) //销毁顺序表l&#123; free(l-&gt;elem );&#125;Status Insertlist_sq(Sqlist*l,int i,Elemtype e) //在顺序表的第i个位置前插入元素e&#123; int j; Elemtype *p; if(i&gt;l-&gt;length ) &#123; printf(&quot;输入数据不合法!&quot;); return (OVERFLOW); &#125; if(l-&gt;length&gt;=l-&gt;listsize ) &#123; Elemtype *p; p=(Elemtype*)realloc(l-&gt;elem ,(List_init_size+Listincrement)*sizeof(Elemtype)); if(p==0) &#123; return(OVERFLOW);&#125; l-&gt;elem =p; l-&gt;listsize =+Listincrement; &#125; p=&amp;(l-&gt;elem[i-1]); for(j=l-&gt;length +1;j&gt;=i;j--) l-&gt;elem [j]=l-&gt;elem [j-1]; *p=e; l-&gt;length ++; return OK;&#125;Elemtype Deletelist_sq(Sqlist*l,int i)//函数（删除）用e返回删除的元素&#123; int j; Elemtype e; e=l-&gt;elem [i-1]; for(j=i-1;j&lt;l-&gt;length-1 ;j++) l-&gt;elem [j]=l-&gt;elem [j+1]; l-&gt;elem [l-&gt;length -1]=0; l-&gt;length --; return e;&#125; 二，顺序表的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;# define List_Init_Size 100# define ListIncrement 10typedef int ElemType; //定义数据元素的类型 typedef struct &#123; ElemType *elem; //存储空间基址 int length; //当前长度(数据元素个数) int ListSize;//当前分配的存储容量&#125; Sqlist; //定义顺序表的类型 bool InitList (Sqlist *L); //顺序表初始化函数void InsertList(Sqlist *L,int i,ElemType x); //向向顺序表插入第i个元素//顺序表初始化函数 bool InitList (Sqlist *L)&#123; L-&gt;elem=(ElemType *)malloc(List_Init_Size*sizeof(ElemType));//为顺序表分配一个大小为List_Init_Size的数组空间 if (!L-&gt;elem) exit(0) ; L-&gt;length=0; L-&gt;ListSize=List_Init_Size; return true;&#125;//向顺序表插入第i个元素 void InsertList(Sqlist *L,int i,ElemType x) &#123; //int j; if(i &lt;1 || i &gt;L-&gt;length+1) &#123;printf(&quot;Position error&quot;); return; &#125; if(L-&gt;length&gt;=L-&gt;ListSize) &#123;printf(&quot;overflow&quot;); exit(EXIT_FAILURE); &#125; for(int j=L-&gt;length-1;j&gt;= i-1;--j) L-&gt;elem[j+1]=L-&gt;elem[j]; L-&gt;elem[i-1]=x; ++L-&gt;length; return; &#125; //删除顺序表中第i个数据元素void deleteList(Sqlist *L,int i) &#123; int j; if(i&lt;1 || i&gt;L-&gt;length) &#123; printf(&quot;Position error&quot;); return; &#125; for(j=i;j&lt;L-&gt;length;j++) L-&gt;elem[j-1]=L-&gt;elem[j]; L-&gt;length--;&#125;//查找元素x，找到返回序号，找不到返回0int Locate(Sqlist L, ElemType x)&#123; int i=1; while(i&lt;=L.length &amp;&amp; L.elem[i-1]!=x) ++i; if(i&lt;=L.length) return i; else return 0;&#125;//获取第i个元素 void GetElem(Sqlist L,int i, ElemType *e)&#123; *e=L.elem[i-1];&#125;//返回顺序表的长度 int ListLength(Sqlist L)&#123; return L.length;&#125;//输出顺序表 void Output(Sqlist L)&#123; printf(&quot;number of elements：%d\\n&quot;,L.length); for (int i=1;i&lt;=L.length;i++) &#123; printf(&quot;%d element:%d\\n&quot;,i,L.elem[i-1]); &#125;&#125;//输入n个数据元素 void Input(Sqlist *L)&#123; int n,x; scanf (&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) &#123; scanf (&quot;%d&quot;,&amp;x); L-&gt;elem[i-1]=x; L-&gt;length++; &#125;&#125;//两个线性表并运算 void unio(Sqlist *La,Sqlist Lb) &#123; ElemType e; int La_len=La-&gt;length; int Lb_len=Lb.length; for(int i=1;i&lt;=Lb_len;++i) &#123; GetElem(Lb,i,&amp;e); if(!Locate(*La,e)) InsertList(La,++La_len,e); &#125; Output(*La);&#125;//将两个顺序表合并到第三个顺序表中 void mergelist(Sqlist La,Sqlist Lb,Sqlist *Lc)&#123; int i=1,j=1,k=0; ElemType ai,bj; int La_len=ListLength(La); int Lb_len=ListLength(Lb); while((i&lt;=La_len)&amp;&amp;(j&lt;=Lb_len)) &#123; GetElem(La,i,&amp;ai);GetElem(Lb,j,&amp;bj); if(ai&lt;=bj) &#123; InsertList(Lc,++k,ai);++i; &#125; else &#123;InsertList(Lc,++k,bj);++j;&#125; &#125; while(i&lt;=La_len)&#123; GetElem(La,i++,&amp;ai);InsertList(Lc,++k,ai); &#125; while(j&lt;=Lb_len)&#123; GetElem(Lb,j++,&amp;bj);InsertList(Lc,++k,bj); &#125; Output(*Lc); &#125;int main(int argc, const char * argv[]) &#123; //主函数 Sqlist L,La,Lb,Lc; int conti=1,choice=0,loc=0; ElemType x; while (conti) &#123; printf(&quot;1.Initial 2.Insert 3.Delete 4.Locate 5.并集 6.Merge 7.Output 8.Exit&quot;); scanf (&quot;%d&quot;,&amp;choice); switch (choice)&#123; int i; case 1: InitList(&amp;L);break; case 2: printf(&quot;请输入要插入的位置&quot;); scanf (&quot;%d&quot;,&amp;i); printf(&quot;请输入要插入的内容&quot;); scanf (&quot;%d&quot;,&amp;x); InsertList(&amp;L,i,x); break; case 3: printf(&quot;请输入要删除的位置&quot;); scanf (&quot;%d&quot;,&amp;i); deleteList(&amp;L,i); break; case 4: printf(&quot;请输入要定位的内容：&quot;); scanf (&quot;%d&quot;,&amp;x); loc = Locate(L,x); if (!loc) printf(&quot;该元素不存在\\n&quot;); else printf(&quot;该元素的序号是：%d \\n&quot;,loc); break; case 5: InitList(&amp;La); InitList(&amp;Lb); printf(&quot;请输入La中的元素个数:&quot;); Input(&amp;La); printf(&quot;请输入Lb中的元素个数:&quot;); Input(&amp;Lb); unio(&amp;La,Lb); break; case 6: InitList(&amp;La); InitList(&amp;Lb); InitList(&amp;Lc); printf(&quot;请输入La中的元素个数:&quot;); Input(&amp;La); printf(&quot;请输入Lb中的元素个数:&quot;); Input(&amp;Lb); mergelist(La,Lb,&amp;Lc); break; case 7: Output(L); break; case 8: conti=0; break; &#125; &#125; return 0;&#125; 三，基于顺序存储结构的图书信息表的创建和输出（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;iomanip&gt;using namespace std;#define OK 1#define ERROR 0#define OVERFLOW -2typedef int Status; //Status 是函数返回值类型，其值是函数结果状态代码。typedef int ElemType; //ElemType 为可定义的数据类型，此设为int类型#define MAXSIZE 100 //顺序表可能达到的最大长度struct Book &#123; string id;//ISBN string name;//书名 double price;//定价&#125;;typedef struct &#123; Book *elem; //存储空间的基地址 int length; //当前长度&#125; SqList;Status InitList_Sq(SqList &amp;L) &#123; //算法2.1 顺序表的初始化 //构造一个空的顺序表L L.elem = new Book[MAXSIZE]; //为顺序表分配一个大小为MAXSIZE的数组空间 if (!L.elem) exit(OVERFLOW); //存储分配失败退出 L.length = 0; //空表长度为0 return OK;&#125;Status GetElem(SqList L, int i, Book &amp;e) &#123;//算法2.2 顺序表的取值 if (i &lt; 1 || i &gt; L.length) return ERROR; //判断i值是否合理，若不合理，返回ERROR e = L.elem[i - 1]; //elem[i-1]单元存储第i个数据元素 return OK;&#125;int LocateElem_Sq(SqList L, double e) &#123; //算法2.3 顺序表的查找 //顺序表的查找 for (int i = 0; i &lt; L.length; i++) if (L.elem[i].price == e) return i + 1;//查找成功，返回序号i+1 return 0;//查找失败，返回0&#125;Status ListInsert_Sq(SqList &amp;L, int i, Book e) &#123; //算法2.4 顺序表的插入 //在顺序表L中第i个位置之前插入新的元素e //i值的合法范围是1&lt;=i&lt;=L.length+1 if ((i &lt; 1) || (i &gt; L.length + 1)) return ERROR; //i值不合法 if (L.length == MAXSIZE) return ERROR; //当前存储空间已满 for (int j = L.length - 1; j &gt;= i - 1; j--) L.elem[j + 1] = L.elem[j]; //插入位置及之后的元素后移 L.elem[i - 1] = e; //将新元素e放入第i个位置 ++L.length; //表长增1 return OK;&#125;Status ListDelete_Sq(SqList &amp;L, int i) &#123; //算法2.5 顺序表的删除 //在顺序表L中删除第i个元素，并用e返回其值 //i值的合法范围是1&lt;=i&lt;=L.length if ((i &lt; 1) || (i &gt; L.length)) return ERROR; //i值不合法 for (int j = i; j &lt;= L.length; j++) L.elem[j - 1] = L.elem[j]; //被删除元素之后的元素前移 --L.length; //表长减1 return OK;&#125;int main() &#123; SqList L; //生成顺序表变量 int i = 0, temp, a, c, choose; double price; Book e; string head_1, head_2, head_3; cout &lt;&lt; &quot;1. 建立\\n&quot;; cout &lt;&lt; &quot;2. 输入\\n&quot;; cout &lt;&lt; &quot;3. 取值\\n&quot;; cout &lt;&lt; &quot;4. 查找\\n&quot;; cout &lt;&lt; &quot;5. 插入\\n&quot;; cout &lt;&lt; &quot;6. 删除\\n&quot;; cout &lt;&lt; &quot;7. 输出\\n&quot;; cout &lt;&lt; &quot;0. 退出\\n\\n&quot;; choose = -1; while (choose != 0) &#123; cout &lt;&lt; &quot;your choose?&quot;; cin &gt;&gt; choose; //输入选项 switch (choose) &#123; case 1://创建顺序表 if (InitList_Sq(L)) cout &lt;&lt; &quot;成功建立顺序表\\n\\n&quot;; else cout &lt;&lt; &quot;顺序表建立失败\\n\\n&quot;; break; case 2: &#123;//顺序表信息输入 i = 0; L.elem = new Book[MAXSIZE]; if (!L.elem) exit(OVERFLOW); L.length = 0; fstream file; file.open(&quot;book.txt&quot;); //文件打开 if (!file) &#123; cout &lt;&lt; &quot;错误！未找到文件！&quot; &lt;&lt; endl; exit(ERROR); &#125; file &gt;&gt; head_1 &gt;&gt; head_2 &gt;&gt; head_3; while (!file.eof()) &#123; file &gt;&gt; L.elem[i].id &gt;&gt; L.elem[i].name &gt;&gt; L.elem[i].price;//从文件中读入一条数据元素的三个数据项 i++; &#125; cout &lt;&lt; &quot;输入 book.txt 信息完毕\\n\\n&quot;; L.length = i; file.close(); //文件关闭 &#125; break; case 3://顺序表的取值 cout &lt;&lt; &quot;请输入一个位置用来取值：\\n&quot;; cin &gt;&gt; i; temp = GetElem(L, i, e); if (temp != 0) &#123; cout &lt;&lt; &quot;查找成功\\n&quot;; cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;本图书的信息是：\\n&quot;; cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; e.id &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(50) &lt;&lt; e.name &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(5) &lt;&lt; e.price &lt;&lt; endl &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;查找失败！位置超出范围\\n\\n&quot;; break; case 4: //顺序表的查找 cout &lt;&lt; &quot;请输入所要查找价格:&quot;; cin &gt;&gt; price; temp = LocateElem_Sq(L, price); if (temp != 0) &#123; cout &lt;&lt; &quot;查找成功\\n&quot;; cout &lt;&lt; &quot;该价格对应的书名为：&quot; &lt;&lt; L.elem[temp - 1].name &lt;&lt; endl &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;查找失败！没有这个价格对应的书籍\\n\\n&quot;; break; case 5: //顺序表的插入 cout &lt;&lt; &quot;请输入插入的位置和书本信息，包括：编号 书名 价格（用空格隔开）:&quot;; cin &gt;&gt; a; cin &gt;&gt; e.id &gt;&gt; e.name &gt;&gt; e.price; //输入a和b，a代表插入的位置，b代表插入的数值（书本信息） if (ListInsert_Sq(L, a, e)) cout &lt;&lt; &quot;插入成功.\\n\\n&quot;; else cout &lt;&lt; &quot;插入失败.\\n\\n&quot;; break; case 6: //顺序表的删除 cout &lt;&lt; &quot;请输入所要删除的书籍的位置:&quot;; cin &gt;&gt; c; if (ListDelete_Sq(L, c)) cout &lt;&lt; &quot;删除成功.\\n\\n&quot;; else cout &lt;&lt; &quot;删除失败.\\n\\n&quot;; break; case 7: //顺序表的输出 cout &lt;&lt; &quot;当前图书系统信息（顺序表）读出:\\n&quot;; for (i = 0; i &lt; L.length; i++) cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; L.elem[i].id &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(50) &lt;&lt; L.elem[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; left &lt;&lt; setw(5) &lt;&lt; L.elem[i].price &lt;&lt; endl; cout &lt;&lt; endl; break; &#125; &#125; return 0;&#125;","path":"2022/04/05/数据与结构之顺序表/","date":"04-05","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C#版基础题","text":"123456789目录1.回文数2.输出100以内能被3整除且个位数为6的所有整数。3.求自然对数e的近似值，要求其误差小于0.00001，近似公式为4.求100—200之间的全部素数，每输出10个素数换行。5.输出* 形成的菱形：6.C#中的get、set方法6.1委托事件7.常见窗体与控件属性 1、编程实现判断一个5位数是不是回文数。5位回文数是指个位数字与万位数字相同，十位数字与千位数字相同，如12321是回文数。 1234567891011121314151617181920212223242526272829303132using System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123; class Program &#123; static void Main(string[] args) &#123; int i = Convert.ToInt32(Console.ReadLine()); int a = 0; int b = i,c; while (b != 0) &#123; c = b % 10; a = a * 10+c; b = b / 10; &#125; if (a == i) &#123; Console.WriteLine(&quot;&#123;0&#125;是回文数&quot;,i); &#125;else Console.WriteLine(&quot;&#123;0&#125;不是回文数&quot;,i); Console.ReadLine(); &#125; &#125;&#125; 2、输出100以内能被3整除且个位数为6的所有整数。 1234567891011121314151617181920using System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication2&#123; class Program &#123; static void Main(string[] args) &#123; int a = 100; for (int i = 1; i &lt;= 100; i++) &#123; if(i%3==0&amp;&amp;i%10==6) Console.WriteLine(i); &#125; Console.ReadLine(); &#125; &#125;&#125; 3、求自然对数e的近似值，要求其误差小于0.00001，近似公式为 123456789101112131415161718192021222324252627282930using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsoleApp2&#123; internal class Program &#123; static void Main(string[] args) &#123; int a; double e = 1; int n = Convert.ToInt32(Console.ReadLine()); //int n =Int32.Parse(Console.ReadLine()); for (int i = 1; i &lt;= n; i++) &#123; a = 1; for(int j = 1; j &lt;= i; j++) &#123; a = a * j; &#125; e = e+1.0/a; &#125; Console.WriteLine(e); Console.ReadLine(); &#125; &#125;&#125; 4、求100—200之间的全部素数，每输出10个素数换行。 1234567891011121314151617181920212223242526272829303132using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsoleApp2&#123; internal class Program &#123; static void Main(string[] args) &#123; int m, k, i, n = 0; for (m = 101; m &lt;= 200; m = m + 2) &#123; k = (int)Math.Sqrt(m); for (i = 2; i &lt;= k; i++) &#123; if (m % i == 0) break; &#125; if (i &gt;= k + 1) &#123; Console.Write(&quot;&#123;0&#125; &quot;, m); n = n + 1; &#125; if (n % 10 == 0) Console.WriteLine(); &#125; Console.WriteLine() ; Console.ReadLine() ; &#125; &#125;&#125; 5、输出* 形成的菱形： 1234567891011121314151617181920212223242526272829303132333435using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsoleApp2&#123; internal class Program &#123; static void Main(string[] args) &#123; int n = Convert.ToInt32(Console.ReadLine()); for(int i = 1; i &lt;= n; i++) &#123; for (int k = 0; k &lt; n - i; k++) Console.Write(&quot; &quot;); for (int l = 0; l &lt; 2*i-1; l++) Console.Write(&quot;*&quot;); Console.WriteLine(); &#125; for (int i = n-1; i &gt;= 0; i--) &#123; for (int k = 0; k &lt; n - i; k++) Console.Write(&quot; &quot;); for (int l = 0; l &lt; 2*i-1; l++) Console.Write(&quot;*&quot;); Console.WriteLine(); &#125; Console.ReadLine(); &#125; &#125;&#125; 6.C#中的get、set方法123456public class student &#123; private int _id; private string _name; &#125; 接着选中上面的代码块，先ctrl+R,再ctrl+E,就会出现下图的界面，点击Apply，就会自动生成set、get方法 123456789101112131415161718192021222324252627public class student &#123; private int _id; private string _name; public int Id &#123; get &#123; return _id; &#125; set &#123; _id = value; &#125; &#125; public string Name &#123; get &#123; return _name; &#125; set &#123; _name = value; &#125; &#125; &#125; 6.1委托事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using ConsoleApp1;using System;using System.Collections.Generic;using System.Text;namespace ConsoleApplication1&#123; public delegate void YunsuanWeituo(double a, double b); public class Computer &#123; public void Yunsuan(double a, double b, YunsuanWeituo Cometure) &#123; Cometure(a, b); &#125; &#125; class Program &#123; private static void Jia(double a, double b) &#123; Console.WriteLine(&quot;&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;, a, b, a + b); &#125; private static void Jian(double a, double b) &#123; Console.WriteLine(&quot;&#123;0&#125;-&#123;1&#125;=&#123;2&#125;&quot;,a,b,a-b); &#125; private static void Cheng(double a, double b) &#123; Console.WriteLine(&quot;&#123;0&#125;*&#123;1&#125;=&#123;2&#125;&quot;, a, b, a * b); &#125; private static void Chu(double a, double b) &#123; Console.WriteLine(&quot;&#123;0&#125;/&#123;1&#125;=&#123;2&#125;&quot;, a, b, a / b); &#125; static void Main(string[] args) &#123; double a=2; double b=3; Computer computer = new Computer(); computer.Yunsuan(a,b, Jia); computer.Yunsuan(a, b, Jian); computer.Yunsuan(a, b, Cheng); computer.Yunsuan(a, b, Chu); Console.ReadLine(); &#125; &#125;&#125; 7.常见窗体与控件属性 button 按钮 check box复选框 ckeck boxlist：复选框列表 radiobutton：单选框控件 lable：标签控件 combo box组合框（下拉列表） picture control图片控制 FileUpload：上传文件控件 timer：计时器 serialport：端口 textbox：文本框 panel：容器 RichTextBox控件RichTextBox是一种既可以输入文本、 又可以编辑文本的文字处理控件， 与TextBox控件相比， RichTextBox控件的文字处理功能更加丰富， 不仅可以设定文字的颜色、 字体， 还具有字符串检索功能。 另外， RichTextBox控件还可以打开、编辑和存储.rtf格式文件、ASCII文本格式文件及Unicode编码格式的文件。 TreeView控件TreeView控件用来显示信息的分级视图，如同Windows里的资源管理器的目录。TreeView控件中的各项信息都有一个与之相关的Node对象。TreeView显示Node对象的分层目录结构，每个Node对象均由一个Label对象和其相关的位图组成。在建立TreeView控件后，可以展开和折叠、显示或隐藏其中的节点。TreeView控件一般用来显示文件和目录结构、文档中的类层次、索引中的层次和其他具有分层目录结构的信息。 1,常用方法下面介绍一些窗体的最常用方法。 Show方法：该方法的作用是让窗体显示出来，其调用格式为：窗体名.Show();其中窗体名是要显示的窗体名称。 Hide方法：该方法的作用是把窗体隐藏出来，其调用格式为：窗体名.Hide();其中窗体名是要隐藏的窗体名称。 Refresh方法：该方法的作用是刷新并重画窗体，其调用格式为：窗体名.Refresh();其中窗体名是要刷新的窗体名称。 Activate方法：该方法的作用是激活窗体并给予它焦点。其调用格式为：窗体名.Activate();其中窗体名是要激活的窗体名称。 Close方法：该方法的作用是关闭窗体。其调用格式为：窗体名.Close();其中窗体名是要关闭的窗体名称。 ShowDialog方法：该方法的作用是将窗体显示为模式对话框。其调用格式为：窗体名.ShowDialog(); 2，常用事件 Load事件：该事件在窗体加载到内存时发生，即在第一次显示窗体前发生。 Activated事件：该事件在窗体激活时发生。 Deactivate事件：该事件在窗体失去焦点成为不活动窗体时发生。 Resize事件：该事件在改变窗体大小时发生。 Paint事件：该事件在重绘窗体时发生。 Click事件：该事件在用户单击窗体时发生。 DoubleClick事件：该事件在用户双击窗体时发生。 Closed事件：该事件在关闭窗体时发生。 3、常用属性 Name属性：用来获取或设置窗体的名称，在应用程序中可通过Name属性来引用窗体。 WindowState属性： 用来获取或设置窗体的窗口状态。 取值有三种： Normal （窗体正常显示）、 Minimized（窗体以最小化形式显示）和 Maximized（窗体以最大化形式显示）。 StartPosition属性：用来获取或设置运行时窗体的起始位置。 Text属性：该属性是一个字符串属性，用来设置或返回在窗口标题栏中显示的文字。 Width属性：用来获取或设置窗体的宽度。 Height属性：用来获取或设置窗体的高度。 Left属性：用来获取或设置窗体的左边缘的x坐标（以像素为单位）。 Top属性：用来获取或设置窗体的上边缘的y坐标（以像素为单位）。 ControlBox属性：用来获取或设置一个值，该值指示在该窗体的标题栏中是否显示控制框。值为true时将显示控制框，值为false时不显示控制框。 MaximizeBox属性：用来获取或设置一个值，该值指示是否在窗体的标题栏中显示最大化按钮。值为 true时显示最大化按钮，值为false时不显示最大化按钮。 MinimizeBox 属性：用来获取或设置一个值，该值指示是否在窗体的标题栏中显示最小化按钮。值为 true时显示最小化按钮，值为false时不显示最小化按钮。 AcceptButton 属性：该属性用来获取或设置一个值，该值是一个按钮的名称，当按 Enter 键时就相当于单击了窗体上的该按钮。 CancelButton 属性：该属性用来获取或设置一个值，该值是一个按钮的名称，当按 Esc 键时就相当于单击了窗体上的该按钮。 Modal 属性：该属性用来设置窗体是否为有模式显示窗体。如果有模式地显示该窗体，该属性值为true；否则为 false。当有模式地显示窗体时，只能对模式窗体上的对象进行输入。必须隐藏或关闭模式窗体（通常是响应某个用户操作），然后才能对另一窗体进行输入。有模式显示的窗体通常用做应用程序中的对话框。 ActiveControl属性：用来获取或设置容器控件中的活动控件。窗体也是一种容器控件。 ActiveMdiChild属性：用来获取多文档界面（MDI）的当前活动子窗口。 AutoScroll 属性：用来获取或设置一个值，该值指示窗体是否实现自动滚动。如果此属性值设置为true，则当任何控件位于窗体工作区之外时，会在该窗体上显示滚动条。另外，当自动滚动打开时，窗体的工作区自动滚动，以使具有输入焦点的控件可见。 BackColor属性：用来获取或设置窗体的背景色。 BackgroundImage属性：用来获取或设置窗体的背景图像。 Enabled 属性：用来获取或设置一个值，该值指示控件是否可以对用户交互作出响应。如果控件可以对用户交互作出响应，则为 true；否则为false。默认值为true。 Font属性：用来获取或设置控件显示的文本的字体。 ForeColor属性：用来获取或设置控件的前景色。 IsMdiChild属性：获取一个值，该值指示该窗体是否为多文档界面（MDI）子窗体。值为 true时，是子窗体，值为false时，不是子窗体。 IsMdiContainer 属性：获取或设置一个值，该值指示窗体是否为多文档界面（MDI）中的子窗体的容器。值为true时，是子窗体的容器，值为false时，不是子窗体的容器。 KeyPreview属性：用来获取或设置一个值，该值指示在将按键事件传递到具有焦点的控件前，窗体是否将接收该事件。值为true时，窗体将接收按键事件，值为false时，窗体不接收按键事件。 MdiChildren属性：数组属性。数组中的每个元素表示以此窗体作为父级的多文档界面（MDI）子窗体。 MdiParent属性：用来获取或设置此窗体的当前多文档界面（MDI）父窗体。 ShowInTaskbar属性：用来获取或设置一个值，该值指示是否在Windows任务栏中显示窗体。 Visible属性：用于获取或设置一个值，该值指示是否显示该窗体或控件。值为true 时显示窗体或控件，为 false时不显示。 Capture属性：如果该属性值为true，则鼠标就会被限定只由此控件响应，不管鼠标是否在此控件的范围内。链接：https://www.jianshu.com/p/38854353f304","path":"2022/04/05/C-版基础题-1/","date":"04-05","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java版基础题","text":"123456目录1.输入输出2.冒泡排序3.排序（快排）4.判闰年（面向对象）5.知道圆心半径，求面积（面向对象加继承） 1.输入输出 123456789101112131415161718192021222324252627public class Dome &#123; public static void main(String[] args) &#123; //输出 System.out.println(&quot;请输入一个字符:&quot;); //输入 Scanner scan=new Scanner(System.in); String str=scan.nextLine(); //输出字符串 System.out.println(str); &#125;&#125;/*scan.nextInt();scan.nextFloat();scan.nextDouble();next() 与 nextLine() 区别 next(): 1、一定要读取到有效字符后才可以结束输入。 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine()： 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 2、可以获得空白。*/ 2.冒泡排序 12345678910111213141516171819package com.homework;public class Maopao &#123; public static void main(String[] args) &#123; int[] aa= &#123;12,34,1,-5,9,100,55,0&#125;; int bb,t; for (int i=0;i&lt;aa.length-1;i++) for (int j=i+1;j&lt;aa.length;j++)&#123; if (aa[i]&gt;aa[j])&#123; t=aa[j]; aa[j]=aa[i]; aa[i]=t; &#125; &#125; for (int ss:aa) System.out.println(ss); &#125;&#125; 3.排序（快排） 123456789101112131415161718192021222324252627282930313233343536package com.homework;public class Kuaipai &#123; public static void main(String[] args) &#123; int[] aa= &#123;12,34,1,-5,9,100,55,0&#125;; kuaipai(aa,0,aa.length-1); for (int i = 0; i &lt; aa.length; i++) &#123; System.out.println(aa[i]); &#125; &#125; public static void kuaipai(int[] arry, int low, int hight)&#123; if(low&gt;hight) return; int temp,bb; temp=arry[low]; int i=low; int j=hight; while (i&lt;j)&#123; while (temp&lt;=arry[j]&amp;&amp;i&lt;j) j--; while (temp&gt;=arry[i]&amp;&amp;i&lt;j) i++; if (i&lt;j)&#123; bb=arry[j]; arry[j]=arry[i]; arry[i]=bb; &#125; &#125; arry[low]=arry[i]; arry[i]=temp; kuaipai(arry,low,j-1); kuaipai(arry,j+1,hight); &#125;&#125; 4.判闰年 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//日期类package com.homework;import java.text.ParseException;import java.text.SimpleDateFormat;public class Date &#123; private int year; private int month; private int day; public Date(int year,int month,int day)&#123; this.year=year; this.month=month; this.day=day;&#125; public String getDate()&#123; return year+&quot;/&quot;+month+&quot;/&quot;+day; &#125; public int getYear() &#123; return year; &#125; public int getMonth() &#123; return month; &#125; public int getDay() &#123; return day; &#125; public void setYear(int year) &#123; this.year = year; &#125; public void setMonth(int month) &#123; this.month = month; &#125; public void setDay(int day) &#123; this.day = day; &#125; public String isValidDate(String str) &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;); String aa=&quot;字符为有效字符&quot;; try &#123;format.setLenient(false); format.parse(str); &#125; catch (ParseException e) &#123; month=1; day=1; aa=&quot;非有效字符已重置为1月1日&quot;;&#125; return aa;&#125;&#125;//main实现package com.homework;import java.util.GregorianCalendar;public class Amain &#123; public static void main(String[] args) &#123; //实例化并初始化 Date date=new Date(2008,5,15); //得到日期 String str=date.getDate(); //判断是否为有效日期 System.out.println(date.isValidDate(str)); //打印日期 System.out.println(date.getDate()); //判断闰年 int year = date.getYear(); if(year%4==0&amp;&amp;year%100!=0||year%400==0) System.out.println(&quot;是闰年&quot;); else System.out.println(&quot;不是闰年&quot;); /* GregorianCalendar gcalendar = new GregorianCalendar(); if(gcalendar.isLeapYear(date.getYear())) System.out.println(&quot;是闰年&quot;); else System.out.println(&quot;不是闰年&quot;);*/ &#125;&#125; 5.知道圆心半径，求面积 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//圆心类package com.homework;class Point&#123; private int x; private int y; public static int count=0; public Point(int x,int y) &#123; this.x=x; this.y=y; count++; &#125; public int getX() &#123; return x; &#125; public int getY() &#123; return y; &#125; public String getXY() &#123; return &quot;(&quot;+getX()+&quot;,&quot;+getY()+&quot;)&quot;; &#125;&#125;//圆类package com.homework;public class Circle extends Point&#123; private int r; static double PI=3.14159265; public Circle(int x, int y,int r) &#123; super(x,y); this.r=r; &#125; public int getR() &#123; return r; &#125; public void setR(int r) &#123; this.r = r; &#125; public double getD() &#123; return 2*r; &#125; public double getL() &#123; return 2*r*PI; &#125; public double getS() &#123; return PI*r*r; &#125;&#125;//实现类package com.homework;public class Bmain &#123; public static void main(String[] args)&#123; Circle circle01=new Circle(3,4,5); Circle circle02=new Circle(3,5,6); double d=circle01.getD(); double l=circle01.getL(); double s=circle02.getS(); System.out.println(&quot;坐标:&quot;+circle01.getXY()); System.out.println(&quot;坐标点数量:&quot;+circle02.count); System.out.println(&quot;直径为:&quot;+d); System.out.println(&quot;周长为:&quot;+l); System.out.println(&quot;面积为:&quot;+s); &#125; &#125;","path":"2022/04/05/Java版基础题/","date":"04-05","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C++版基础题","text":"12345678910111213141516目录1.用C++实现日历功能2.用C++实现计算器功能3.编写C++程序解决百钱问题4.C++程序实现函数重载5.引用实现排序输出6.定义一个Dog类，包含age, weight等数据成员7.计算矩形面积8.计算圆的周长和面积9.对象数组求解问题10. 对象指针及其使用11.This指针及其用法12.静态成员的用法13.游泳池改造预算14.类的组合应用15.友元函数的应用 1.用C++实现日历功能 1234567891011121314151617181920#include &quot;iostream&quot;using namespace std;class date&#123;int year,month,day;public:void setdate(int yy,int mm,int dd)&#123;year=yy;month=mm;day=dd;&#125;void showdate()&#123;cout&lt;&lt;year&lt;&lt;&#x27;-&#x27;&lt;&lt;month&lt;&lt;&#x27;-&#x27;&lt;&lt;day&lt;&lt;endl;&#125;&#125;;int main()&#123; int a,b,c; date dd; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; dd.setdate(a,b,c); dd.showdate(); return 0;&#125; 2.用C++实现计算器功能 12345678910111213141516171819202122232425262728293031323334353637#include &quot;iostream&quot;using namespace std;class caculater&#123;int a,b,d;char c,zz;public:void setcaculater(int yy,char mm,int dd)&#123;a=yy;c=mm;b=dd;&#125;void computer(int zz)&#123; c=zz; if(c==&#x27;+&#x27;) d=a+b; else if(c==&#x27;-&#x27;) d=a-b; else if(c==&#x27;*&#x27;) d=a*b; else if(c==&#x27;/&#x27;) d=a/b;&#125;void showcaculater()&#123; cout&lt;&lt;a&lt;&lt;c&lt;&lt;b&lt;&lt;&quot;=&quot;&lt;&lt;d&lt;&lt;endl;&#125;&#125;;int main()&#123; int a,c; char b; caculater dd; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; dd.setcaculater(a,b,c); dd.computer(b); dd.showcaculater(); return 0;&#125; 3.编写C++程序解决百钱问题 1234567891011121314151617181920#include &quot;iostream&quot;using namespace std;int main() &#123; int count=0,n,m,a=1,b=2,c=5,temp; cin&gt;&gt;n; m=n*100; for(int i=0; i&lt;=m/b;++i) &#123; for (int j=0;j&lt;=m/c;++j) &#123; temp=m-(b*i+c*j); if(temp&gt;=0&amp;&amp;temp%a==0) &#123; ++count; &#125; &#125; &#125; cout &lt;&lt; &quot;将&quot;&lt;&lt;n&lt;&lt;&quot;元人民币兑换成1、2、5分的硬币，共有&quot;&lt;&lt;count&lt;&lt;&quot;种换法。&quot; ; return 0;&#125; 4.C++程序实现函数重载 编写一个C++风格的程序，建立一个被称为sroot()的函数，返回其参数的二次方根。重载sroot()3次，让它返回整数、长整数与双精度数的二次方根（计算二次方根时，可以使用标准库函数sqrt()）。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int sroot(int);long sroot(long);double sroot(double);int main()&#123; int i,x; long l,y; double d,z; cin&gt;&gt;i&gt;&gt;l&gt;&gt;d; x=sroot(i); y=sroot(l); z=sroot(d); cout&lt;&lt;x&lt;&lt;&#x27;,&#x27;&lt;&lt;y&lt;&lt;&#x27;,&#x27;&lt;&lt;z&lt;&lt;endl; return 0;&#125;int sroot(int n) &#123; return sqrt(n);&#125;long sroot(long n) &#123; return sqrt(n);&#125;double sroot(double n) &#123; return sqrt(n);&#125; 5.引用实现排序输出 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;void swap(int &amp;x,int &amp;y);int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; swap(a,b); cout&lt;&lt;a&lt;&lt;&#x27;,&#x27;&lt;&lt;b&lt;&lt;endl; return 0;&#125;void swap(int &amp;x,int &amp;y)&#123; int t; if(x&gt;y) &#123; t=x; x=y; y=t; &#125;&#125; 6.定义一个Dog类，包含age, weight等数据成员，以及对这些数据成员操作的方法。实现并测试这个类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;class Dog&#123; int Age,Weight; public: Dog(int a,int b) &#123; Age=a,Weight=b; &#125; int getAge() &#123; return Age; &#125; int getWeight() &#123; return Weight; &#125; void setAge(int x) &#123; Age=x; &#125; void setWeight(int y) &#123; Weight=y; &#125;&#125;;int main()&#123; Dog Jack(2,10); cout&lt;&lt;&quot;Jack is a Dog who is &quot;; cout&lt;&lt;Jack.getAge()&lt;&lt;&quot; years old and &quot;&lt;&lt;Jack.getWeight()&lt;&lt;&quot; pounds weight&quot;&lt;&lt;endl; Jack.setAge(7); Jack.setWeight(20); cout&lt;&lt;&quot;Now Jack is &quot;; cout&lt;&lt;Jack.getAge()&lt;&lt;&quot; years old and &quot;&lt;&lt;Jack.getWeight()&lt;&lt;&quot; pounds weight.&quot;&lt;&lt;endl; return 0;&#125; 7.计算矩形面积 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;class Rectangle&#123; int x1,y1,x2,y2; public: Rectangle(int a,int b,int c,int d) &#123; x1=a,y1=b,x2=c,y2=d; &#125; int getArea() &#123; return (x1-x2)*(y2-y1); &#125;&#125;;int main()&#123; Rectangle rect(100,80,200,40); cout&lt;&lt;&quot;Area: &quot;&lt;&lt;rect.getArea()&lt;&lt;endl; return 0;&#125; 8.计算圆的周长和面积 定义一个Circle类，有数据成员radius（半径）、成员函数getCircumference()计算圆的周长，成员函数getArea()计算圆的面积。在主函数中定义圆对象，通过调用成员函数计算圆的周长和面积。提示：圆周率取值3.14 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;class Circle&#123; float radius; public: Circle (float a) &#123; radius=a; &#125; float getCircumference() &#123; return 2*3.14*radius; &#125; float getArea() &#123; return 3.14*radius*radius; &#125;&#125;;int main()&#123; float radius; cin&gt;&gt;radius; Circle c(radius); cout&lt;&lt;&quot;半径为&quot;&lt;&lt;radius&lt;&lt;&quot;的圆的周长为：&quot;&lt;&lt;c.getCircumference()&lt;&lt;&quot;,面积为：&quot;&lt;&lt;c.getArea()&lt;&lt;endl; return 0;&#125; 9.对象数组求解问题 构建一个类book，其中含有两个私有数据成员qu和price，将qu初始化为1~5，将price初始化为qu的10倍，建立一个有5个元素的数组对象。显示每个对象数组元素的qu*price值。 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;class book&#123; int qu,price; public: book(int a) &#123; qu=a; price=10*qu; &#125; void print() &#123; cout&lt;&lt;&quot;qu*price=&quot;&lt;&lt;qu*price&lt;&lt;endl; &#125;&#125;;int main() &#123; book b[5]=&#123;1,2,3,4,5&#125;; for(int i=0;i&lt;5;i++) b[i].print(); return 0; &#125; 对象指针及其使用 构建一个类book，其中含有两个私有数据成员qu和price，将price初始化为qu的10倍，建立一个有5个元素的数组对象，将qu初始化为6~10。要求通过对象指针访问对象数组，按相反的顺序显示每个对象数组元素的qu*price值。 123456789101112131415161718192021222324252627#include &lt;iostream&gt; using namespace std; class book &#123; int qu,price;public: book(int i) &#123; qu=i; price=10*i; &#125;void print()&#123; cout&lt;&lt;&quot;qu*price=&quot;&lt;&lt;qu*price&lt;&lt;endl;&#125;&#125;; int main()&#123; int x=5; book b[5]=&#123;6,7,8,9,10&#125;; book *p=&amp;b[4]; while(x!=0) &#123; (*p).print(); p--; x--; &#125;&#125; 11.This指针及其用法 构建一个类Stock，含字符数组stockcode[]及整型数据成员quan、双精度型数据成员price。 构造函数含3个参数：字符数组na[]及q、p。当定义Stock的类对象时，将对象的第1个字符串参数赋值给数据成员stockcode，第2个和第3个参数分别赋给quan、price。未设置第2和第3个参数时，quan的值为1000，price的值为8.98。 成员函数print没有形参，需使用this指针，显示对象数据成员的内容。假设类Stock第1个对象的三个参数分别为：”600001”，3000和5.67，第2个对象的第1个数据成员的值为”600002”，第2个和第3个数据成员的值取默认值。 要求编写程序分别显示这两个对象数据成员的值。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class stock&#123; int quan; string stockcode; double price; public: stock(string na,int q=1000,double p=8.98) &#123; stockcode=na; quan=q; price=p; &#125; void print() &#123; cout&lt;&lt;stockcode&lt;&lt;endl&lt;&lt;quan&lt;&lt;endl&lt;&lt;price&lt;&lt;endl; &#125;&#125;;int main()&#123; stock st1(&quot;600001&quot;,3000,5.67); st1.print(); stock st2(&quot;600002&quot;); st2.print(); return 0;&#125; 静态成员的用法 编写一个程序，已有若干学生的数据，包括学号、姓名、成绩，要求输入这些学生的数据并计算出学生人数和平均成绩（要求将学生人数和总成绩用静态数据成员表示）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class student&#123; string num; string name; int score; static double sum; static int count1; static double aver; public: student(string num1,string name1,int score1)&#123; num=num1; name=name1; score=score1; count1++; sum+=score1; aver=sum/count1;&#125; void print()&#123; cout&lt;&lt;num&lt;&lt;&quot; &quot;&lt;&lt;name&lt;&lt;&quot; &quot;&lt;&lt;score&lt;&lt;endl;&#125; static int get_count()&#123; return count1;&#125; static double get_avg()&#123; return aver;&#125;&#125;; double student::sum=0.0; int student::count1=0; double student::aver=0.0; int main()&#123; student s1(&quot;201601&quot;,&quot;john&quot;,85),s2(&quot;201602&quot;,&quot;mike&quot;,90),s3(&quot;201603&quot;,&quot;june&quot;,95); s1.print(); s2.print(); s3.print(); cout&lt;&lt;&quot;共有&quot;&lt;&lt;student::get_count()&lt;&lt;&quot;位学生，平均成绩为：&quot;&lt;&lt;student::get_avg()&lt;&lt;endl; return 0;&#125; 13.游泳池改造预算 一个圆形游泳池如图所示，现在需要在其周围建一个圆形过道，并在其四周围上栅栏。栅栏价格为35元&#x2F;米，过道造价为20元&#x2F;平方米。过道宽度为3米，游泳池半径由键盘输入。要求编程计算并输出过道和栅栏的造价。 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int a,b; float c=3.14,x,y; cin&gt;&gt;a; x=(float)((a+3)*(a+3)*c-a*a*c)*20; y=2*c*(a+3)*35; cout&lt;&lt;&quot;Enter the radius of the pool:&quot;&lt;&lt;endl&lt;&lt;&quot;Fencing Cost is $&quot;&lt;&lt;y&lt;&lt;endl&lt;&lt;&quot;Concrete Cost is $&quot;&lt;&lt;x; return 0;&#125; 14.类的组合应用 定义一个线段类Line，实现根据起点坐标和终点坐标计算线段的长度。坐标点又包含X坐标值和Y坐标值，因此定义坐标点类Point，其对象作为线段类的数据成员。试编程实现根据坐标点计算线段长度的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;class Point&#123; int x,y;public: Point(int a=0,int b=0) &#123; x=a; y=b; &#125; Point(Point &amp;p) &#123; x=p.x; y=p.y; &#125; int getX() &#123; return x; &#125; int getY() &#123; return y; &#125;&#125;;class Line&#123; int a,b,c,n;public: Line(Point pp1,Point pp2) &#123; a=pp1.getX(); b=pp1.getY(); c=pp2.getX(); n=pp2.getY(); &#125; int getLen() &#123; return sqrt((c-a)*(c-a)+(n-b)*(n-b)); &#125;&#125;;int main()&#123; Point p1(1,1),p2(4,5); Line line1(p1,p2); Line line2(line1); cout&lt;&lt;&quot;The length of the line1 is:&quot;&lt;&lt;line1.getLen()&lt;&lt;endl; cout&lt;&lt;&quot;The length of the line2 is:&quot;&lt;&lt;line2.getLen()&lt;&lt;endl; return 0;&#125; 15.友元函数的应用 定义Boat与Car两个类，二者都有weight属性，定义二者的一个友元函数getTotalWeight()，计算二者的重量和。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;class Car;class Boat&#123;public: int x; Boat(int a) &#123; x=a; &#125; friend int getTotalWeight(Boat &amp;n,Car &amp;m);&#125;;class Car&#123;public: int y; Car(int b) &#123; y=b; &#125; friend int getTotalWeight(Boat &amp;n,Car &amp;m);&#125;;int getTotalWeight(Car &amp;n,Boat &amp;m)&#123; return (n.y+m.x);&#125;int main()&#123; Car c(4); Boat b(5); cout&lt;&lt;getTotalWeight(c,b)&lt;&lt;endl; return 0;&#125;","path":"2022/04/05/C-版基础题/","date":"04-05","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C语言基础题","text":"123456789101112131415161718192021222324252627282930目录1.阶乘2.最大数3.平行四边形4.素数5.最大公约数6.[m,n]区间的所有素数7.n行等边三角形8.回文数9.鸡兔同笼10.水仙花数11.求所有小于等于n(n&lt;100)的与7无关的正整数的平方和12.判断字符13.数字的顺序进行排列14.谁能出线15.n个数的平均值16.n个数的平均值17.字符串相连18.字符串回文函数19.四舍五入（保留2位小数）20.求两个整数的最大公约数和最小公倍数21.求出数组中所有素数之和22.将a的十位和个位依次存放在c数的十位和千位上，b的十位和个位依次存放在c数的个位和百位上结构体23.顺序输出总分最低的学生信息24.分别输出工资变化之前和之后的所有职工的信息25.按学号顺序排序输出后在输入要统计的院系名称26.将该学生的各科成绩都乘以一个系数a27.把指定分数范围内的学生数据放在h所指的数组中，分数范围内的学生人数由函数值返回 1.计算一个整数N的阶乘 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n,sum=1,i=1; scanf(&quot;%d&quot;,&amp;n); for(n;n&lt;=12&amp;&amp;n&gt;0;n--) sum=sum*n; printf(&quot;%d&quot;,sum); return 0;&#125; 2.最大数 输入若干个整数,以-1标记输入结束。输出其中的最大数 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int a,b; scanf(&quot;%d&quot;,&amp;a); b=a; while(a != -1) &#123; scanf(&quot;%d&quot;,&amp;a); if(a&gt;b&amp;&amp;a!=-1) b=a; &#125; printf(&quot;%d\\n&quot;,b);&#125; 3.平行四边形 输入图形的每行有n个星号，高 n ，输出对应的图形 . 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i,j,a,b; scanf(&quot;%d&quot;,&amp;a); for(i=0;i&lt;a;i++) &#123; for(j=0;j&lt;i;j++) &#123; printf(&quot; &quot;); &#125; for(b=0;b&lt;a;b++) &#123; printf(&quot;*&quot;); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 4.求素数。输入一个数n，判断其是否为素数。 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n,i; scanf(&quot;%d&quot;,&amp;n); for(i=2;i&lt;n;i++) &#123; if(n%i==0) break; &#125; if(n==i) printf(&quot;y\\n&quot;); else printf(&quot;n\\n&quot;); return 0;&#125; 5.【循环】最大公约数 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int m,n,a,b,c; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); if(m&lt;n) &#123; c=m; m=n; n=c; &#125; b=m*n; a=m%n; while(a!=0) &#123; m=n; n=a; a=m%n; &#125; printf(&quot;the greatest common divisor is %d\\n&quot;,n); printf(&quot;the least common multiple is %d\\n&quot;,b/n); return 0;&#125; 6.输入两个正整数m和n，求出[m,n]区间的所有素数 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n,m,i,j,flag=1; scanf(&quot;%d %d&quot;,&amp;m,&amp;n); for(i=m;i&lt;=n;i++) &#123; flag=1; for(j=2;j&lt;i;j++) &#123; if(i%j==0) &#123; flag=0; break; &#125; &#125; if(flag==1) printf(&quot;%d &quot;,i); &#125; return 0;&#125; 7.输入整数n，打印出n行等边三角形 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int n,i,j,k; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) &#123; for(k=1;k&lt;=n-i;k++) printf(&quot; &quot;); for(j=1;j&lt;=2*i-1;j++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); &#125; return 0;&#125; 8.回文数 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n,a,k=0,m; scanf(&quot;%d&quot;,&amp;n); m=n; while(n!=0) &#123; a=n%10; k=k*10+a; n=n/10; &#125; if(m==k) printf(&quot;Yes&quot;); else printf(&quot;No&quot;); return 0;&#125; 9.鸡和兔关在一个笼子里，鸡有2只脚，兔有4只脚，没有例外。已知现在可以看到笼子里m个头和n只脚，求鸡和兔子各有多少只？ 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int n,m,c,r,flag; scanf(&quot;%d %d&quot;,&amp;m,&amp;n); for(c=0;c&lt;=m;c++) &#123; for(r=0;r&lt;=m;r++) &#123; if(r+c==m&amp;&amp;c*2+r*4==n) printf(&quot;%d %d&quot;,c,r); &#125; &#125; return 0;&#125; 10.输出所有的水仙花数。所谓的水仙花数是指一个3位数，其各位数字立方和等于该数本身。例如153是一水仙花数， 如153&#x3D;13+53+33 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n,a,b,c; for(n=100;n&lt;=999;n++) &#123; a=n/100; b=n/10%10; c=n%10; if(a*a*a+b*b*b+c*c*c==n) &#123; printf(&quot;%d\\n&quot;,n); &#125; &#125; return 0;&#125; 11.一个正整数，如果它能被7整除，或者它的十进制表示法中某一位上的数字为7，则称其为与7相关的数。求所有小于等于n(n&lt;100)的与7无关的正整数的平方和。 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n,i,sum=0,j; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) &#123; if(i/10!=7&amp;&amp;i%10!=7&amp;&amp;i%7!=0) &#123; sum=sum+i*i; &#125; &#125; printf(&quot;%d\\n&quot;,sum); return 0;&#125; 12.编写程序，从键盘输入一个字符，输出字符所属的类型：大写字母时输出capital letters， 小写字母时输出small letters，数字是输出figures,其他字符时输出 others。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char a; scanf(&quot;%c&quot;,&amp;a); if(a&gt;=&#x27;A&#x27;&amp;&amp;a&lt;=&#x27;Z&#x27;) printf(&quot;capital letters&quot;); else if(a&gt;=&#x27;a&#x27;&amp;&amp;a&lt;=&#x27;z&#x27;) printf(&quot;small letters&quot;); else if(a&gt;=&#x27;0&#x27;&amp;&amp;a&lt;=&#x27;9&#x27;) printf(&quot;figures&quot;); else printf(&quot;others&quot;);&#125; 13.将十个数进行从大到小的顺序进行排列 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int a[10],b,i,t; for(i=0;i&lt;10;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i=0;i&lt;9;i++) for(b=i+1;b&lt;10;b++) if(a[b]&gt;a[i]) &#123; t=a[b]; a[b]=a[i]; a[i]=t; &#125; for(i=0;i&lt;10;i++) printf(&quot;%d &quot;,a[i]);&#125; 14.电视台举办“超级学生”才艺大赛，由于报名人数狂多，所以要先进行分组预赛。按规定，每10名学生为一个预赛小组，评委打出分数（0~100分），各小组第一名可以进入下一轮；如果有多名学生得分相同都是第一名，则可同时进入下一轮。 输入描述 按顺序给出一个小组10个人的最后得分（int）。 输出描述 能够出线的学生序号（0~9），多名学生时，每行输出一个序号 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int a[10],b,c=0,i,m; for(i=0;i&lt;10;i++) &#123; scanf(&quot;%d\\n&quot;,&amp;a[i]); &#125; for(i=0;i&lt;10;i++) &#123; if(a[i]&gt;=c) c=a[i]; &#125; m=c; for(b=0;b&lt;10;b++) &#123; if(a[b]==m) printf(&quot;%d\\n&quot;,b); &#125;&#125; 16.题目描述 输入n个数，求n个数的平均值（5&lt;&#x3D;n&lt;&#x3D;10） 输入描述 第一行输入n的值，第二行输入n个数 输出描述 分两行输出平均值和低于平均值的个数 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; int n,i,t=0,b=0; float y; scanf(&quot;%d&quot;,&amp;n); int a[n]; for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i=0;i&lt;n;i++) &#123; t=t+a[i]; &#125; y=(float)t/n; for(i=0;i&lt;n;i++) if(a[i]&lt;y) b=b+1; printf(&quot;average=%.2f\\n&quot;,y); printf(&quot;%d&quot;,b);&#125; 17.将两个字符串按照要求进行首尾相连，即：将一个字符串链接到另一个字符串尾部，并输出。 输入描述 输入两行字符串 输出描述 输出一行连接后的字符串 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i,m,n; char a[100],b[100],c[100]; gets(a); gets(b); n=strlen(a); m=strlen(b); for(i=0;i&lt;n;i++) printf(&quot;%c&quot;,a[i]); for(i=0;i&lt;m;i++) printf(&quot;%c&quot;,b[i]);&#125; 18.题目描述 编程，输入一个字符串，输出该字符串是否回文。 关于输入输入为一行字符串（字符串中没有空白字符，字符串长度不超过100）。 关于输出如果字符串是回文，输出yes；否则，输出no。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char a[100]; int n,i,flag; gets(a); n=strlen(a); for(i=0;i&lt;=n/2;i++) &#123; flag=0; if(a[i]!=a[n-i-1]) &#123; flag=1; break; &#125; &#125; if(flag=0) printf(&quot;yes&quot;); else printf(&quot;no&quot;); return 0;&#125; 19.请编一个函数Fun，函数的功能是使实型数保留2位小数，并对第3位进行四舍五入（规定实型数为正数）例如：实型数为1234.567，则函数返回1234.570000 实型数为1234.564，则函数返回1234.560000 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;math.h&gt;double fun(double x)&#123; double y,m; y=(int)(x*100+0.5); m=y/100; return m;&#125;int main() &#123; double a; scanf ( &quot;%lf&quot;, &amp;a ); printf ( &quot;%f\\n&quot;, fun ( a ) ); return 0;&#125; 20.写两个函数，分别求两个整数的最大公约数和最小公倍数。用主函数分别调用这两个函数，并输出结果。 输入描述 两个用空格隔开的正整数，保证二者的值均不超过10000。 输出描述 输出两个正整数的最大公约数和最小公倍数，用空格隔开。请注意行尾输出换行。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int max(int a,int b);int min(int a,int b);int main()&#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); printf(&quot;%d %d\\n&quot;,max(a,b),min(a,b));&#125;int max(int x,int y)&#123; int m; m=x%y; while(m!=0) &#123; x=y; y=m; m=x%y; &#125; return y;&#125;int min(int x,int y)&#123; int m; m=x*y/max(x,y); return m;&#125; 21.请编一个函数 Fun，函数的功能是分别求出数组中所有素数之和。形参 n 给了数组中数据的个数：利用指针 prime 返回素数之和。例如：数组中的值依次为： 5， 8 ， 76 ， 3 ， 11 ， 6 ；则利用指针 prime 返回素数之和 19。 123456789101112注意：本题只需提交Fun函数即可，还可以编写一个判断是否素数的函数，在Fun()里调用****int main()&#123; int a[N],i,n,prime; scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); Fun(a,n,&amp;prime); printf(&quot;The sum of prime numbers:%d\\n&quot;,prime); return 0;&#125; 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;void Fun(int a[],int n,int *x)&#123; int i,j,c=0; *x=0; for(i=0;i&lt;n;i++) &#123; c=0; for(j=2;j&lt;a[i];j++) if(a[i]%j==0) &#123; c=1;break; &#125; if(c==0) *x+=a[i]; &#125;&#125;int main()&#123; int a[999],i,n,prime; scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); Fun(a,n,&amp;prime); printf(&quot;The sum of prime numbers:%d\\n&quot;,prime); return 0;&#125; 22.编写函数Fun，其功能是将两个两位数的正整数a、b合并形成一个整数放在c中。合并的方式是：将a的十位和个位依次存放在c数的十位和千位上，b的十位和个位依次存放在c数的个位和百位上。 输入描述 仅一行。两个整数a和b，以逗号分隔。 输出描述 仅一行。一个整数，表示合并后的数据c。 样例输入 145,12 样例输出 15241 12345678910111213#include &lt;stdio.h&gt;void Fun(int a,int b,int *x)&#123; *x=a%10*1000+b%10*100+a/10*10+b/10;&#125;int main()&#123; int a,b,c; scanf(&quot;%d,%d&quot;,&amp;a,&amp;b); Fun(a,b,&amp;c); printf(&quot;%d\\n&quot;,c); return 0;&#125; 23.上小学的小红刚考完期末考试，拿到成绩的她迫切想知道自己的成绩如何，你能帮帮她吗？ 输入描述 有多行。第1行是一个整数n（1≤n≤100）表示有n位同学。接下来有n行，每行表示一位同学的相关信息，依次是姓名（姓名中不包含空格，长度不超过20）、语文成绩、数学成绩、英语成绩，三门课程的成绩均为整数（0≤成绩≤100）。 输出描述 仅1行，按照学生姓名、语文、数学、英语成绩和三门课的总分的顺序输出总分最低的学生信息（数据能确保所有学生的总分成绩不会出现相同的情况）。 样例输入 12343Xiaoli 65 45 87Xiaohong 78 89 93Xiaozhang 87 67 54 样例输出 1Xiaoli 65 45 87 197 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct student&#123; char name[30]; int a; int b; int c; int d;&#125;;struct student stu[50];void main()&#123; int n,x,i,t; scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;n;i++) &#123; scanf(&quot;%s%d%d%d&quot;,stu[i].name,&amp;stu[i].a,&amp;stu[i].b,&amp;stu[i].c); stu[i].d=stu[i].a+stu[i].b+stu[i].c; &#125; x=stu[0].d; for(i=0;i&lt;n;i++) &#123; if(stu[i].d&lt;=x) x=stu[i].d; &#125; for(i=0;i&lt;n;i++) if(stu[i].d==x) t=i; printf(&quot;%s %d %d %d %d&quot;,stu[t].name,stu[t].a,stu[t].b,stu[t].c,stu[t].d);&#125; 24.题目描述 编写程序，定义一个存放职工信息的结构体类型，职工信息包括职工姓名、工作年限、工资总额。初始化5名职工的信息，对工作年限超过30年的职工每人加100元工资，要求分别输出工资变化之前和之后的所有职工的信息。 输入描述 输入5个员工的职工姓名、工作年限、工资总额 输出描述 输出两部分，第一部分输出工资变化之前所有职工的信息，第二部分输出工资变化之后的所有职工的信息 样例输入 12345zhang1 5 1000 zhang2 10 2000 zhang3 20 3000 zhang4 40 4000 zhang5 50 5000 样例输出 1234567891011121314原始工资姓名 年限 工资zhang1 5 1000zhang2 10 2000zhang3 20 3000zhang4 40 4000zhang5 50 5000加薪后工资姓名 年限 工资zhang1 5 1000zhang2 10 2000zhang3 20 3000zhang4 40 4100zhang5 50 5100 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct student&#123; char name[30]; int years; int sum;&#125;;struct student stu[5];int main()&#123; int i; for(i=0;i&lt;5;i++) &#123; scanf(&quot;%s%d%d&quot;,stu[i].name,&amp;stu[i].years,&amp;stu[i].sum); &#125; printf(&quot;原始工资\\n&quot;); printf(&quot;姓名 年限 工资\\n&quot;); for(i=0;i&lt;5;i++) &#123; printf(&quot;%s %d %d\\n&quot;,stu[i].name,stu[i].years,stu[i].sum); &#125; for(i=0;i&lt;5;i++) &#123; if(stu[i].years&gt;=30) stu[i].sum=stu[i].sum+100; &#125; printf(&quot;加薪后工资\\n&quot;); printf(&quot;姓名 年限 工资\\n&quot;); for(i=0;i&lt;5;i++) &#123; printf(&quot;%s %d %d\\n&quot;,stu[i].name,stu[i].years,stu[i].sum); &#125; return 0;&#125; 25.输入描述 先输入5名学生的信息，按学号顺序排序输出后在输入要统计的院系名称 输出描述 先按学号从小到大的顺序输出学生信息 样例输入 12345zhang3 20149003 M 信息系zhang5 20149005 F 信息系zhang10 20149010 F 管理系zhang1 20149001 M 会计系zhang9 20149009 M 会计系 样例输出 12345zhang1 20149001 M 会计系zhang3 20149003 M 信息系zhang5 20149005 F 信息系zhang9 20149009 M 会计系zhang10 20149010 F 管理系 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Student&#123; char name[20]; long num; char sex; char dept[20]; &#125;;struct Student stu[40];int main( )&#123; struct Student tmp; int i,j; for(i=0; i&lt;5; i++) &#123; scanf(&quot;%s %ld %c %s&quot;,stu[i].name, &amp;stu[i].num,&amp;stu[i].sex, stu[i].dept); &#125; for(i=0;i&lt;5;i++) for(j=0;j&lt;4-i;j++) &#123; if(stu[j].num&gt;stu[j+1].num) &#123; tmp=stu[j]; stu[j]=stu[j+1]; stu[j+1]=tmp; &#125; &#125; for(i=0; i&lt;5; i++) &#123; printf(&quot;%s %ld %c %s\\n&quot;,stu[i].name, stu[i].num,stu[i].sex,stu[i].dept); &#125; return 0;&#125; 26.给定程序通过定义并赋初值的方式，利用结构体变量存储了一名学生的学号、姓名和3门课的成绩。函数fun的功能是将该学生的各科成绩都乘以一个系数a。 请在程序的下划线处填入正确的内容并把下划线删除，使程序得出正确的结果。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;typedef struct&#123;int num;char name[9];float score[3];&#125;STU;void show(STU tt)&#123;int i;printf(&quot;%d %s : &quot;,tt.num,tt.name);for(i=0; i&lt;3; i++)printf(&quot;%5.1f&quot;,tt.score[i]);printf(&quot;\\n&quot;);&#125;int main( )&#123;STU std=&#123; 1,&quot;Zhanghua&quot;,76.5,78.0,82.0 &#125;;float a;scanf(&quot;%f&quot;,&amp;a);for(int i=0;i&lt;3;i++)&#123; std.score[i] *=a;&#125;show(std);return 0;&#125; 27.学生的记录由学号和成绩组成，N名学生的数据已在主函数中放入结构体数组s中, 请编写函数fun，它的功能是：把指定分数范围内的学生数据放在h所指的数组中，分数范围内的学生人数由函数值返回。 例如，输入的分数是60 69, 则应当把分数在60到69的学生数据进行输出，包含60分和69分的学生数据。主函数中将把60放在low中，把69放在heigh中。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#define N 16typedef struct&#123;char num[10];int s;&#125; STREC;int main()&#123;STREC s[N]=&#123;&#123;&quot;GA005&quot;,85&#125;,&#123;&quot;GA003&quot;,76&#125;,&#123;&quot;GA002&quot;,69&#125;,&#123;&quot;GA004&quot;,85&#125;,&#123;&quot;GA001&quot;,96&#125;,&#123;&quot;GA007&quot;,72&#125;,&#123;&quot;GA008&quot;,64&#125;,&#123;&quot;GA006&quot;,87&#125;,&#123;&quot;GA015&quot;,85&#125;,&#123;&quot;GA013&quot;,94&#125;,&#123;&quot;GA012&quot;,64&#125;,&#123;&quot;GA014&quot;,91&#125;,&#123;&quot;GA011&quot;,90&#125;,&#123;&quot;GA017&quot;,64&#125;,&#123;&quot;GA018&quot;,64&#125;,&#123;&quot;GA016&quot;,72&#125;&#125;;STREC h[N];int i,n,low,heigh,t;scanf(&quot;%d%d&quot;, &amp;low,&amp;heigh);if ( heigh &lt; low )&#123;t=heigh;heigh=low;low=t;&#125;printf(&quot;The student&#x27;s data between %d--%d :\\n&quot;,low,heigh);for(int i=0;i&lt;N;i++)&#123; if(s[i].s&gt;=low&amp;&amp;s[i].s&lt;=heigh) &#123; printf(&quot;%s %4d\\n&quot;,s[i].num,s[i].s); &#125;&#125;return 0;&#125;","path":"2022/04/05/C语言基础题/","date":"04-05","excerpt":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Vue 快速入门笔记（十六）","text":"1、Vue 快速入门1.1、Vue的介绍 Vue是一套构建用户界面的渐进式前端框架。 只关注视图层，并且非常容易学习，还可以很方便的与其它库或已有项目整合。 通过尽可能简单的API来实现响应数据的绑定和组合的视图组件。 特点易用：在有HTMLCSSJavaScript的基础上，快速上手。灵活：简单小巧的核心，渐进式技术栈，足以应付任何规模的应用。性能：20kbmin+gzip运行大小、超快虚拟DOM、最省心的优化。 1.2、Vue的快速入门 开发步骤 下载和引入vue.js文件。 编写入门程序。视图：负责页面渲染，主要由HTML+CSS构成。脚本：负责业务数据模型（Model）以及数据的处理逻辑。 代码实现 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;快速入门&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 视图 --&gt; &lt;div id=&quot;div&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 脚本 new Vue(&#123; el:&quot;#div&quot;, data:&#123; msg:&quot;Hello Vue&quot; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 1.3、Vue快速入门详解 Vue 核心对象：每一个 Vue 程序都是从一个 Vue 核心对象开始的。 123let vm = new Vue(&#123; 选项列表;&#125;); 选项列表el选项：用于接收获取到页面中的元素。(根据常用选择器获取)。data选项：用于保存当前Vue对象中的数据。在视图中声明的变量需要在此处赋值。methods选项：用于定义方法。方法可以直接通过对象名调用，this代表当前Vue对象。 数据绑定在视图部分获取脚本部分的数据。 1.4、Vue快速入门的升级12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;快速入门升级&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 视图 --&gt; &lt;div id=&quot;div&quot;&gt; &lt;div&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div&gt;班级：&#123;&#123;classRoom&#125;&#125;&lt;/div&gt; &lt;button onclick=&quot;hi()&quot;&gt;打招呼&lt;/button&gt; &lt;button onclick=&quot;update()&quot;&gt;修改班级&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // 脚本 let vm = new Vue(&#123; el:&quot;#div&quot;, data:&#123; name:&quot;张三&quot;, classRoom:&quot;黑马程序员&quot; &#125;, methods:&#123; study()&#123; alert(this.name + &quot;正在&quot; + this.classRoom + &quot;好好学习!&quot;); &#125; &#125; &#125;); //定义打招呼方法 function hi()&#123; vm.study(); &#125; //定义修改班级 function update()&#123; vm.classRoom = &quot;传智播客&quot;; &#125;&lt;/script&gt;&lt;/html&gt; 1.5、Vue小结 Vue是一套构建用户界面的渐进式前端框架。 Vue的程序包含视图和脚本两个核心部分。 脚本部分 Vue核心对象。 选项列表 el：接收获取的元素。 data：保存数据。 methods：定义方法。 视图部分 数据绑定： 2、Vue 常用指令2.1、指令介绍 指令：是带有 v- 前缀的特殊属性，不同指令具有不同含义。例如 v-html，v-if，v-for。 使用指令时，通常编写在标签的属性上，值可以使用 JS 的表达式。 常用指令 2.2、文本插值 v-html：把文本解析为 HTML 代码。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;文本插值&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;div v-html=&quot;msg&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot;, data:&#123; msg:&quot;&lt;b&gt;Hello Vue&lt;/b&gt;&quot; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 2.3、绑定属性 v-bind：为 HTML 标签绑定属性值。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;绑定属性&lt;/title&gt; &lt;style&gt; .my&#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;a v-bind:href=&quot;url&quot;&gt;百度一下&lt;/a&gt; &lt;br&gt; &lt;a :href=&quot;url&quot;&gt;百度一下&lt;/a&gt; &lt;br&gt; &lt;div :class=&quot;cls&quot;&gt;我是div&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot;, data:&#123; url:&quot;https://www.baidu.com&quot;, cls:&quot;my&quot; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 2.4、条件渲染 v-if：条件性的渲染某元素，判定为真时渲染,否则不渲染。 v-else：条件性的渲染。 v-else-if：条件性的渲染。 v-show：根据条件展示某元素，区别在于切换的是display属性的值。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;条件渲染&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;!-- 判断num的值，对3取余 余数为0显示div1 余数为1显示div2 余数为2显示div3 --&gt; &lt;div v-if=&quot;num % 3 == 0&quot;&gt;div1&lt;/div&gt; &lt;div v-else-if=&quot;num % 3 == 1&quot;&gt;div2&lt;/div&gt; &lt;div v-else=&quot;num % 3 == 2&quot;&gt;div3&lt;/div&gt; &lt;div v-show=&quot;flag&quot;&gt;div4&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot;, data:&#123; num:1, flag:false &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 2.5、列表渲染 v-for：列表渲染，遍历容器的元素或者对象的属性。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;列表渲染&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;name in names&quot;&gt; &#123;&#123;name&#125;&#125; &lt;/li&gt; &lt;li v-for=&quot;value in student&quot;&gt; &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot;, data:&#123; names:[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;], student:&#123; name:&quot;张三&quot;, age:23 &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 2.6、事件绑定 v-on：为 HTML 标签绑定事件。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;事件绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;button v-on:click=&quot;change()&quot;&gt;改变div的内容&lt;/button&gt; &lt;button v-on:dblclick=&quot;change()&quot;&gt;改变div的内容&lt;/button&gt; &lt;button @click=&quot;change()&quot;&gt;改变div的内容&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot;, data:&#123; name:&quot;黑马程序员&quot; &#125;, methods:&#123; change()&#123; this.name = &quot;传智播客&quot; &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 2.7、表单绑定 表单绑定v-model：在表单元素上创建双向数据绑定。 双向数据绑定更新data数据，页面中的数据也会更新。更新页面数据，data数据也会更新。 MVVM模型(ModelViewViewModel)：是MVC模式的改进版在前端页面中，JS对象表示Model，页面表示View，两者做到了最大限度的分离。将Model和View关联起来的就是ViewModel，它是桥梁。ViewModel负责把Model的数据同步到View显示出来，还负责把View修改的数据同步回Model。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;表单绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;form autocomplete=&quot;off&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; v-model=&quot;username&quot;&gt; &lt;br&gt; 年龄：&lt;input type=&quot;number&quot; name=&quot;age&quot; v-model=&quot;age&quot;&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot;, data:&#123; username:&quot;张三&quot;, age:23 &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 2.8、小结 指令：是带有v-前缀的特殊属性，不同指令具有不同含义。 文本插值v-html：把文本解析为HTML代码。 绑定属性v-bind：为HTML标签绑定属性值。 条件渲染v-if：条件性的渲染某元素，判定为真时渲染,否则不渲染。v-else：条件性的渲染。v-else-if：条件性的渲染。v-show：根据条件展示某元素，区别在于切换的是display属性的值。 列表渲染v-for：列表渲染，遍历容器的元素或者对象的属性。 事件绑定v-on：为HTML标签绑定事件。 表单绑定v-model：在表单元素上创建双向数据绑定。 3、Element 基本使用3.1、Element介绍 Element：网站快速成型工具。是饿了么公司前端开发团队提供的一套基于Vue的网站组件库。 使用Element前提必须要有Vue。 组件：组成网页的部件，例如超链接、按钮、图片、表格等等~ Element官网：https://element.eleme.cn/#/zh-CN 自己完成的按钮 Element 提供的按钮 3.2、Element快速入门 开发步骤 下载 Element 核心库。 引入 Element 样式文件。 引入 Vue 核心 js 文件。 引入 Element 核心 js 文件。 编写按钮标签。 通过 Vue 核心对象加载元素。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;快速入门&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;我是按钮&lt;/button&gt; &lt;br&gt; &lt;div id=&quot;div&quot;&gt; &lt;el-row&gt; &lt;el-button&gt;默认按钮&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt; &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt; &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot;&gt;危险按钮&lt;/el-button&gt; &lt;/el-row&gt; &lt;br&gt; &lt;el-row&gt; &lt;el-button plain&gt;朴素按钮&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; plain&gt;主要按钮&lt;/el-button&gt; &lt;el-button type=&quot;success&quot; plain&gt;成功按钮&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; plain&gt;信息按钮&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; plain&gt;警告按钮&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; plain&gt;危险按钮&lt;/el-button&gt; &lt;/el-row&gt; &lt;br&gt; &lt;el-row&gt; &lt;el-button round&gt;圆角按钮&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; round&gt;主要按钮&lt;/el-button&gt; &lt;el-button type=&quot;success&quot; round&gt;成功按钮&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; round&gt;信息按钮&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; round&gt;警告按钮&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; round&gt;危险按钮&lt;/el-button&gt; &lt;/el-row&gt; &lt;br&gt; &lt;el-row&gt; &lt;el-button icon=&quot;el-icon-search&quot; circle&gt;&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle&gt;&lt;/el-button&gt; &lt;el-button type=&quot;success&quot; icon=&quot;el-icon-check&quot; circle&gt;&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; icon=&quot;el-icon-message&quot; circle&gt;&lt;/el-button&gt; &lt;el-button type=&quot;warning&quot; icon=&quot;el-icon-star-off&quot; circle&gt;&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle&gt;&lt;/el-button&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot; &#125;);&lt;/script&gt;&lt;/html&gt; 3.3、基础布局将页面分成最多 24 个部分，自由切分。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;基础布局&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .el-row &#123; /* 行距为20px */ margin-bottom: 20px; &#125; .bg-purple-dark &#123; background: red; &#125; .bg-purple &#123; background: blue; &#125; .bg-purple-light &#123; background: green; &#125; .grid-content &#123; /* 边框圆润度 */ border-radius: 4px; /* 行高为36px */ min-height: 36px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot;&gt;&lt;div class=&quot;grid-content bg-purple-dark&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot;&gt;&lt;/div&gt;&lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot; &#125;);&lt;/script&gt;&lt;/html&gt; 3.4、容器布局将页面分成头部区域、侧边栏区域、主区域、底部区域。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;容器布局&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .el-header, .el-footer &#123; background-color: #d18e66; color: #333; text-align: center; height: 100px; &#125; .el-aside &#123; background-color: #55e658; color: #333; text-align: center; height: 580px; &#125; .el-main &#123; background-color: #5fb1f3; color: #333; text-align: center; height: 520px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;el-container&gt; &lt;el-header&gt;头部区域&lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt;侧边栏区域&lt;/el-aside&gt; &lt;el-container&gt; &lt;el-main&gt;主区域&lt;/el-main&gt; &lt;el-footer&gt;底部区域&lt;/el-footer&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot; &#125;);&lt;/script&gt;&lt;/html&gt; 3.5、表单组件由输入框、下拉列表、单选框、多选框等控件组成，用以收集、校验、提交数据。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;表单组件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;el-form :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt; &lt;el-form-item label=&quot;活动名称&quot; prop=&quot;name&quot;&gt; &lt;el-input v-model=&quot;ruleForm.name&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;活动区域&quot; prop=&quot;region&quot;&gt; &lt;el-select v-model=&quot;ruleForm.region&quot; placeholder=&quot;请选择活动区域&quot;&gt; &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt; &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;活动时间&quot; required&gt; &lt;el-col :span=&quot;11&quot;&gt; &lt;el-form-item prop=&quot;date1&quot;&gt; &lt;el-date-picker type=&quot;date&quot; placeholder=&quot;选择日期&quot; v-model=&quot;ruleForm.date1&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-date-picker&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;el-col class=&quot;line&quot; :span=&quot;2&quot;&gt;-&lt;/el-col&gt; &lt;el-col :span=&quot;11&quot;&gt; &lt;el-form-item prop=&quot;date2&quot;&gt; &lt;el-time-picker placeholder=&quot;选择时间&quot; v-model=&quot;ruleForm.date2&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-time-picker&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;即时配送&quot; prop=&quot;delivery&quot;&gt; &lt;el-switch v-model=&quot;ruleForm.delivery&quot;&gt;&lt;/el-switch&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;活动性质&quot; prop=&quot;type&quot;&gt; &lt;el-checkbox-group v-model=&quot;ruleForm.type&quot;&gt; &lt;el-checkbox label=&quot;美食/餐厅线上活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label=&quot;地推活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label=&quot;线下主题活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt; &lt;el-checkbox label=&quot;单纯品牌曝光&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;特殊资源&quot; prop=&quot;resource&quot;&gt; &lt;el-radio-group v-model=&quot;ruleForm.resource&quot;&gt; &lt;el-radio label=&quot;线上品牌商赞助&quot;&gt;&lt;/el-radio&gt; &lt;el-radio label=&quot;线下场地免费&quot;&gt;&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;活动形式&quot; prop=&quot;desc&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;ruleForm.desc&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;ruleForm&#x27;)&quot;&gt;立即创建&lt;/el-button&gt; &lt;el-button @click=&quot;resetForm(&#x27;ruleForm&#x27;)&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot;, data:&#123; ruleForm: &#123; name: &#x27;&#x27;, region: &#x27;&#x27;, date1: &#x27;&#x27;, date2: &#x27;&#x27;, delivery: false, type: [], resource: &#x27;&#x27;, desc: &#x27;&#x27; &#125;, rules: &#123; name: [ &#123; required: true, message: &#x27;请输入活动名称&#x27;, trigger: &#x27;blur&#x27; &#125;, &#123; min: 3, max: 5, message: &#x27;长度在 3 到 5 个字符&#x27;, trigger: &#x27;blur&#x27; &#125; ], region: [ &#123; required: true, message: &#x27;请选择活动区域&#x27;, trigger: &#x27;change&#x27; &#125; ], date1: [ &#123; type: &#x27;date&#x27;, required: true, message: &#x27;请选择日期&#x27;, trigger: &#x27;change&#x27; &#125; ], date2: [ &#123; type: &#x27;date&#x27;, required: true, message: &#x27;请选择时间&#x27;, trigger: &#x27;change&#x27; &#125; ], type: [ &#123; type: &#x27;array&#x27;, required: true, message: &#x27;请至少选择一个活动性质&#x27;, trigger: &#x27;change&#x27; &#125; ], resource: [ &#123; required: true, message: &#x27;请选择活动资源&#x27;, trigger: &#x27;change&#x27; &#125; ], desc: [ &#123; required: true, message: &#x27;请填写活动形式&#x27;, trigger: &#x27;blur&#x27; &#125; ] &#125; &#125;, methods:&#123; submitForm(formName) &#123; this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; alert(&#x27;submit!&#x27;); &#125; else &#123; console.log(&#x27;error submit!!&#x27;); return false; &#125; &#125;); &#125;, resetForm(formName) &#123; this.$refs[formName].resetFields(); &#125; &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 3.6、表格组件用于展示多条结构类似的数据，可对数据进行编辑、删除或其他自定义操作。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;表格组件&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;template&gt; &lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;180&quot;&gt; &lt;el-button type=&quot;warning&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot;&gt;删除&lt;/el-button&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot;, data:&#123; tableData: [&#123; date: &#x27;2016-05-02&#x27;, name: &#x27;王小虎&#x27;, address: &#x27;上海市普陀区金沙江路 1518 弄&#x27; &#125;, &#123; date: &#x27;2016-05-04&#x27;, name: &#x27;王小虎&#x27;, address: &#x27;上海市普陀区金沙江路 1517 弄&#x27; &#125;, &#123; date: &#x27;2016-05-01&#x27;, name: &#x27;王小虎&#x27;, address: &#x27;上海市普陀区金沙江路 1519 弄&#x27; &#125;, &#123; date: &#x27;2016-05-03&#x27;, name: &#x27;王小虎&#x27;, address: &#x27;上海市普陀区金沙江路 1516 弄&#x27; &#125;] &#125; &#125;);&lt;/script&gt;&lt;/html&gt; 3.7、顶部导航栏组件 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;顶部导航栏&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;el-menu :default-active=&quot;activeIndex2&quot; class=&quot;el-menu-demo&quot; mode=&quot;horizontal&quot; @select=&quot;handleSelect&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot;&gt; &lt;el-menu-item index=&quot;1&quot;&gt;处理中心&lt;/el-menu-item&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt;我的工作台&lt;/template&gt; &lt;el-menu-item index=&quot;2-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-3&quot;&gt;选项3&lt;/el-menu-item&gt; &lt;el-submenu index=&quot;2-4&quot;&gt; &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt; &lt;el-menu-item index=&quot;2-4-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-4-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-4-3&quot;&gt;选项3&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;el-menu-item index=&quot;3&quot; disabled&gt;消息中心&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;4&quot;&gt;&lt;a href=&quot;https://www.ele.me&quot; target=&quot;_blank&quot;&gt;订单管理&lt;/a&gt;&lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot; &#125;);&lt;/script&gt;&lt;/html&gt; 3.8、侧边导航栏组件 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;侧边导航栏&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;el-col :span=&quot;6&quot;&gt; &lt;el-menu default-active=&quot;2&quot; class=&quot;el-menu-vertical-demo&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;导航一&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;template slot=&quot;title&quot;&gt;分组一&lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-menu-item-group title=&quot;分组2&quot;&gt; &lt;el-menu-item index=&quot;1-3&quot;&gt;选项3&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-submenu index=&quot;1-4&quot;&gt; &lt;template slot=&quot;title&quot;&gt;选项4&lt;/template&gt; &lt;el-menu-item index=&quot;1-4-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;el-menu-item index=&quot;2&quot;&gt; &lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;导航二&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;3&quot; disabled&gt; &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;导航三&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;4&quot;&gt; &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;导航四&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/el-col&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot; &#125;);&lt;/script&gt;&lt;/html&gt; 3.9、小结 Element：网站快速成型工具。是一套为开发者、设计师、产品经理准备的基于Vue的桌面端组件库。 使用Element前提必须要有Vue。 使用步骤1.下载Element核心库。2.引入Element样式文件。3.引入Vue核心js文件。4.引入Element核心js文件。5.借助常用组件编写网页。 常用组件网页基本组成部分，布局、按钮、表格、表单等等~~~常用组件不需要记住，只需要在Element官网中复制使用即可。 4、综合案例 学生列表4.1、案例效果和分析 4.2、头部区域的实现 实现思路 头部效果实现。 侧边栏和主区域效果实现。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;学生列表&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .el-header&#123; background-color: #545c64; &#125; .header-img&#123; width: 100px; margin-top: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot;&gt; &lt;el-container&gt; &lt;!-- 头部 --&gt; &lt;el-header class=&quot;el-header&quot;&gt; &lt;el-container&gt; &lt;div&gt; &lt;el-image src=&quot;img/export.png&quot; class=&quot;header-img&quot;&gt;&lt;/el-image&gt; &lt;/div&gt; &lt;el-menu :default-active=&quot;activeIndex2&quot; mode=&quot;horizontal&quot; @select=&quot;handleSelect&quot; background-color=&quot;#545c64&quot; text-color=&quot;white&quot; active-text-color=&quot;#ffd04b&quot; style=&quot;margin-left: auto;&quot;&gt; &lt;el-menu-item index=&quot;1&quot;&gt;处理中心&lt;/el-menu-item&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt;我的工作台&lt;/template&gt; &lt;el-menu-item index=&quot;2-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-3&quot;&gt;选项3&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-menu-item index=&quot;3&quot;&gt;&lt;a href=&quot;学生列表.html&quot; target=&quot;_self&quot;&gt;首页&lt;/a&gt;&lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/el-container&gt; &lt;/el-header&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el:&quot;#div&quot; &#125;);&lt;/script&gt;&lt;/html&gt; 4.3、侧边栏区域的实现1234567891011121314151617181920212223242526272829303132&lt;!-- 侧边栏区域 --&gt;&lt;el-container style=&quot;height: 580px; border: 1px solid #eee&quot;&gt; &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;el-menu :default-openeds=&quot;[&#x27;1&#x27;]&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;学工部&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;&lt;i class=&quot;el-icon-help&quot;&gt;&lt;/i&gt;在校学生管理&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;&lt;i class=&quot;el-icon-help&quot;&gt;&lt;/i&gt;学生升级/留级&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-3&quot;&gt;&lt;i class=&quot;el-icon-help&quot;&gt;&lt;/i&gt;学生就业情况&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;咨询部&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;2-1&quot;&gt;&lt;i class=&quot;el-icon-help&quot;&gt;&lt;/i&gt;意向学生管理&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-2&quot;&gt;&lt;i class=&quot;el-icon-help&quot;&gt;&lt;/i&gt;未报名学生管理&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-3&quot;&gt;&lt;i class=&quot;el-icon-help&quot;&gt;&lt;/i&gt;已报名学生管理&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;3&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;教研部&lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;3-1&quot;&gt;&lt;i class=&quot;el-icon-help&quot;&gt;&lt;/i&gt;已有课程管理&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;3-2&quot;&gt;&lt;i class=&quot;el-icon-help&quot;&gt;&lt;/i&gt;正在研发课程管理&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;3-3&quot;&gt;&lt;i class=&quot;el-icon-help&quot;&gt;&lt;/i&gt;新技术课程管理&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt;&lt;/el-container&gt; 4.4、主区域的实现主区域和侧边栏区域放在一起 1234567891011121314151617181920212223&lt;!-- 主区域 --&gt;&lt;el-container&gt; &lt;el-main&gt; &lt;b style=&quot;color: red;font-size: 20px;&quot;&gt;学生列表&lt;/b&gt; &lt;div style=&quot;float:right&quot;&gt; &lt;el-button type=&quot;primary&quot;&gt;添加学生&lt;/el-button&gt; &lt;/div&gt; &lt;el-table :data=&quot;tableData&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;140&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;120&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;180&quot;&gt; &lt;el-button type=&quot;warning&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button type=&quot;danger&quot;&gt;删除&lt;/el-button&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-main&gt;&lt;/el-container&gt; 在vue中定义data 12345678910111213141516171819202122&lt;script&gt; new Vue(&#123; el:&quot;#div&quot;, data:&#123; tableData:[ &#123; date:&quot;2088-08-08&quot;, name:&quot;张三&quot;, address:&quot;北京市昌平区&quot; &#125;,&#123; date:&quot;2088-08-08&quot;, name:&quot;李四&quot;, address:&quot;北京市昌平区&quot; &#125;,&#123; date:&quot;2088-08-08&quot;, name:&quot;王五&quot;, address:&quot;北京市昌平区&quot; &#125;, ] &#125; &#125;);&lt;/script&gt;","path":"2022/04/03/Js之Vue笔记（十六）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Ajax快速入门笔记（十五）","text":"1、Ajax快速入门1.1、AJAX介绍 AJAX(Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。 本身不是一种新技术，而是多个技术综合。用于快速创建动态网页的技术。 一般的网页如果需要更新内容，必需重新加载个页面。 而 AJAX 通过浏览器与服务器进行少量数据交换，就可以使网页实现异步更新。也就是在不重新加载整个页 面的情况下，对网页的部分内容进行局部更新。 ​ ​ 1.2、原生JS实现AJAX 代码实现 12345678910111213141516171819202122232425262728293031323334353637import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/userServlet&quot;)public class UserServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置请求和响应的乱码 req.setCharacterEncoding(&quot;UTF-8&quot;); resp.setContentType(&quot;text/html;charset=UTF-8&quot;); //1.获取请求参数 String username = req.getParameter(&quot;username&quot;); //模拟服务器处理请求需要5秒钟 /*try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;*/ //2.判断姓名是否已注册 if(&quot;zhangsan&quot;.equals(username)) &#123; resp.getWriter().write(&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已注册&lt;/font&gt;&quot;); &#125;else &#123; resp.getWriter().write(&quot;&lt;font color=&#x27;green&#x27;&gt;用户名可用&lt;/font&gt;&quot;); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req,resp); &#125;&#125; html代码 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form autocomplete=&quot;off&quot;&gt; 姓名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;span id=&quot;uSpan&quot;&gt;&lt;/span&gt; &lt;br&gt; 密码：&lt;input type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;script&gt; //1.为姓名绑定失去焦点事件 document.getElementById(&quot;username&quot;).onblur = function() &#123; //2.创建XMLHttpRequest核心对象 let xmlHttp = new XMLHttpRequest(); //3.打开链接 let username = document.getElementById(&quot;username&quot;).value; xmlHttp.open(&quot;GET&quot;,&quot;userServlet?username=&quot;+username,true); //xmlHttp.open(&quot;GET&quot;,&quot;userServlet?username=&quot;+username,false); //4.发送请求 xmlHttp.send(); //5.处理响应 xmlHttp.onreadystatechange = function() &#123; //判断请求和响应是否成功 if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; //将响应的数据显示到span标签 document.getElementById(&quot;uSpan&quot;).innerHTML = xmlHttp.responseText; &#125; &#125; &#125;&lt;/script&gt;&lt;/html&gt; 1.3、原生JS实现AJAX详解 核心对象：XMLHttpRequest ​ 用于在后台与服务器交换数据。可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 打开链接：open(method,url,async) ​ method：请求的类型 GET 或 POST。 ​ url：请求资源的路径。 ​ async：true(异步) 或 false(同步)。 发送请求：send(String params) ​ params：请求的参数(POST 专用)。 处理响应：onreadystatechange ​ readyState：0-请求未初始化，1-服务器连接已建立，2-请求已接收，3-请求处理中，4-请求已完成，且响应已就绪。 ​ status：200-响应已全部 OK。 获得响应数据形式 ​ responseText：获得字符串形式的响应数据。 ​ responseXML：获得 XML 形式的响应数据。 1.4、JQuery的GET方式实现AJAX 核心语法：$.get(url,[data],[callback],[type]); url：请求的资源路径。 data：发送给服务器端的请求参数，格式可以是key&#x3D;value，也可以是 js 对象。 callback：当请求成功后的回调函数，可以在函数中编写我们的逻辑代码。 type：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form autocomplete=&quot;off&quot;&gt; 姓名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;span id=&quot;uSpan&quot;&gt;&lt;/span&gt; &lt;br&gt; 密码：&lt;input type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1.为用户名绑定失去焦点事件 $(&quot;#username&quot;).blur(function () &#123; let username = $(&quot;#username&quot;).val(); //2.jQuery的GET方式实现AJAX $.get( //请求的资源路径 &quot;userServlet&quot;, //请求参数 &quot;username=&quot; + username, //回调函数 function (data) &#123; //将响应的数据显示到span标签 $(&quot;#uSpan&quot;).html(data); &#125;, //响应数据形式 &quot;text&quot; ); &#125;);&lt;/script&gt;&lt;/html&gt; 1.5、JQuery的POST方式实现AJAX 核心语法：$.post(url,[data],[callback],[type]); url：请求的资源路径。 data：发送给服务器端的请求参数，格式可以是key&#x3D;value，也可以是 js 对象。 callback：当请求成功后的回调函数，可以在函数中编写我们的逻辑代码。 type：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form autocomplete=&quot;off&quot;&gt; 姓名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;span id=&quot;uSpan&quot;&gt;&lt;/span&gt; &lt;br&gt; 密码：&lt;input type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1.为用户名绑定失去焦点事件 $(&quot;#username&quot;).blur(function () &#123; let username = $(&quot;#username&quot;).val(); //2.jQuery的POST方式实现AJAX $.post( //请求的资源路径 &quot;userServlet&quot;, //请求参数 &quot;username=&quot; + username, //回调函数 function (data) &#123; //将响应的数据显示到span标签 $(&quot;#uSpan&quot;).html(data); &#125;, //响应数据形式 &quot;text&quot; ); &#125;);&lt;/script&gt;&lt;/html&gt; 1.6、JQuery的通用方式实现AJAX 核心语法：$.ajax({name:value,name:value,…}); url：请求的资源路径。 async：是否异步请求，true-是，false-否 (默认是 true)。 data：发送到服务器的数据，可以是键值对形式，也可以是 js 对象形式。 type：请求方式，POST 或 GET (默认是 GET)。 dataType：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 success：请求成功时调用的回调函数。 error：请求失败时调用的回调函数。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form autocomplete=&quot;off&quot;&gt; 姓名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;span id=&quot;uSpan&quot;&gt;&lt;/span&gt; &lt;br&gt; 密码：&lt;input type=&quot;password&quot; id=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1.为用户名绑定失去焦点事件 $(&quot;#username&quot;).blur(function () &#123; let username = $(&quot;#username&quot;).val(); //2.jQuery的通用方式实现AJAX $.ajax(&#123; //请求资源路径 url:&quot;userServletxxx&quot;, //是否异步 async:true, //请求参数 data:&quot;username=&quot;+username, //请求方式 type:&quot;POST&quot;, //数据形式 dataType:&quot;text&quot;, //请求成功后调用的回调函数 success:function (data) &#123; //将响应的数据显示到span标签 $(&quot;#uSpan&quot;).html(data); &#125;, //请求失败后调用的回调函数 error:function () &#123; alert(&quot;操作失败...&quot;); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/html&gt; 1.7、小结 AJAX(Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。 通过浏览器与服务器进行少量数据交换，就可以使网页实现异步更新。也就是在不重新加载整个页面的情况下，对网页的部 分内容进行局部更新。 同步和异步 同步：服务器端在处理过程中，无法进行其他操作。 异步：服务器端在处理过程中，可以进行其他操作。 GET 方式实现：$.get(); POST 方式实现：$.post(); url：请求的资源路径。 data：发送给服务器端的请求参数，格式可以是key&#x3D;value，也可以是 js 对象。 callback：当请求成功后的回调函数，可以在函数中编写我们的逻辑代码。 type：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 通用方式实现：$.ajax(); url：请求的资源路径。 async：是否异步请求，true-是，false-否 (默认是 true)。 data：发送到服务器的数据，可以是键值对形式，也可以是 js 对象形式。 type：请求方式，POST 或 GET (默认是 GET)。 dataType：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。 success：请求成功时调用的回调函数。 error：请求失败时调用的回调函数。 2、JSON的处理2.1、JSON回顾 JSON(JavaScript Object Notation)：是一种轻量级的数据交换格式。 它是基于 ECMAScript 规范的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于计算机解析和生成，并有效的 提升网络传输效率。 创建格式 常用方法 2.2、JSON转换工具的介绍 我们除了可以在 JavaScript 中来使用 JSON 以外，在 JAVA 中同样也可以使用 JSON。 JSON 的转换工具是通过 JAVA 封装好的一些 JAR 工具包。 可以将 JAVA 对象或集合转换成 JSON 格式的字符串，也可以将 JSON 格式的字符串转成 JAVA 对象。 Jackson：开源免费的 JSON 转换工具，SpringMVC 转换默认使用 Jackson。 导入 jar 包。 创建核心对象。 调用方法完成转换。 常用类 ObjectMapper常用方法 2.3、JSON转换练习 对象转 JSON, JSON 转对象。 12345678910111213141516171819202122/* JSON转换工具的使用 */public class ObjectMapperTest &#123; private ObjectMapper mapper = new ObjectMapper(); /* 1.User对象转json, json转User对象 json字符串 = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23&#125; user对象 = User&#123;name=&#x27;张三&#x27;, age=23&#125; */ @Test public void test01() throws Exception&#123; //User对象转json User user = new User(&quot;张三&quot;,23); String json = mapper.writeValueAsString(user); System.out.println(&quot;json字符串：&quot; + json); //json转User对象 User user2 = mapper.readValue(json, User.class); System.out.println(&quot;java对象：&quot; + user2); &#125;&#125; Map转 JSON, JSON 转 Map。 123456789101112131415161718/* 2.map&lt;String,String&gt;转json, json转map&lt;String,String&gt; json字符串 = &#123;&quot;姓名&quot;:&quot;张三&quot;,&quot;性别&quot;:&quot;男&quot;&#125; map对象 = &#123;姓名=张三, 性别=男&#125;*/@Testpublic void test02() throws Exception&#123; //map&lt;String,String&gt;转json HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;姓名&quot;,&quot;张三&quot;); map.put(&quot;性别&quot;,&quot;男&quot;); String json = mapper.writeValueAsString(map); System.out.println(&quot;json字符串：&quot; + json); //json转map&lt;String,String&gt; HashMap&lt;String,String&gt; map2 = mapper.readValue(json, HashMap.class); System.out.println(&quot;java对象：&quot; + map2);&#125; Map转 JSON, JSON 转 Map。 123456789101112131415161718/* 3.map&lt;String,User&gt;转json, json转map&lt;String,User&gt; json字符串 = &#123;&quot;黑马一班&quot;:&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23&#125;,&quot;黑马二班&quot;:&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:24&#125;&#125; map对象 = &#123;黑马一班=User&#123;name=&#x27;张三&#x27;, age=23&#125;, 黑马二班=User&#123;name=&#x27;李四&#x27;, age=24&#125;&#125; */@Testpublic void test03() throws Exception&#123; //map&lt;String,User&gt;转json HashMap&lt;String,User&gt; map = new HashMap&lt;&gt;(); map.put(&quot;黑马一班&quot;,new User(&quot;张三&quot;,23)); map.put(&quot;黑马二班&quot;,new User(&quot;李四&quot;,24)); String json = mapper.writeValueAsString(map); System.out.println(&quot;json字符串：&quot; + json); //json转map&lt;String,User&gt; HashMap&lt;String,User&gt; map2 = mapper.readValue(json,new TypeReference&lt;HashMap&lt;String,User&gt;&gt;()&#123;&#125;); System.out.println(&quot;java对象：&quot; + map2);&#125; List转 JSON, JSON 转 List。 123456789101112131415161718/* 4.List&lt;String&gt;转json, json转 List&lt;String&gt; json字符串 = [&quot;张三&quot;,&quot;李四&quot;] list对象 = [张三, 李四]*/@Testpublic void test04() throws Exception&#123; //List&lt;String&gt;转json ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张三&quot;); list.add(&quot;李四&quot;); String json = mapper.writeValueAsString(list); System.out.println(&quot;json字符串：&quot; + json); //json转 List&lt;String&gt; ArrayList&lt;String&gt; list2 = mapper.readValue(json,ArrayList.class); System.out.println(&quot;java对象：&quot; + list2);&#125; List转 JSON, JSON 转 List。 123456789101112131415161718/* 5.List&lt;User&gt;转json, json转List&lt;User&gt; json字符串 = [&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23&#125;,&#123;&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:24&#125;] list对象 = [User&#123;name=&#x27;张三&#x27;, age=23&#125;, User&#123;name=&#x27;李四&#x27;, age=24&#125;] */@Testpublic void test05() throws Exception&#123; //List&lt;User&gt;转json ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(new User(&quot;张三&quot;,23)); list.add(new User(&quot;李四&quot;,24)); String json = mapper.writeValueAsString(list); System.out.println(&quot;json字符串：&quot; + json); //json转List&lt;User&gt; ArrayList&lt;User&gt; list2 = mapper.readValue(json,new TypeReference&lt;ArrayList&lt;User&gt;&gt;()&#123;&#125;); System.out.println(&quot;java对象：&quot; + list2);&#125; 2.4、小结 Jackson：开源免费的 JSON 转换工具，SpringMVC 转换默认使用 Jackson。 可以将 JAVA 对象或集合转换成 JSON 格式的字符串，也可以将 JSON 格式的字符串转成 JAVA 对象。 常用类 3、综合案例 搜索联想 案例效果和环境介绍 案例分析 页面 为用户名输入框绑定鼠标点击事件。 获取输入的用户名数据。 判断用户名是否为空。 如果为空，则将联想提示框隐藏。 如果不为空，则发送 AJAX 请求，并将响应的数据显示到联想框。 控制层 获取请求参数。 调用业务层的模糊查询方法。 将返回的数据转成 JSON，并响应给客户端。 代码实现 html页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户搜索&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .content &#123; width: 643px; margin: 100px auto; text-align: center; &#125; input[type=&#x27;text&#x27;] &#123; width: 530px; height: 40px; font-size: 14px; &#125; input[type=&#x27;button&#x27;] &#123; width: 100px; height: 46px; background: #38f; border: 0; color: #fff; font-size: 15px &#125; .show &#123; position: absolute; width: 535px; height: 100px; border: 1px solid #999; border-top: 0; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form autocomplete=&quot;off&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;img src=&quot;img/logo.jpg&quot;&gt; &lt;br/&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;搜索一下&quot;&gt; &lt;!--用于显示联想的数据--&gt; &lt;div id=&quot;show&quot; class=&quot;show&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //1.为用户名输入框绑定鼠标点击事件 $(&quot;#username&quot;).mousedown(function () &#123; //2.获取输入的用户名 let username = $(&quot;#username&quot;).val(); //3.判断用户名是否为空 if(username == null || username == &quot;&quot;) &#123; //4.如果为空，将联想框隐藏 $(&quot;#show&quot;).hide(); return; &#125; //5.如果不为空，发送AJAX请求。并将数据显示到联想框 $.ajax(&#123; //请求的资源路径 url:&quot;userServlet&quot;, //请求参数 data:&#123;&quot;username&quot;:username&#125;, //请求方式 type:&quot;POST&quot;, //响应数据形式 dataType:&quot;json&quot;, //请求成功后的回调函数 success:function (data) &#123; //将返回的数据显示到show的div let names = &quot;&quot;; for(let i = 0; i &lt; data.length; i++) &#123; names += &quot;&lt;div&gt;&quot;+data[i].name+&quot;&lt;/div&gt;&quot;; &#125; $(&quot;#show&quot;).html(names); $(&quot;#show&quot;).show(); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/html&gt; 控制层-Java代码 1234567891011121314151617181920212223242526@WebServlet(&quot;/userServlet&quot;)public class UserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置请求和响应的编码 req.setCharacterEncoding(&quot;UTF-8&quot;); resp.setContentType(&quot;text/html;charset=UTF-8&quot;); //1.获取请求参数 String username = req.getParameter(&quot;username&quot;); //2.调用业务层的模糊查询方法得到数据 UserService service = new UserServiceImpl(); List&lt;User&gt; users = service.selectLike(username); //3.将数据转成JSON，响应到客户端 ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(users); resp.getWriter().write(json); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125;&#125; 4、综合案例 分页​ 瀑布流无限加载数据分页 4.1、案例效果和环境准备 案例效果 环境准备 1.导入“案例二的sql语句.sql”文件（已在当天的SQL语句中提供） 2.导入“分页案例原始环境”中的ajax03项目（已在当天的资料中提供） 4.2、案例的分析 如何确定当前显示的数据已经浏览完毕？ 公式：(滚动条距底部的距离 + 滚动条上下滚动的距离 + 当前窗口的高度) &gt;&#x3D; 当前文档的高度 当前文档高度：存储10条数据，100px。 滚动条距底部的距离：1px。 当前窗口的高度：80px。 滚动条上下滚动的距离：&gt;&#x3D;19px。 前置知识 4.3、案例的实现 实现思路 页面 定义发送请求标记。 定义当前页码和每页显示的条数。 定义滚动条距底部的距离。 设置页面加载事件。 为当前窗口绑定滚动条滚动事件。 获取必要信息(当前窗口的高度,滚动条上下滚动的距离,当前文档的高度)。 计算当前展示数据是否浏览完毕。 判断请求标记是否为 true。 将请求标记置为 false，当前异步操作完成前，不能重新发起请求。 根据当前页和每页显示的条数来请求查询分页数据。 当前页码+1。 服务器 获取请求参数(当前页,每页显示的条数)。 根据当前页码和每页显示的条数，调用业务层的方法，得到分页 Page 对象。 将得到的数据转为 json。 将数据响应给客户端。 代码实现 html页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;script&gt; //1.定义发送请求标记 let send = true; //2.定义当前页码和每页显示的条数 let start = 1; let pageSize = 10; //3.定义滚动条距底部的距离 let bottom = 1; //4.设置页面加载事件 $(function () &#123; //5.为当前窗口绑定滚动条滚动事件 $(window).scroll(function () &#123; //6.获取必要信息，用于计算当前展示数据是否浏览完毕 //当前窗口的高度 let windowHeight = $(window).height(); //滚动条从上到下滚动距离 let scrollTop = $(window).scrollTop(); //当前文档的高度 let docHeight = $(document).height(); //7.计算当前展示数据是否浏览完毕 //当 滚动条距底部的距离 + 当前滚动条滚动的距离 + 当前窗口的高度 &gt;= 当前文档的高度 if((bottom + scrollTop + windowHeight) &gt;= docHeight) &#123; //8.判断请求标记是否为true if(send == true) &#123; //9.将请求标记置为false，当前异步操作完成前，不能重新发起请求。 send = false; //10.根据当前页和每页显示的条数来 请求查询分页数据 queryByPage(start,pageSize); //11.当前页码+1 start++; &#125; &#125; &#125;); &#125;); //定义查询分页数据的函数 function queryByPage(start,pageSize)&#123; //加载动图显示 $(&quot;.loading&quot;).show(); //发起AJAX请求 $.ajax(&#123; //请求的资源路径 url:&quot;newsServlet&quot;, //请求的参数 data:&#123;&quot;start&quot;:start,&quot;pageSize&quot;:pageSize&#125;, //请求的方式 type:&quot;POST&quot;, //响应数据形式 dataType:&quot;json&quot;, //请求成功后的回调函数 success:function (data) &#123; if(data.length == 0) &#123; $(&quot;.loading&quot;).hide(); $(&quot;#no&quot;).html(&quot;我也是有底线的...&quot;); return; &#125; //加载动图隐藏 $(&quot;.loading&quot;).hide(); //将数据显示 let titles = &quot;&quot;; for(let i = 0; i &lt; data.length; i++) &#123; titles += &quot;&lt;li&gt;\\n&quot; + &quot; &lt;div class=\\&quot;title-box\\&quot;&gt;\\n&quot; + &quot; &lt;a href=\\&quot;#\\&quot; class=\\&quot;link\\&quot;&gt;\\n&quot; + data[i].title + &quot; &lt;hr&gt;\\n&quot; + &quot; &lt;/a&gt;\\n&quot; + &quot; &lt;/div&gt;\\n&quot; + &quot; &lt;/li&gt;&quot;; &#125; //显示到页面 $(&quot;.news_list&quot;).append(titles); //将请求标记设置为true send = true; &#125; &#125;); &#125;&lt;/script&gt; java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import com.fasterxml.jackson.databind.ObjectMapper;import com.github.pagehelper.Page;import com.itheima.service.NewsService;import com.itheima.service.impl.NewsServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/newsServlet&quot;)public class NewsServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置请求和响应的编码 req.setCharacterEncoding(&quot;UTF-8&quot;); resp.setContentType(&quot;text/html;charset=UTF-8&quot;); //1.获取请求参数 String start = req.getParameter(&quot;start&quot;); String pageSize = req.getParameter(&quot;pageSize&quot;); //2.根据当前页码和每页显示的条数来调用业务层的查询方法，得到分页Page对象 NewsService service = new NewsServiceImpl(); Page page = service.pageQuery(Integer.parseInt(start), Integer.parseInt(pageSize)); //3.将得到的数据转为JSON String json = new ObjectMapper().writeValueAsString(page); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //4.将数据响应给客户端 resp.getWriter().write(json); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125;&#125; 4.4、点击按钮分页 案例效果和环境准备 按钮效果 环境准备 使用已完善的ajax3项目 复制index.html更名为index2.html，并去掉原js中的方法 案例的分析 页面 1.引入分页插件的样式文件和 js 文件。 定义当前页码和每页显示的条数。 调用查询数据的函数。 定义请求查询分页数据的函数，发起 AJAX 异步请求。 为分页按钮区域设置页数参数(总页数和当前页)。 为分页按钮绑定单击事件,完成上一页下一页查询功能。 服务器 获取请求参数。 根据当前页码和每页显示的条数，调用业务层的方法，得到分页 Page 对象 封装 PageInfo 对象。 将得到的数据转为 json。 将数据响应给客户端。 案例的实现 html页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;script&gt; //1.定义当前页码和每页显示的条数 let start = 1; let pageSize = 10; //2.调用查询数据的方法 queryByPage(start,pageSize); //3.定义请求查询分页数据的函数，发起AJAX异步请求，将数据显示到页面 function queryByPage(start,pageSize) &#123; $.ajax(&#123; //请求的资源路径 url:&quot;newsServlet2&quot;, //请求的参数 data:&#123;&quot;start&quot;:start,&quot;pageSize&quot;:pageSize&#125;, //请求的方式 type:&quot;POST&quot;, //响应数据形式 dataType:&quot;json&quot;, //请求成功后的回调函数 success:function (pageInfo) &#123; //将数据显示到页面 let titles = &quot;&quot;; for(let i = 0; i &lt; pageInfo.list.length; i++) &#123; titles += &quot;&lt;li&gt;\\n&quot; + &quot; &lt;div class=\\&quot;title-box\\&quot;&gt;\\n&quot; + &quot; &lt;a href=\\&quot;#\\&quot; class=\\&quot;link\\&quot;&gt;\\n&quot; + pageInfo.list[i].title + &quot; &lt;hr&gt;\\n&quot; + &quot; &lt;/a&gt;\\n&quot; + &quot; &lt;/div&gt;\\n&quot; + &quot; &lt;/li&gt;&quot;; &#125; $(&quot;.news_list&quot;).html(titles); //4.为分页按钮区域设置页数参数（总页数和当前页） $(&quot;#light-pagination&quot;).pagination(&#123; pages:pageInfo.pages, currentPage:pageInfo.pageNum &#125;); //5.为分页按钮绑定单击事件,完成上一页下一页查询功能 $(&quot;#light-pagination .page-link&quot;).click(function () &#123; //获取点击按钮的文本内容 let page = $(this).html(); //如果点击的是Prev，调用查询方法，查询当前页的上一页数据 if(page == &quot;Prev&quot;) &#123; queryByPage(pageInfo.pageNum - 1,pageSize); &#125;else if (page == &quot;Next&quot;) &#123; //如果点击的是Next，调用查询方法，查询当前页的下一页数据 queryByPage(pageInfo.pageNum + 1,pageSize); &#125; else &#123; //调用查询方法，查询当前页的数据 queryByPage(page,pageSize); &#125; &#125;); &#125; &#125;); &#125;&lt;/script&gt; Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import com.fasterxml.jackson.databind.ObjectMapper;import com.github.pagehelper.Page;import com.github.pagehelper.PageInfo;import com.itheima.bean.News;import com.itheima.service.NewsService;import com.itheima.service.impl.NewsServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@WebServlet(&quot;/newsServlet2&quot;)public class NewsServlet2 extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置请求和响应的编码 req.setCharacterEncoding(&quot;UTF-8&quot;); resp.setContentType(&quot;text/html;charset=UTF-8&quot;); //1.获取请求参数 String start = req.getParameter(&quot;start&quot;); String pageSize = req.getParameter(&quot;pageSize&quot;); //2.根据当前页码和每页显示的条数来调用业务层的查询方法，得到分页Page对象 NewsService service = new NewsServiceImpl(); Page page = service.pageQuery(Integer.parseInt(start), Integer.parseInt(pageSize)); //3.封装PageInfo对象 PageInfo&lt;List&lt;News&gt;&gt; info = new PageInfo&lt;&gt;(page); //4.将得到的数据转为JSON String json = new ObjectMapper().writeValueAsString(info); //5.将数据响应给客户端 resp.getWriter().write(json); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125;&#125;","path":"2022/04/03/Js之Ajax笔记（十五）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript之ES6语法笔记（十四）","text":"ES6语法ES6相关概念（★★）什么是ES6ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范。 为什么使用 ES6 ?每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript语言本身也有一些令人不满意的地方。 变量提升特性增加了程序运行时的不可预测性 语法过于松散，实现相同的功能，不同的人可能会写出不同的代码 ES6新增语法let（★★★）ES6中新增了用于声明变量的关键字 let声明的变量只在所处于的块级有效1234 if (true) &#123; let a = 10; &#125;console.log(a) // a is not defined 注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。 不存在变量提升12console.log(a); // a is not defined let a = 20; 暂时性死区利用let声明的变量会绑定在这个块级作用域，不会受外界的影响 12345var tmp = 123;if (true) &#123; tmp = &#x27;abc&#x27;; let tmp; &#125; 经典面试题123456789var arr = [];for (var i = 0; i &lt; 2; i++) &#123; arr[i] = function () &#123; console.log(i); &#125;&#125;arr[0]();arr[1](); 经典面试题图解：此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。 123456789let arr = [];for (let i = 0; i &lt; 2; i++) &#123; arr[i] = function () &#123; console.log(i); &#125;&#125;arr[0]();arr[1](); 经典面试题图解：此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值. 小结 let关键字就是用来声明变量的 使用let关键字声明的变量具有块级作用域 在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的 防止循环变量变成全局变量 使用let关键字声明的变量没有变量提升 使用let关键字声明的变量具有暂时性死区特性 const（★★★）声明常量，常量就是值（内存地址）不能变化的量 具有块级作用域1234 if (true) &#123; const a = 10; &#125;console.log(a) // a is not defined 声明常量时必须赋值1const PI; // Missing initializer in const declaration 常量赋值后，值不能修改12345678const PI = 3.14;PI = 100; // Assignment to constant variable.const ary = [100, 200];ary[0] = &#x27;a&#x27;;ary[1] = &#x27;b&#x27;;console.log(ary); // [&#x27;a&#x27;, &#x27;b&#x27;]; ary = [&#x27;a&#x27;, &#x27;b&#x27;]; // Assignment to constant variable. 小结 const声明的变量是一个常量 既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值 声明 const时候必须要给定值 let、const、var 的区别 使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象 使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升 使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值 解构赋值（★★★）ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构 数组解构12345 let [a, b, c] = [1, 2, 3]; console.log(a)//1 console.log(b)//2 console.log(c)//3//如果解构不成功，变量的值为undefined 对象解构123456789let person = &#123; name: &#x27;zhangsan&#x27;, age: 20 &#125;; let &#123; name, age &#125; = person;console.log(name); // &#x27;zhangsan&#x27; console.log(age); // 20let &#123;name: myName, age: myAge&#125; = person; // myName myAge 属于别名console.log(myName); // &#x27;zhangsan&#x27; console.log(myAge); // 20 小结 解构赋值就是把数据结构分解，然后给变量进行赋值 如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined 数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开 利用解构赋值能够让我们方便的去取对象中的属性跟方法 箭头函数（★★★）ES6中新增的定义函数的方式。 12() =&gt; &#123;&#125; //()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；&#123;&#125;：函数体const fn = () =&gt; &#123;&#125;//代表把一个函数赋值给fn 函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号 123456function sum(num1, num2) &#123; return num1 + num2; &#125;//es6写法const sum = (num1, num2) =&gt; num1 + num2; 如果形参只有一个，可以省略小括号 123456 function fn (v) &#123; return v; &#125; //es6写法 const fn = v =&gt; v; 箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this 12345678910const obj = &#123; name: &#x27;张三&#x27;&#125; function fn () &#123; console.log(this);//this 指向 是obj对象 return () =&gt; &#123; console.log(this);//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象 &#125; &#125; const resFn = fn.call(obj); resFn(); 小结 箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁 箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题 面试题12345678910var age = 100;var obj = &#123; age: 20, say: () =&gt; &#123; alert(this.age) &#125;&#125;obj.say();//箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域 剩余参数（★★）剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数 123456function sum (first, ...args) &#123; console.log(first); // 10 console.log(args); // [20, 30] &#125; sum(10, 20, 30) 剩余参数和解构配合使用12345let students = [&#x27;wangwu&#x27;, &#x27;zhangsan&#x27;, &#x27;lisi&#x27;];let [s1, ...s2] = students; console.log(s1); // &#x27;wangwu&#x27; console.log(s2); // [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;] ES6 的内置对象扩展Array 的扩展方法（★★）扩展运算符（展开语法）扩展运算符可以将数组或者对象转为用逗号分隔的参数序列 1234let ary = [1, 2, 3];...ary // 1, 2, 3console.log(...ary); // 1 2 3,相当于下面的代码console.log(1,2,3); 扩展运算符可以应用于合并数组123456// 方法一 let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; // 方法二 ary1.push(...ary2); 将类数组或可遍历对象转换为真正的数组12let oDivs = document.getElementsByTagName(&#x27;div&#x27;); oDivs = [...oDivs]; 构造函数方法：Array.from()将伪数组或可遍历对象转换为真正的数组 123456789//定义一个集合let arrayLike = &#123; &#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#x27;b&#x27;, &#x27;2&#x27;: &#x27;c&#x27;, length: 3&#125;; //转成数组let arr2 = Array.from(arrayLike); // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组 1234567let arrayLike = &#123; &quot;0&quot;: 1, &quot;1&quot;: 2, &quot;length&quot;: 2&#125;let newAry = Array.from(arrayLike, item =&gt; item *2)//[2,4] 注意：如果是对象，那么属性需要写对应的索引 实例方法：find()用于找出第一个符合条件的数组成员，如果没有找到返回undefined 123456789let ary = [&#123; id: 1, name: &#x27;张三&#x27; &#125;, &#123; id: 2, name: &#x27;李四&#x27; &#125;]; let target = ary.find((item, index) =&gt; item.id == 2);//找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个 实例方法：findIndex()用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1 123let ary = [1, 5, 10, 15];let index = ary.findIndex((value, index) =&gt; value &gt; 9); console.log(index); // 2 实例方法：includes()判断某个数组是否包含给定的值，返回布尔值。 123[1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false String 的扩展方法模板字符串（★★★）ES6新增的创建字符串的方式，使用反引号定义 12let name = `zhangsan`; 模板字符串中可以解析变量12let name = &#x27;张三&#x27;; let sayHello = `hello,my name is $&#123;name&#125;`; // hello, my name is zhangsan 模板字符串中可以换行1234567891011let result = &#123; name: &#x27;zhangsan&#x27;, age: 20, sex: &#x27;男&#x27; &#125; let html = ` &lt;div&gt; &lt;span&gt;$&#123;result.name&#125;&lt;/span&gt; &lt;span&gt;$&#123;result.age&#125;&lt;/span&gt; &lt;span&gt;$&#123;result.sex&#125;&lt;/span&gt;&lt;/div&gt; `; 在模板字符串中可以调用函数123456const sayHello = function () &#123; return &#x27;哈哈哈哈 追不到我吧 我就是这么强大&#x27;; &#125;; let greet = `$&#123;sayHello()&#125; 哈哈哈哈`; console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈 实例方法：startsWith() 和 endsWith() startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值 endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值 1234let str = &#x27;Hello world!&#x27;;str.startsWith(&#x27;Hello&#x27;) // true str.endsWith(&#x27;!&#x27;) // true 实例方法：repeat()repeat方法表示将原字符串重复n次，返回一个新字符串 12&#x27;x&#x27;.repeat(3) // &quot;xxx&quot; &#x27;hello&#x27;.repeat(2) // &quot;hellohello&quot; Set 数据结构（★★）ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成 Set 数据结构 1const s = new Set(); Set函数可以接受一个数组作为参数，用来初始化。 12const set = new Set([1, 2, 3, 4, 4]);//&#123;1, 2, 3, 4&#125; 实例方法 add(value)：添加某个值，返回 Set 结构本身 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功 has(value)：返回一个布尔值，表示该值是否为 Set 的成员 clear()：清除所有成员，没有返回值 123456const s = new Set();s.add(1).add(2).add(3); // 向 set 结构中添加值 s.delete(2) // 删除 set 结构中的2值 s.has(1) // 表示 set 结构中是否有1这个值 返回布尔值 s.clear() // 清除 set 结构中的所有值//注意：删除的是元素的值，不是代表的索引 遍历Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 12s.forEach(value =&gt; console.log(value))","path":"2022/04/03/Js之面向对象笔记（十四）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript之正则表达式笔记（十三）","text":"1.正则表达式概述1.1什么是正则表达式正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。 正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 其他语言也会使用正则表达式，本阶段我们主要是利用JavaScript 正则表达式完成表单验证。 1.2 正则表达式的特点 灵活性、逻辑性和功能性非常的强。 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。比如：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$ 实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式. 比如用户名: &#x2F;^[a-z0-9_-]{3,16}$&#x2F; 2.正则表达式在js中的使用2.1正则表达式的创建在 JavaScript 中，可以通过两种方式创建一个正则表达式。 方式一：通过调用RegExp对象的构造函数创建 12var regexp = new RegExp(/123/);console.log(regexp); 方式二：利用字面量创建 正则表达式 1var rg = /123/; 2.2测试正则表达式test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。 123var rg = /123/;console.log(rg.test(123));//匹配字符中是否出现123 出现结果为trueconsole.log(rg.test(&#x27;abc&#x27;));//匹配字符中是否出现123 未出现结果为false 3.正则表达式中的特殊字符3.1正则表达式的组成一个正则表达式可以由简单的字符构成，比如 &#x2F;abc&#x2F;，也可以是简单和特殊字符的组合，比如 &#x2F;ab*c&#x2F; 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。 特殊字符非常多，可以参考： MDN jQuery 手册：正则表达式部分 [正则测试工具]( &lt;http://tool.oschina.net/regex) 3.2边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 边界符 说明 ^ 表示匹配行首的文本（以谁开始） $ 表示匹配行尾的文本（以谁结束） 如果 ^和 $ 在一起，表示必须是精确匹配。 12345678910111213141516var rg = /abc/; // 正则表达式里面不需要加引号 不管是数字型还是字符串型// /abc/ 只要包含有abc这个字符串返回的都是trueconsole.log(rg.test(&#x27;abc&#x27;));console.log(rg.test(&#x27;abcd&#x27;));console.log(rg.test(&#x27;aabcd&#x27;));console.log(&#x27;---------------------------&#x27;);var reg = /^abc/;console.log(reg.test(&#x27;abc&#x27;)); // trueconsole.log(reg.test(&#x27;abcd&#x27;)); // trueconsole.log(reg.test(&#x27;aabcd&#x27;)); // falseconsole.log(&#x27;---------------------------&#x27;);var reg1 = /^abc$/; // 精确匹配 要求必须是 abc字符串才符合规范console.log(reg1.test(&#x27;abc&#x27;)); // trueconsole.log(reg1.test(&#x27;abcd&#x27;)); // falseconsole.log(reg1.test(&#x27;aabcd&#x27;)); // falseconsole.log(reg1.test(&#x27;abcabc&#x27;)); // false 3.3字符类字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。 3.3.1 [] 方括号表示有一系列字符可供选择，只要匹配其中一个就可以了 1234567891011121314151617181920212223242526var rg = /[abc]/; // 只要包含有a 或者 包含有b 或者包含有c 都返回为trueconsole.log(rg.test(&#x27;andy&#x27;));//trueconsole.log(rg.test(&#x27;baby&#x27;));//trueconsole.log(rg.test(&#x27;color&#x27;));//trueconsole.log(rg.test(&#x27;red&#x27;));//falsevar rg1 = /^[abc]$/; // 三选一 只有是a 或者是 b 或者是c 这三个字母才返回 trueconsole.log(rg1.test(&#x27;aa&#x27;));//falseconsole.log(rg1.test(&#x27;a&#x27;));//trueconsole.log(rg1.test(&#x27;b&#x27;));//trueconsole.log(rg1.test(&#x27;c&#x27;));//trueconsole.log(rg1.test(&#x27;abc&#x27;));//true----------------------------------------------------------------------------------var reg = /^[a-z]$/ //26个英文字母任何一个字母返回 true - 表示的是a 到z 的范围 console.log(reg.test(&#x27;a&#x27;));//trueconsole.log(reg.test(&#x27;z&#x27;));//trueconsole.log(reg.test(&#x27;A&#x27;));//false-----------------------------------------------------------------------------------//字符组合var reg1 = /^[a-zA-Z0-9]$/; // 26个英文字母(大写和小写都可以)任何一个字母返回 true ------------------------------------------------------------------------------------//取反 方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。var reg2 = /^[^a-zA-Z0-9]$/;console.log(reg2.test(&#x27;a&#x27;));//falseconsole.log(reg2.test(&#x27;B&#x27;));//falseconsole.log(reg2.test(8));//falseconsole.log(reg2.test(&#x27;!&#x27;));//true 3.3.2量词符量词符用来设定某个模式出现的次数。 量词 说明 * 重复0次或更多次 + 重复1次或更多次 ? 重复0次或1次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 3.3.3用户名表单验证功能需求: 如果用户名输入合法, 则后面提示信息为: 用户名合法,并且颜色为绿色 如果用户名输入不合法, 则后面提示信息为: 用户名不符合规范, 并且颜色为红色 分析: 用户名只能为英文字母,数字,下划线或者短横线组成, 并且用户名长度为6~16位. 首先准备好这种正则表达式模式&#x2F;$[a-zA-Z0-9-_]{6,16}^&#x2F; 当表单失去焦点就开始验证. 如果符合正则规范, 则让后面的span标签添加 right类. 如果不符合正则规范, 则让后面的span标签添加 wrong类. 123456789101112131415161718&lt;input type=&quot;text&quot; class=&quot;uname&quot;&gt; &lt;span&gt;请输入用户名&lt;/span&gt; &lt;script&gt; // 量词是设定某个模式出现的次数 var reg = /^[a-zA-Z0-9_-]&#123;6,16&#125;$/; // 这个模式用户只能输入英文字母 数字 下划线 中划线 var uname = document.querySelector(&#x27;.uname&#x27;); var span = document.querySelector(&#x27;span&#x27;); uname.onblur = function() &#123; if (reg.test(this.value)) &#123; console.log(&#x27;正确的&#x27;); span.className = &#x27;right&#x27;; span.innerHTML = &#x27;用户名格式输入正确&#x27;; &#125; else &#123; console.log(&#x27;错误的&#x27;); span.className = &#x27;wrong&#x27;; span.innerHTML = &#x27;用户名格式输入不正确&#x27;; &#125; &#125;&lt;/script&gt; 3.3.4 括号总结1.大括号 量词符. 里面表示重复次数 2.中括号 字符集合。匹配方括号中的任意字符. 3.小括号表示优先级 正则表达式在线测试 3.4预定义类预定义类指的是某些常见模式的简写方式. 案例:验证座机号码 12var reg = /^\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;$/;var reg = /^\\d&#123;3,4&#125;-\\d&#123;7,8&#125;$/; 表单验证案例 1234567891011//手机号验证:/^1[3|4|5|7|8][0-9]&#123;9&#125;$/;//验证通过与不通过更换元素的类名与元素中的内容 if (reg.test(this.value)) &#123; // console.log(&#x27;正确的&#x27;); this.nextElementSibling.className = &#x27;success&#x27;; this.nextElementSibling.innerHTML = &#x27;&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确&#x27;; &#125; else &#123; // console.log(&#x27;不正确&#x27;); this.nextElementSibling.className = &#x27;error&#x27;; this.nextElementSibling.innerHTML = &#x27;&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt;格式不正确,请从新输入 &#x27;; &#125; 12345678910111213141516//QQ号验证: /^[1-9]\\d&#123;4,&#125;$/; //昵称验证:/^[\\u4e00-\\u9fa5]&#123;2,8&#125;$///验证通过与不通过更换元素的类名与元素中的内容 ,将上一步的匹配代码进行封装,多次调用即可 function regexp(ele, reg) &#123; ele.onblur = function() &#123; if (reg.test(this.value)) &#123; // console.log(&#x27;正确的&#x27;); this.nextElementSibling.className = &#x27;success&#x27;; this.nextElementSibling.innerHTML = &#x27;&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 恭喜您输入正确&#x27;; &#125; else &#123; // console.log(&#x27;不正确&#x27;); this.nextElementSibling.className = &#x27;error&#x27;; this.nextElementSibling.innerHTML = &#x27;&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt; 格式不正确,请从新输入 &#x27;; &#125; &#125; &#125;; 12//密码验证:/^[a-zA-Z0-9_-]&#123;6,16&#125;$///再次输入密码只需匹配与上次输入的密码值 是否一致 3.5正则替换replacereplace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。 12345678910111213141516var str = &#x27;andy和red&#x27;;var newStr = str.replace(&#x27;andy&#x27;, &#x27;baby&#x27;);console.log(newStr)//baby和red//等同于 此处的andy可以写在正则表达式内var newStr2 = str.replace(/andy/, &#x27;baby&#x27;);console.log(newStr2)//baby和red//全部替换var str = &#x27;abcabc&#x27;var nStr = str.replace(/a/,&#x27;哈哈&#x27;)console.log(nStr) //哈哈bcabc//全部替换gvar nStr = str.replace(/a/a,&#x27;哈哈&#x27;)console.log(nStr) //哈哈bc哈哈bc//忽略大小写ivar str = &#x27;aAbcAba&#x27;;var newStr = str.replace(/a/gi,&#x27;哈哈&#x27;)//&quot;哈哈哈哈bc哈哈b哈哈&quot; 案例:过滤敏感词汇 12345678910&lt;textarea name=&quot;&quot; id=&quot;message&quot;&gt;&lt;/textarea&gt; &lt;button&gt;提交&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var text = document.querySelector(&#x27;textarea&#x27;); var btn = document.querySelector(&#x27;button&#x27;); var div = document.querySelector(&#x27;div&#x27;); btn.onclick = function() &#123; div.innerHTML = text.value.replace(/激情|gay/g, &#x27;**&#x27;); &#125;&lt;/script&gt;","path":"2022/04/03/Js之面向对象笔记（十三）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript之函数的定义和调用笔记（十二）","text":"1.函数的定义和调用1.1函数的定义方式 方式1 函数声明方式 function 关键字 (命名函数) 1function fn()&#123;&#125; 方式2 函数表达式(匿名函数) 1var fn = function()&#123;&#125; 方式3 new Function() 12345678910var f = new Function(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;console.log(a + b)&#x27;);f(1, 2);var fn = new Function(&#x27;参数1&#x27;,&#x27;参数2&#x27;..., &#x27;函数体&#x27;)注意/*Function 里面参数都必须是字符串格式第三种方式执行效率低，也不方便书写，因此较少使用所有函数都是 Function 的实例(对象) 函数也属于对象*/ 1.2函数的调用1234567891011121314151617181920212223/* 1. 普通函数 */function fn() &#123; console.log(&#x27;人生的巅峰&#x27;);&#125; fn(); /* 2. 对象的方法 */var o = &#123; sayHi: function() &#123; console.log(&#x27;人生的巅峰&#x27;); &#125;&#125;o.sayHi();/* 3. 构造函数*/function Star() &#123;&#125;;new Star();/* 4. 绑定事件函数*/ btn.onclick = function() &#123;&#125;; // 点击了按钮就可以调用这个函数/* 5. 定时器函数*/setInterval(function() &#123;&#125;, 1000); 这个函数是定时器自动1秒钟调用一次/* 6. 立即执行函数(自调用函数)*/(function() &#123; console.log(&#x27;人生的巅峰&#x27;);&#125;)(); 2.this2.1函数内部的this指向这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同 一般指向我们的调用者. 2.2改变函数内部 this 指向2.2.1 call方法call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向 应用场景: 经常做继承. 123456789var o = &#123; name: &#x27;andy&#x27;&#125; function fn(a, b) &#123; console.log(this); console.log(a+b)&#125;;fn(1,2)// 此时的this指向的是window 运行结果为3fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3 以上代码运行结果为: 2.2.2 apply方法apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。 应用场景: 经常跟数组有关系 123456789var o = &#123; name: &#x27;andy&#x27;&#125; function fn(a, b) &#123; console.log(this); console.log(a+b)&#125;;fn()// 此时的this指向的是window 运行结果为3fn.apply(o,[1,2])//此时的this指向的是对象o,参数使用数组传递 运行结果为3 2.2.3 bind方法bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数 如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind 应用场景:不调用函数,但是还想改变this指向 12345678910 var o = &#123; name: &#x27;andy&#x27; &#125;;function fn(a, b) &#123; console.log(this); console.log(a + b);&#125;;var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数f();//调用新函数 this指向的是对象o 参数使用逗号隔开 2.2.4 call、apply、bind三者的异同 共同点 : 都可以改变this指向 不同点: call 和 apply 会调用函数, 并且改变函数内部this指向. call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递 bind 不会调用函数, 可以改变函数内部this指向. 应用场景 call 经常做继承. apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值 bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. 3.严格模式3.1什么是严格模式JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。 严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。 严格模式对正常的 JavaScript 语义做了一些更改： 1.消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。 2.消除代码运行的一些不安全之处，保证代码运行的安全。 3.提高编译器效率，增加运行速度。 4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名 3.2开启严格模式严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。 情况一 :为脚本开启严格模式 有的 script 脚本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他script 脚本文件。 12345678910111213(function ()&#123; //在当前的这个自调用函数中有开启严格模式，当前函数之外还是普通模式 &quot;use strict&quot;; var num = 10; function fn() &#123;&#125;&#125;)();//或者 &lt;script&gt; &quot;use strict&quot;; //当前script标签开启了严格模式&lt;/script&gt;&lt;script&gt; //当前script标签未开启严格模式&lt;/script&gt; 情况二: 为函数开启严格模式 要给某个函数开启严格模式，需要把“use strict”; (或 ‘use strict’; ) 声明放在函数体所有语句之前。 12345function fn()&#123; &quot;use strict&quot;; return &quot;123&quot;;&#125; //当前fn函数开启了严格模式 3.3严格模式中的变化严格模式对 Javascript 的语法和行为，都做了一些改变。 12345678910111213141516171819202122&#x27;use strict&#x27;num = 10 console.log(num)//严格模式后使用未声明的变量--------------------------------------------------------------------------------var num2 = 1;delete num2;//严格模式不允许删除变量--------------------------------------------------------------------------------function fn() &#123; console.log(this); // 严格模式下全局作用域中函数中的 this 是 undefined&#125;fn(); ---------------------------------------------------------------------------------function Star() &#123; this.sex = &#x27;男&#x27;;&#125;// Star();严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错.var ldh = new Star();console.log(ldh.sex);----------------------------------------------------------------------------------setTimeout(function() &#123; console.log(this); //严格模式下，定时器 this 还是指向 window&#125;, 2000); 更多严格模式要求参考 4.高阶函数高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。 此时fn 就是一个高阶函数 函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。 同理函数也可以作为返回值传递回来 5.闭包5.1变量的作用域复习变量根据作用域的不同分为两种：全局变量和局部变量。 函数内部可以使用全局变量。 函数外部不可以使用局部变量。 当函数执行完毕，本作用域内的局部变量会销毁。 5.2什么是闭包闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。 5.3闭包的作用作用：延伸变量的作用范围。 123456789 function fn() &#123; var num = 10; function fun() &#123; console.log(num); &#125; return fun; &#125;var f = fn();f(); 5.4闭包的案例 利用闭包的方式得到当前li 的索引号 123456789for (var i = 0; i &lt; lis.length; i++) &#123;// 利用for循环创建了4个立即执行函数// 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量(function(i) &#123; lis[i].onclick = function() &#123; console.log(i); &#125; &#125;)(i);&#125; 闭包应用-3秒钟之后,打印所有li元素的内容 1234567 for (var i = 0; i &lt; lis.length; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(lis[i].innerHTML); &#125;, 3000) &#125;)(i);&#125; 闭包应用-计算打车价格 12345678910111213141516171819202122232425/*需求分析打车起步价13(3公里内), 之后每多一公里增加 5块钱. 用户输入公里数就可以计算打车价格如果有拥堵情况,总价格多收取10块钱拥堵费*/ var car = (function() &#123; var start = 13; // 起步价 局部变量 var total = 0; // 总价 局部变量 return &#123; // 正常的总价 price: function(n) &#123; if (n &lt;= 3) &#123; total = start; &#125; else &#123; total = start + (n - 3) * 5 &#125; return total; &#125;, // 拥堵之后的费用 yd: function(flag) &#123; return flag ? total + 10 : total; &#125; &#125; &#125;)();console.log(car.price(5)); // 23console.log(car.yd(true)); // 33 5.5案例1234567891011121314151617181920212223 var name = &quot;The Window&quot;; var object = &#123; name: &quot;My Object&quot;, getNameFunc: function() &#123; return function() &#123; return this.name; &#125;; &#125; &#125;;console.log(object.getNameFunc()())-----------------------------------------------------------------------------------var name = &quot;The Window&quot;; var object = &#123; name: &quot;My Object&quot;, getNameFunc: function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 6.递归6.1什么是递归递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数 注意：递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。 6.2利用递归求1~n的阶乘12345678//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n function fn(n) &#123; if (n == 1) &#123; //结束条件 return 1; &#125; return n * fn(n - 1); &#125; console.log(fn(3)); 6.3利用递归求斐波那契数列12345678910// 利用递归函数求斐波那契数列(兔子序列) 1、1、2、3、5、8、13、21...// 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值// 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值function fb(n) &#123; if (n === 1 || n === 2) &#123; return 1; &#125; return fb(n - 1) + fb(n - 2);&#125;console.log(fb(3)); 6.4利用递归遍历数据123456789101112131415161718192021222324252627282930313233343536373839404142// 我们想要做输入id号,就可以返回的数据对象 var data = [&#123; id: 1, name: &#x27;家电&#x27;, goods: [&#123; id: 11, gname: &#x27;冰箱&#x27;, goods: [&#123; id: 111, gname: &#x27;海尔&#x27; &#125;, &#123; id: 112, gname: &#x27;美的&#x27; &#125;, ] &#125;, &#123; id: 12, gname: &#x27;洗衣机&#x27; &#125;] &#125;, &#123; id: 2, name: &#x27;服饰&#x27;&#125;];//1.利用 forEach 去遍历里面的每一个对象 function getID(json, id) &#123; var o = &#123;&#125;; json.forEach(function(item) &#123; // console.log(item); // 2个数组元素 if (item.id == id) &#123; // console.log(item); o = item; return o; // 2. 我们想要得里层的数据 11 12 可以利用递归函数 // 里面应该有goods这个数组并且数组的长度不为 0 &#125; else if (item.goods &amp;&amp; item.goods.length &gt; 0) &#123; o = getID(item.goods, id); &#125; &#125;); return o;&#125;","path":"2022/04/03/Js之面向对象笔记（十二）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript之构造函数和原型笔记（十一）","text":"1.构造函数和原型1.1对象的三种创建方式–复习 字面量方式 1var obj = &#123;&#125;; new关键字 1var obj = new Object(); 构造函数方式 12345function Person(name,age)&#123; this.name = name; this.age = age;&#125;var obj = new Person(&#x27;zs&#x27;,12); 1.2静态成员和实例成员1.2.1实例成员实例成员就是构造函数内部通过this添加的成员 如下列代码中uname age sing 就是实例成员,实例成员只能通过实例化的对象来访问 123456789 function Star(uname, age) &#123; this.uname = uname; this.age = age; this.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;); &#125;&#125;var ldh = new Star(&#x27;刘德华&#x27;, 18);console.log(ldh.uname);//实例成员只能通过实例化的对象来访问 1.2.2静态成员静态成员 在构造函数本身上添加的成员 如下列代码中 sex 就是静态成员,静态成员只能通过构造函数来访问 12345678910 function Star(uname, age) &#123; this.uname = uname; this.age = age; this.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;); &#125;&#125;Star.sex = &#x27;男&#x27;;var ldh = new Star(&#x27;刘德华&#x27;, 18);console.log(Star.sex);//静态成员只能通过构造函数来访问 1.3构造函数的问题构造函数方法很好用，但是存在浪费内存的问题。 1.4构造函数原型prototype构造函数通过原型分配的函数是所有对象所共享的。 JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 1234567891011function Star(uname, age) &#123; this.uname = uname; this.age = age;&#125;Star.prototype.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;);&#125;var ldh = new Star(&#x27;刘德华&#x27;, 18);var zxy = new Star(&#x27;张学友&#x27;, 19);ldh.sing();//我会唱歌zxy.sing();//我会唱歌 1.5对象原型123对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。__proto__对象原型和原型对象 prototype 是等价的__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype 1.6constructor构造函数123对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数如: 1234567891011121314151617 function Star(uname, age) &#123; this.uname = uname; this.age = age; &#125; // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数 Star.prototype = &#123; // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 constructor: Star, // 手动设置指回原来的构造函数 sing: function() &#123; console.log(&#x27;我会唱歌&#x27;); &#125;, movie: function() &#123; console.log(&#x27;我会演电影&#x27;); &#125;&#125;var zxy = new Star(&#x27;张学友&#x27;, 19);console.log(zxy) 以上代码运行结果,设置constructor属性如图: 如果未设置constructor属性,如图: 1.7原型链​ 每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。 1.8构造函数实例和原型对象三角关系1231.构造函数的prototype属性指向了构造函数原型对象2.实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数 1.9原型链和成员的查找机制任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有__proto__属性,这样一层一层往上找,就形成了一条链,我们称此为原型链; 12345当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。如果还没有就查找原型对象的原型（Object的原型对象）。依此类推一直找到 Object 为止（null）。__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。 1.10原型对象中this指向构造函数中的this和原型对象的this,都指向我们new出来的实例对象 12345678910111213function Star(uname, age) &#123; this.uname = uname; this.age = age;&#125;var that;Star.prototype.sing = function() &#123; console.log(&#x27;我会唱歌&#x27;); that = this;&#125;var ldh = new Star(&#x27;刘德华&#x27;, 18);// 1. 在构造函数中,里面this指向的是对象实例 ldhconsole.log(that === ldh);//true// 2.原型对象函数里面的this 指向的是 实例对象 ldh 1.11通过原型为数组扩展内置方法12345678Array.prototype.sum = function() &#123; var sum = 0; for (var i = 0; i &lt; this.length; i++) &#123; sum += this[i]; &#125; return sum;&#125;;//此时数组对象中已经存在sum()方法了 可以始终 数组.sum()进行数据的求 2.继承2.1call() call()可以调用函数 call()可以修改this的指向,使用call()的时候 参数一是修改后的this指向,参数2,参数3..使用逗号隔开连接 12345678 function fn(x, y) &#123; console.log(this); console.log(x + y);&#125; var o = &#123; name: &#x27;andy&#x27; &#125;; fn.call(o, 1, 2);//调用了函数此时的this指向了对象o, 2.2子构造函数继承父构造函数中的属性 先定义一个父构造函数 再定义一个子构造函数 子构造函数继承父构造函数的属性(使用call方法) 123456789101112131415 // 1. 父构造函数 function Father(uname, age) &#123; // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; &#125; // 2 .子构造函数 function Son(uname, age, score) &#123; // this 指向子构造函数的对象实例 3.使用call方式实现子继承父的属性 Father.call(this, uname, age); this.score = score;&#125;var son = new Son(&#x27;刘德华&#x27;, 18, 100);console.log(son); 2.3借用原型对象继承方法 先定义一个父构造函数 再定义一个子构造函数 子构造函数继承父构造函数的属性(使用call方法) 1234567891011121314151617181920212223242526// 1. 父构造函数function Father(uname, age) &#123; // this 指向父构造函数的对象实例 this.uname = uname; this.age = age;&#125;Father.prototype.money = function() &#123; console.log(100000); &#125;; // 2 .子构造函数 function Son(uname, age, score) &#123; // this 指向子构造函数的对象实例 Father.call(this, uname, age); this.score = score; &#125;// Son.prototype = Father.prototype; 这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化 Son.prototype = new Father(); // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 Son.prototype.constructor = Son; // 这个是子构造函数专门的方法 Son.prototype.exam = function() &#123; console.log(&#x27;孩子要考试&#x27;); &#125; var son = new Son(&#x27;刘德华&#x27;, 18, 100); console.log(son); 如上代码结果如图: 3.ES5新增方法3.1数组方法forEach遍历数组123456arr.forEach(function(value, index, array) &#123; //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组&#125;) //相当于数组遍历的 for循环 没有返回值 3.2数组方法filter过滤数组12345678var arr = [12, 66, 4, 88, 3, 7];var newArr = arr.filter(function(value, index,array) &#123; //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组 return value &gt;= 20;&#125;);console.log(newArr);//[66,88] //返回值是一个新数组 3.3数组方法some123456789some 查找数组中是否有满足条件的元素 var arr = [10, 30, 4]; var flag = arr.some(function(value,index,array) &#123; //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组 return value &lt; 3; &#125;);console.log(flag);//false返回值是布尔值,只要查找到满足条件的一个元素就立马终止循环 3.4筛选商品案例 定义数组对象数据 1234567891011121314151617var data = [&#123; id: 1, pname: &#x27;小米&#x27;, price: 3999 &#125;, &#123; id: 2, pname: &#x27;oppo&#x27;, price: 999 &#125;, &#123; id: 3, pname: &#x27;荣耀&#x27;, price: 1299 &#125;, &#123; id: 4, pname: &#x27;华为&#x27;, price: 1999 &#125;, ]; 使用forEach遍历数据并渲染到页面中 12345data.forEach(function(value) &#123; var tr = document.createElement(&#x27;tr&#x27;); tr.innerHTML = &#x27;&lt;td&gt;&#x27; + value.id + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + value.pname + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + value.price + &#x27;&lt;/td&gt;&#x27;; tbody.appendChild(tr); &#125;); 根据价格筛选数据 获取到搜索按钮并为其绑定点击事件 12search_price.addEventListener(&#x27;click&#x27;, function() &#123;&#125;); 使用filter将用户输入的价格信息筛选出来 12345678search_price.addEventListener(&#x27;click&#x27;, function() &#123; var newDate = data.filter(function(value) &#123; //start.value是开始区间 //end.value是结束的区间 return value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value; &#125;); console.log(newDate); &#125;); 将筛选出来的数据重新渲染到表格中 将渲染数据的逻辑封装到一个函数中 123456789function setDate(mydata) &#123; // 先清空原来tbody 里面的数据 tbody.innerHTML = &#x27;&#x27;; mydata.forEach(function(value) &#123; var tr = document.createElement(&#x27;tr&#x27;); tr.innerHTML = &#x27;&lt;td&gt;&#x27; + value.id + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + value.pname + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + value.price + &#x27;&lt;/td&gt;&#x27;; tbody.appendChild(tr); &#125;); &#125; 将筛选之后的数据重新渲染 12345678 search_price.addEventListener(&#x27;click&#x27;, function() &#123; var newDate = data.filter(function(value) &#123; return value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value; &#125;); console.log(newDate); // 把筛选完之后的对象渲染到页面中 setDate(newDate);&#125;); 根据商品名称筛选 获取用户输入的商品名称 为查询按钮绑定点击事件,将输入的商品名称与这个数据进行筛选 123456789101112 search_pro.addEventListener(&#x27;click&#x27;, function() &#123; var arr = []; data.some(function(value) &#123; if (value.pname === product.value) &#123; // console.log(value); arr.push(value); return true; // return 后面必须写true &#125; &#125;); // 把拿到的数据渲染到页面中 setDate(arr);&#125;) 3.5some和forEach区别 如果查询数组中唯一的元素, 用some方法更合适,在some 里面 遇到 return true 就是终止遍历 迭代效率更高 在forEach 里面 return 不会终止迭代 3.6trim方法去除字符串两端的空格1234var str = &#x27; hello &#x27;console.log(str.trim()） //hello 去除两端空格var str1 = &#x27; he l l o &#x27;console.log(str.trim()） //he l l o 去除两端空格 3.7获取对象的属性名Object.keys(对象) 获取到当前对象中的属性名 ，返回值是一个数组 12345678 var obj = &#123; id: 1, pname: &#x27;小米&#x27;, price: 1999, num: 2000&#125;;var result = Object.keys(obj)console.log(result)//[id，pname,price,num] 3.8Object.definePropertyObject.defineProperty设置或修改对象中的属性 123456Object.defineProperty(对象，修改或新增的属性名，&#123; value:修改或新增的属性的值, writable:true/false,//如果值为false 不允许修改这个属性值 enumerable: false,//enumerable 如果值为false 则不允许遍历 configurable: false //configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性&#125;)","path":"2022/04/03/Js之面向对象笔记（十一）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript之面向过程与面向对象笔记（十）","text":"1.面向过程与面向对象1.1面向过程 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。 1.2面向对象 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。 1.3面向过程与面向对象对比 面向过程 面向对象 优点 性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 缺点 不易维护、不易复用、不易扩展 性能比面向过程低 2.对象与类2.1对象对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 2.1.1创建对象123456789101112131415//以下代码是对对象的复习//字面量创建对象var ldh = &#123; name: &#x27;刘德华&#x27;, age: 18&#125;console.log(ldh);//构造函数创建对象 function Star(name, age) &#123; this.name = name; this.age = age; &#125;var ldh = new Star(&#x27;刘德华&#x27;, 18)//实例化对象console.log(ldh); 如上两行代码运行结果为: 2.2类 在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象 2.2.1创建类 语法: 123456//步骤1 使用class关键字class name &#123; // class body&#125; //步骤2使用定义的类创建实例 注意new关键字var xx = new name(); 示例 1234567891011// 1. 创建类 class 创建一个 明星类class Star &#123; // 类的共有属性放到 constructor 里面 constructor(name, age) &#123; this.name = name; this.age = age; &#125;&#125; // 2. 利用类创建对象 new var ldh = new Star(&#x27;刘德华&#x27;, 18); console.log(ldh); 以上代码运行结果: 通过结果我们可以看出,运行结果和使用构造函数方式一样 2.2.2类创建添加属性和方法123456789101112131415 // 1. 创建类 class 创建一个类class Star &#123; // 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数 constructor(uname, age) &#123; this.uname = uname; this.age = age; &#125;//-------------------------------------------&gt;注意,方法与方法之间不需要添加逗号 sing(song) &#123; console.log(this.uname + &#x27;唱&#x27; + song); &#125;&#125;// 2. 利用类创建对象 newvar ldh = new Star(&#x27;刘德华&#x27;, 18);console.log(ldh); // Star &#123;uname: &quot;刘德华&quot;, age: 18&#125;ldh.sing(&#x27;冰雨&#x27;); // 刘德华唱冰雨 以上代码运行结果: 注意哟: 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象 constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数 多个函数方法之间不需要添加逗号分隔 生成实例 new 不能省略 语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function 2.2.3类的继承 语法 1234567// 父类class Father&#123; &#125; // 子类继承父类class Son extends Father &#123; &#125; 示例 12345678910111213class Father &#123; constructor(surname) &#123; this.surname= surname; &#125; say() &#123; console.log(&#x27;你的姓是&#x27; + this.surname); &#125;&#125;class Son extends Father&#123; // 这样子类就继承了父类的属性和方法&#125;var damao= new Son(&#x27;刘&#x27;);damao.say(); //结果为 你的姓是刘 以上代码运行结果: 子类使用super关键字访问父类的方法 123456789101112131415161718//定义了父类class Father &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; sum() &#123; console.log(this.x + this.y); &#125; &#125;//子元素继承父类 class Son extends Father &#123; constructor(x, y) &#123; super(x, y); //使用super调用了父类中的构造函数 &#125; &#125; var son = new Son(1, 2); son.sum(); //结果为3 注意: 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则) 如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用 1234567891011121314151617181920212223242526 // 父类有加法方法 class Father &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; sum() &#123; console.log(this.x + this.y); &#125; &#125; // 子类继承父类加法方法 同时 扩展减法方法 class Son extends Father &#123; constructor(x, y) &#123; // 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到this之后会报错 super(x, y); this.x = x; this.y = y; &#125; subtract() &#123; console.log(this.x - this.y); &#125;&#125;var son = new Son(5, 3);son.subtract(); //2son.sum();//8 以上代码运行结果为: 时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用. constructor中的this指向的是new出来的实例对象 自定义的方法,一般也指向的new出来的实例对象 绑定事件之后this指向的就是触发事件的事件源 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象 3.面向对象版tab 栏切换3.1功能需求 点击 tab栏,可以切换效果. 点击 + 号, 可以添加 tab 项和内容项. 点击 x 号, 可以删除当前的tab项和内容项. 双击tab项文字或者内容项文字可以修改里面的文字内容 3.2案例准备 获取到标题元素 获取到内容元素 获取到删除的小按钮 x号 新建js文件,定义类,添加需要的属性方法(切换,删除,增加,修改) 时刻注意this的指向问题 3.3切换 为获取到的标题绑定点击事件,展示对应的内容区域,存储对应的索引 12this.lis[i].index = i;this.lis[i].onclick = this.toggleTab; 使用排他,实现只有一个元素的显示 1234567891011toggleTab() &#123; //将所有的标题与内容类样式全部移除 for (var i = 0; i &lt; this.lis.length; i++) &#123; this.lis[i].className = &#x27;&#x27;; this.sections[i].className = &#x27;&#x27;; &#125; //为当前的标题添加激活样式 this.className = &#x27;liactive&#x27;; //为当前的内容添加激活样式 that.sections[this.index].className = &#x27;conactive&#x27;; &#125; 3.4添加 为添加按钮+ 绑定点击事件 1this.add.onclick = this.addTab; 实现标题与内容的添加,做好排他处理 1234567891011addTab() &#123; that.clearClass(); // (1) 创建li元素和section元素 var random = Math.random(); var li = &#x27;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt; &lt;/span&gt;&lt;/li&gt;&#x27;; var section = &#x27;&lt;section class=&quot;conactive&quot;&gt;测试 &#x27; + random + &#x27;&lt;/section&gt;&#x27;; // (2) 把这两个元素追加到对应的父元素里面 that.ul.insertAdjacentHTML(&#x27;beforeend&#x27;, li); that.fsection.insertAdjacentHTML(&#x27;beforeend&#x27;, section); that.init(); &#125; 3.5删除 为元素的删除按钮x绑定点击事件 1this.remove[i].onclick = this.removeTab; 获取到点击的删除按钮的所在的父元素的所有,删除对应的标题与内容 123456789101112131415removeTab(e) &#123; e.stopPropagation(); // 阻止冒泡 防止触发li 的切换点击事件 var index = this.parentNode.index; console.log(index); // 根据索引号删除对应的li 和section remove()方法可以直接删除指定的元素 that.lis[index].remove(); that.sections[index].remove(); that.init(); // 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变 if (document.querySelector(&#x27;.liactive&#x27;)) return; // 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态 index--; // 手动调用我们的点击事件 不需要鼠标触发 that.lis[index] &amp;&amp; that.lis[index].click();&#125; 3.6编辑 为元素(标题与内容)绑定双击事件 12this.spans[i].ondblclick = this.editTab;this.sections[i].ondblclick = this.editTab; 在双击事件处理文本选中状态,修改内部DOM节点,实现新旧value值的传递 123456789101112131415161718192021editTab() &#123; var str = this.innerHTML; // 双击禁止选定文字 window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); // alert(11); this.innerHTML = &#x27;&lt;input type=&quot;text&quot; /&gt;&#x27;; var input = this.children[0]; input.value = str; input.select(); // 文本框里面的文字处于选定状态 // 当我们离开文本框就把文本框里面的值给span input.onblur = function() &#123; this.parentNode.innerHTML = this.value; &#125;; // 按下回车也可以把文本框里面的值给span input.onkeyup = function(e) &#123; if (e.keyCode === 13) &#123; // 手动调用表单失去焦点事件 不需要鼠标离开操作 this.blur(); &#125; &#125;&#125;","path":"2022/04/03/Js之面向对象笔记（十）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"jQuery快速入门笔记（九）","text":"目标： 能够说出4种常见的注册事件能够说出 on 绑定事件的优势能够说出 jQuery 事件委派的优点以及方式能够说出绑定事件与解绑事件能够说出 jQuery 对象的拷贝方法能够说出 jQuery 多库共存的2种方法能够使用 jQuery 插件 1.1. jQuery 事件注册​ jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下： 优点: 操作简单，且不用担心事件覆盖等问题。 缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。 语法 演示代码 1234567891011121314&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. 单个事件注册 $(&quot;div&quot;).click(function() &#123; $(this).css(&quot;background&quot;, &quot;purple&quot;); &#125;); $(&quot;div&quot;).mouseenter(function() &#123; $(this).css(&quot;background&quot;, &quot;skyblue&quot;); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; 1.2. jQuery 事件处理​ 因为普通注册事件方法的不足，jQuery又开发了多个处理方法，重点讲解如下： on(): 用于事件绑定，目前最好用的事件绑定方法 off(): 事件解绑 trigger() &#x2F; triggerHandler(): 事件触发 1.2.1 事件处理 on() 绑定事件​ 因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法bind() &#x2F; live() &#x2F; delegate() &#x2F; on()等，其中最好用的是: on() 语法 演示代码 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt;&lt;/ol&gt; &lt;script&gt; $(function() &#123; // (1) on可以绑定1个或者多个事件处理程序 // $(&quot;div&quot;).on(&#123; // mouseenter: function() &#123; // $(this).css(&quot;background&quot;, &quot;skyblue&quot;); // &#125;, // click: function() &#123; // $(this).css(&quot;background&quot;, &quot;purple&quot;); // &#125; // &#125;); $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() &#123; $(this).toggleClass(&quot;current&quot;); &#125;); // (2) on可以实现事件委托（委派） // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li // $(&quot;ul li&quot;).click(); $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123; alert(11); &#125;); // (3) on可以给未来动态创建的元素绑定事件 $(&quot;ol&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123; alert(11); &#125;) var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;); $(&quot;ol&quot;).append(li); &#125;) &lt;/script&gt;&lt;/body&gt; 1.2.2. 事件处理 off() 解绑事件​ 当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() &#x2F; undelegate() &#x2F; off() 等，甚至还有只触发一次的事件绑定方法 one()，在这里我们重点讲解一下 off() ; 语法 演示代码 1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;我是一个P标签&lt;/p&gt; &lt;script&gt; $(function() &#123; // 事件绑定 $(&quot;div&quot;).on(&#123; click: function() &#123; console.log(&quot;我点击了&quot;); &#125;, mouseover: function() &#123; console.log(&#x27;我鼠标经过了&#x27;); &#125; &#125;); $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123; alert(11); &#125;); // 1. 事件解绑 off // $(&quot;div&quot;).off(); // 这个是解除了div身上的所有事件 $(&quot;div&quot;).off(&quot;click&quot;); // 这个是解除了div身上的点击事件 $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;); // 2. one() 但是它只能触发事件一次 $(&quot;p&quot;).one(&quot;click&quot;, function() &#123; alert(11); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 1.2.4. 事件处理 trigger() 自动触发事件​ 有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ; 语法 演示代码 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;input type=&quot;text&quot;&gt; &lt;script&gt; $(function() &#123; // 绑定事件 $(&quot;div&quot;).on(&quot;click&quot;, function() &#123; alert(11); &#125;); // 自动触发事件 // 1. 元素.事件() // $(&quot;div&quot;).click();会触发元素的默认行为 // 2. 元素.trigger(&quot;事件&quot;) // $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为 $(&quot;input&quot;).trigger(&quot;focus&quot;); // 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为 $(&quot;input&quot;).on(&quot;focus&quot;, function() &#123; $(this).val(&quot;你好吗&quot;); &#125;); // 一个会获取焦点，一个不会 $(&quot;div&quot;).triggerHandler(&quot;click&quot;); // $(&quot;input&quot;).triggerHandler(&quot;focus&quot;); &#125;); &lt;/script&gt;&lt;/body&gt; 1.3. jQuery 事件对象​ jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。 语法 演示代码 12345678910111213141516&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(document).on(&quot;click&quot;, function() &#123; console.log(&quot;点击了document&quot;); &#125;) $(&quot;div&quot;).on(&quot;click&quot;, function(event) &#123; // console.log(event); console.log(&quot;点击了div&quot;); event.stopPropagation(); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 注意：jQuery中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。 1.4. jQuery 拷贝对象​ jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。 语法 演示代码 12345678910111213141516171819202122232425&lt;script&gt; $(function() &#123; // 1.合并数据 var targetObj = &#123;&#125;; var obj = &#123; id: 1, name: &quot;andy&quot; &#125;; // $.extend(target, obj); $.extend(targetObj, obj); console.log(targetObj); // 2. 会覆盖 targetObj 里面原来的数据 var targetObj = &#123; id: 0 &#125;; var obj = &#123; id: 1, name: &quot;andy&quot; &#125;; // $.extend(target, obj); $.extend(targetObj, obj); console.log(targetObj); &#125;) &lt;/script&gt; 1.5. jQuery 多库共存​ 实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。 语法 演示代码 1234567&lt;script&gt; $(function() &#123; // 让jquery 释放对$ 控制权 让用自己决定 var suibian = jQuery.noConflict(); console.log(suibian(&quot;span&quot;)); &#125;)&lt;/script&gt; 1.6. jQuery 插件​ jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入 jQuery文件，因此也称为 jQuery 插件。 ​ jQuery 插件常用的网站： jQuery 插件库 http://www.jq22.com/ jQuery 之家 http://www.htmleaf.com/ jQuery 插件使用步骤： 引入相关文件。（jQuery 文件 和 插件文件） 复制相关html、css、js (调用插件)。 1.4.1. 瀑布流插件（重点讲解）​ 我们学习的第一个插件是jQuery之家的开源插件，瀑布流。我们将重点详细讲解，从找到插件所在网页，然后点击下载代码，到插件的使用等，后面的插件使用可参考瀑布流插件的使用。 下载位置 代码演示 ​ 插件的使用三点： 1. 引入css. 2.引入JS 3.引入html。 （有的简单插件只需引入html和js，甚至有的只需引入js） 1.引入css. 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/default.css&quot;&gt; &lt;!-- 下面的样式代码为页面布局，可以引入，也可以自己写，自己设计页面样式，一般为直接引入，方便 --&gt;&lt;style type=&quot;text/css&quot;&gt; #gallery-wrapper &#123; position: relative; max-width: 75%; width: 75%; margin: 50px auto; &#125; img.thumb &#123; width: 100%; max-width: 100%; height: auto; &#125; .white-panel &#123; position: absolute; background: white; border-radius: 5px; box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3); padding: 10px; &#125; .white-panel h1 &#123; font-size: 1em; &#125; .white-panel h1 a &#123; color: #A92733; &#125; .white-panel:hover &#123; box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5); margin-top: -5px; -webkit-transition: all 0.3s ease-in-out; -moz-transition: all 0.3s ease-in-out; -o-transition: all 0.3s ease-in-out; transition: all 0.3s ease-in-out; &#125;&lt;/style&gt; 2.引入js. 123456789101112131415&lt;!-- 前两个必须引入 --&gt;&lt;script src=&quot;js/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/pinterest_grid.js&quot;&gt;&lt;/script&gt;&lt;!-- 下面的为启动瀑布流代码，参数可调节属性，具体功能可参考readme.html --&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; $(&quot;#gallery-wrapper&quot;).pinterest_grid(&#123; no_columns: 5, padding_x: 15, padding_y: 10, margin_bottom: 50, single_column_breakpoint: 700 &#125;); &#125;);&lt;/script&gt; 3.引入html. 1234567891011121314151617181920212223&lt;!-- html结构一般为事先写好，很难修改结构，但可以修改内容及图片的多少（article标签） --&gt;&lt;section id=&quot;gallery-wrapper&quot;&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_000.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_005.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_006.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_007.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;/section&gt; 总结：jQuery插件就是引入别人写好的：html 、css、js （有时也可以只引入一部分，读懂后也可以修改部分内容） 1.4.2. 图片懒加载插件​ 图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。（下载略） 代码演示 ​ 懒加载只需引入html 和 js操作 即可，此插件不涉及css。 1.引入js 123456789101112&lt;script src=&quot;js/EasyLazyload.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; lazyLoadInit(&#123; showTime: 1100, onLoadBackEnd: function(i, e) &#123; console.log(&quot;onLoadBackEnd:&quot; + i); &#125;, onLoadBackStart: function(i, e) &#123; console.log(&quot;onLoadBackStart:&quot; + i); &#125; &#125;);&lt;/script&gt; 2.引入html 1&lt;img data-lazy-src=&quot;upload/floor-1-3.png&quot; alt=&quot;&quot;&gt; 1.4.3. 全屏滚动插件​ 全屏滚动插件比较大，所以，一般大型插件都会有帮助文档，或者网站。全屏滚动插件介绍比较详细的网站为： http://www.dowebok.com/demo/2014/77/ 代码演示 ​ 全屏滚动因为有多重形式，所以不一样的风格html和css也不一样，但是 js 变化不大。所以下面只演示js的引入，html和css引入根据自己实际 项目需要使用哪种风格引入对应的HTML和CSS。 12345678910&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/fullpage.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function() &#123; $(&#x27;#dowebok&#x27;).fullpage(&#123; sectionsColor: [&#x27;pink&#x27;, &#x27;#4BBFC3&#x27;, &#x27;#7BAABE&#x27;, &#x27;#f90&#x27;], navigation: true &#125;); &#125;);&lt;/script&gt; 注意：实际开发，一般复制文件，然后在文件中进行修改和添加功能。 1.4.4. bootstrap组件​ Bootstrap是 Twitter 公司设计的基于HTML、CSS、JavaScript开发的简洁、直观、强悍的前端开发框架，他依靠jQuery实现，且支持响应式 布局，使得 Web 开发更加方便快捷。 ​ 凡是在软件开发中用到了软件的复用，被复用的部分都可以称为组件，凡是在应用程序中已经预留接口的组件就是插件。Bootstrap组件使 用非常方便: 1.引入bootstrap相关css和js 2.去官网复制html 代码演示 引入bootstrap相关css和js 123&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 去官网复制html的功能模块 123456789101112131415 &lt;div class=&quot;container&quot;&gt; &lt;!-- Single button --&gt; &lt;div class=&quot;btn-group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 1.4.5. bootstrap插件（JS）​ bootstrap中的js插件其实也是组件的一部分，只不过是需要js调用功能的组件，所以一般bootstrap的js插件一般会伴随着js代码（有的也可以 省略js，用属性实现）。 ​ 步骤： 1.引入bootstrap相关css和js 2.去官网复制html 3.复制js代码，启动js插件。 代码演示 引入bootstrap相关css和js 123&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 去官网复制html的功能模块 12345678910&lt;!-- 模态框 --&gt;&lt;!-- Large modal --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-toggle=&quot;modal&quot; data-target=&quot;.bs-example-modal-lg&quot;&gt;Large modal&lt;/button&gt;&lt;div class=&quot;modal fade bs-example-modal-lg&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myLargeModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog modal-lg&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; 里面就是模态框 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 复制js代码，启动js插件。 12345678&lt;script&gt; // 当我们点击了自己定义的按钮，就弹出模态框 $(&quot;.myBtn&quot;).on(&quot;click&quot;, function() &#123; // alert(11); $(&#x27;#btn&#x27;).modal() &#125;)&lt;/script&gt; 1.8. 总结","path":"2022/04/03/Js之jQuery笔记（九）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"jQuery快速入门笔记（八）","text":"目标： 能够操作 jQuery 属性能够操作 jQuery 元素能够操作 jQuery 元素尺寸、位置 1.1. jQuery 属性操作​ jQuery 常用属性操作有三种：prop() &#x2F; attr() &#x2F; data() ; 1.1.1 元素固有属性值 prop()​ 所谓元素固有属性就是元素本身自带的属性，比如 元素里面的 href ，比如 元素里面的 type。 语法 ​ 注意：prop() 除了普通属性操作，更适合操作表单属性：disabled &#x2F; checked &#x2F; selected 等。 1.1.2 元素自定义属性值 attr()​ 用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index &#x3D;“1”。 语法 ​ 注意：attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性） 1.1.3 数据缓存 data()​ data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 语法 ​ 注意：同时，还可以读取 HTML5 自定义属性 data-index ，得到的是数字型。 演示代码 1234567891011121314151617181920212223242526&lt;body&gt; &lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked&gt; &lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt; &lt;span&gt;123&lt;/span&gt; &lt;script&gt; $(function() &#123; //1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值 console.log($(&quot;a&quot;).prop(&quot;href&quot;)); $(&quot;a&quot;).prop(&quot;title&quot;, &quot;我们都挺好&quot;); $(&quot;input&quot;).change(function() &#123; console.log($(this).prop(&quot;checked&quot;)); &#125;); // console.log($(&quot;div&quot;).prop(&quot;index&quot;)); // 2. 元素的自定义属性 我们通过 attr() console.log($(&quot;div&quot;).attr(&quot;index&quot;)); $(&quot;div&quot;).attr(&quot;index&quot;, 4); console.log($(&quot;div&quot;).attr(&quot;data-index&quot;)); // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面 $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;); console.log($(&quot;span&quot;).data(&quot;uname&quot;)); // 这个方法获取data-index h5自定义属性 第一个 不用写data- 而且返回的是数字型 console.log($(&quot;div&quot;).data(&quot;index&quot;)); &#125;) &lt;/script&gt;&lt;/body&gt; 1.2. jQuery 文本属性值​ jQuery的文本属性值常见操作有三种：html() &#x2F; text() &#x2F; val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性。 1.2.1 jQuery内容文本值​ 常见操作有三种：html() &#x2F; text() &#x2F; val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。 语法 ​ 注意：html() 可识别标签，text() 不识别标签。 演示代码 1234567891011121314151617&lt;body&gt; &lt;div&gt; &lt;span&gt;我是内容&lt;/span&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; value=&quot;请输入内容&quot;&gt; &lt;script&gt; // 1. 获取设置元素内容 html() console.log($(&quot;div&quot;).html()); // $(&quot;div&quot;).html(&quot;123&quot;); // 2. 获取设置元素文本内容 text() console.log($(&quot;div&quot;).text()); $(&quot;div&quot;).text(&quot;123&quot;); // 3. 获取设置表单值 val() console.log($(&quot;input&quot;).val()); $(&quot;input&quot;).val(&quot;123&quot;); &lt;/script&gt;&lt;/body&gt; 1.3. jQuery 元素操作​ jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。 1.3.1. 遍历元素​ jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。 语法1 ​ 注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。 语法2 ​ 注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。 演示代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; $(function() &#123; // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大） var sum = 0; var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; // 1. each() 方法遍历元素 $(&quot;div&quot;).each(function(i, domEle) &#123; // 回调函数第一个参数一定是索引号 可以自己指定索引号号名称 // console.log(i); // 回调函数第二个参数一定是 dom 元素对象，也是自己命名 // console.log(domEle); // 使用jQuery方法需要转换 $(domEle) $(domEle).css(&quot;color&quot;, arr[i]); sum += parseInt($(domEle).text()); &#125;) console.log(sum); // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据 // $.each($(&quot;div&quot;), function(i, ele) &#123; // console.log(i); // console.log(ele); // &#125;); // $.each(arr, function(i, ele) &#123; // console.log(i); // console.log(ele); // &#125;) $.each(&#123; name: &quot;andy&quot;, age: 18 &#125;, function(i, ele) &#123; console.log(i); // 输出的是 name age 属性名 console.log(ele); // 输出的是 andy 18 属性值 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 1.3.3. 创建、添加、删除​ jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下： 语法总和 ​ 注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详API。 案例代码 1234567891011121314151617181920212223242526&lt;body&gt; &lt;ul&gt; &lt;li&gt;原先的li&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;test&quot;&gt;我是原先的div&lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. 创建元素 var li = $(&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;); // 2. 添加元素 // 2.1 内部添加 // $(&quot;ul&quot;).append(li); 内部添加并且放到内容的最后面 $(&quot;ul&quot;).prepend(li); // 内部添加并且放到内容的最前面 // 2.2 外部添加 var div = $(&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;); // $(&quot;.test&quot;).after(div); $(&quot;.test&quot;).before(div); // 3. 删除元素 // $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀 // $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子 $(&quot;ul&quot;).html(&quot;&quot;); // 可以删除匹配的元素里面的子节点 孩子 &#125;) &lt;/script&gt;&lt;/body&gt; 1.4. jQuery 尺寸、位置操作​ jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。 1.4.1. jQuery 尺寸操作​ jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。 语法 代码演示 12345678910111213141516171819&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. width() / height() 获取设置元素 width和height大小 console.log($(&quot;div&quot;).width()); // $(&quot;div&quot;).width(300); // 2. innerWidth() / innerHeight() 获取设置元素 width和height + padding 大小 console.log($(&quot;div&quot;).innerWidth()); // 3. outerWidth() / outerHeight() 获取设置元素 width和height + padding + border 大小 console.log($(&quot;div&quot;).outerWidth()); // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin console.log($(&quot;div&quot;).outerWidth(true)); &#125;) &lt;/script&gt;&lt;/body&gt; ​ 注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。 1.4.2. jQuery 位置操作​ jQuery的位置操作主要有三个： offset()、position()、scrollTop()&#x2F;scrollLeft() , 具体介绍如下: 语法 代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;back&quot;&gt;返回顶部&lt;/div&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; // 1. 获取设置距离文档的位置（偏移） offset console.log($(&quot;.son&quot;).offset()); console.log($(&quot;.son&quot;).offset().top); // $(&quot;.son&quot;).offset(&#123; // top: 200, // left: 200 // &#125;); // 2. 获取距离带有定位父级位置（偏移） position 如果没有带有定位的父级，则以文档为准 // 这个方法只能获取不能设置偏移 console.log($(&quot;.son&quot;).position()); // $(&quot;.son&quot;).position(&#123; // top: 200, // left: 200 // &#125;); // 3. 被卷去的头部 $(document).scrollTop(100); // 被卷去的头部 scrollTop() / 被卷去的左侧 scrollLeft() // 页面滚动事件 var boxTop = $(&quot;.container&quot;).offset().top; $(window).scroll(function() &#123; // console.log(11); console.log($(document).scrollTop()); if ($(document).scrollTop() &gt;= boxTop) &#123; $(&quot;.back&quot;).fadeIn(); &#125; else &#123; $(&quot;.back&quot;).fadeOut(); &#125; &#125;); // 返回顶部 $(&quot;.back&quot;).click(function() &#123; // $(document).scrollTop(0); $(&quot;body, html&quot;).stop().animate(&#123; scrollTop: 0 &#125;); // $(document).stop().animate(&#123; // scrollTop: 0 // &#125;); 不能是文档而是 html和body元素做动画 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 1.5总结","path":"2022/04/03/Js之jQuery笔记（八）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"jQuery快速入门笔记（七）","text":"目标： 能够说出什么是 jQuery能够说出 jQuery 的优点能够简单使用 jQuery能够说出 DOM 对象和 jQuery 对象的区别能够写出常用的 jQuery 选择器能够操作 jQuery 样式能够写出常用的 jQuery 动画 1.1. jQuery 介绍1.1.1 JavaScript 库​ JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。 简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。 比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。 ​ 常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。 1.1.2 jQuery的概念​ jQuery总体概况如下 : jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 j 就是 JavaScript； Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。 jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。 学习jQuery本质： 就是学习调用这些函数（方法）。 jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。 1.1.3 jQuery的优点 轻量级。核心文件才几十kb，不会影响页面加载速度。 跨浏览器兼容，基本兼容了现在主流的浏览器。 链式编程、隐式迭代。 对事件、样式、动画支持，大大简化了DOM操作。 支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。 免费、开源。 1.2. jQuery 的基本使用1.2.1 jQuery 的下载​ jQuery的官网地址： https://jquery.com/，官网即可下载最新版本。 各个版本的下载：https://code.jquery.com/ ​ 版本介绍： 1x ：兼容 IE 678 等低版本浏览器， 官网不再更新 2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新 3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本 1.2.2. 体验jQuery​ 步骤： 引入jQuery文件。 在文档最末尾插入 script 标签，书写体验代码。 $(‘div’).hide() 可以隐藏盒子。 1.2.3. jQuery的入口函数​ jQuery中常见的两种入口函数： 123456789// 第一种: 简单易用。$(function () &#123; ... // 此处是页面 DOM 加载完成的入口&#125;) ; // 第二种: 繁琐，但是也可以实现$(document).ready(function()&#123; ... // 此处是页面DOM加载完成的入口&#125;); ​ 总结： 等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。 相当于原生 js 中的 DOMContentLoaded。 不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css文件、图片加载完毕才执行内部代码。 更推荐使用第一种方式。 1.2.4. jQuery中的顶级对象$ $是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。 $是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。 1.2.5. jQuery 对象和 DOM 对象​ 使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 : 用原生 JS 获取来的对象就是 DOM 对象 jQuery 方法获取的元素就是 jQuery 对象。 jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。 注意： 只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。 1.2.6. jQuery 对象和 DOM 对象转换​ DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。 1234567891011// 1.DOM对象转换成jQuery对象，方法只有一种var box = document.getElementById(&#x27;box&#x27;); // 获取DOM对象var jQueryObject = $(box); // 把DOM对象转换为 jQuery 对象// 2.jQuery 对象转换为 DOM 对象有两种方法：// 2.1 jQuery对象[索引值]var domObject1 = $(&#x27;div&#x27;)[0]// 2.2 jQuery对象.get(索引值)var domObject2 = $(&#x27;div&#x27;).get(0) 总结：实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。 1.3. jQuery 选择器​ 原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。 1.3.1. 基础选择器1$(&quot;选择器&quot;) // 里面选择器直接写 CSS 选择器即可，但是要加引号 ​ 1.3.2. 层级选择器​ 层级选择器最常用的两个分别为：后代选择器和子代选择器。 ​ 基础选择器和层级选择器案例代码 12345678910111213141516&lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div class=&quot;nav&quot;&gt;我是nav div&lt;/div&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;ul&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() &#123; console.log($(&quot;.nav&quot;)); console.log($(&quot;ul li&quot;)); &#125;) &lt;/script&gt;&lt;/body&gt; 1.3.3. 筛选选择器​ 筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 : 案例代码 1234567891011121314151617181920212223242526&lt;body&gt; &lt;ul&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; $(function() &#123; $(&quot;ul li:first&quot;).css(&quot;color&quot;, &quot;red&quot;); $(&quot;ul li:eq(2)&quot;).css(&quot;color&quot;, &quot;blue&quot;); $(&quot;ol li:odd&quot;).css(&quot;color&quot;, &quot;skyblue&quot;); $(&quot;ol li:even&quot;).css(&quot;color&quot;, &quot;pink&quot;); &#125;) &lt;/script&gt;&lt;/body&gt; 另: jQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。 偏重于记忆，演示代码略。 1.3.4 知识铺垫 jQuery 设置样式 1$(&#x27;div&#x27;).css(&#x27;属性&#x27;, &#x27;值&#x27;) jQuery 里面的排他思想 123// 想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。$(this).css(“color”,”red”);$(this).siblings(). css(“color”,””); 隐式迭代 123// 遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。// 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。$(&#x27;div&#x27;).hide(); // 页面中所有的div全部隐藏，不用循环操作 链式编程 12// 链式编程是为了节省代码量，看起来更优雅。$(this).css(&#x27;color&#x27;, &#x27;red&#x27;).sibling().css(&#x27;color&#x27;, &#x27;&#x27;); 1.4. jQuery 样式操作​ jQuery中常用的样式操作有两种：css() 和 设置类样式方法 1.4.1. 方法1: 操作 css 方法​ jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。 ​ 常用以下三种形式 : 123456789// 1.参数只写属性名，则是返回属性值var strColor = $(this).css(&#x27;color&#x27;);// 2. 参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号$(this).css(&#x27;&#x27;color&#x27;&#x27;, &#x27;&#x27;red&#x27;&#x27;);// 3. 参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号$(this).css(&#123; &quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;&#125;); ​ 注意：css() 多用于样式少时操作，多了则不太方便。 1.4.2. 方法2: 设置类样式方法​ 作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。 ​ 常用的三种设置类样式方法： 123456789// 1.添加类$(&quot;div&quot;).addClass(&quot;current&quot;);// 2.删除类$(&quot;div&quot;).removeClass(&quot;current&quot;);// 3.切换类$(&quot;div&quot;).toggleClass(&quot;current&quot;); ​ 注意： 设置类样式方法比较适合样式多时操作，可以弥补css()的不足。 原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。 1.5. jQuery 效果​ jQuery 给我们封装了很多动画效果，最为常见的如下： 显示隐藏：show() &#x2F; hide() &#x2F; toggle() ; 划入画出：slideDown() &#x2F; slideUp() &#x2F; slideToggle() ; 淡入淡出：fadeIn() &#x2F; fadeOut() &#x2F; fadeToggle() &#x2F; fadeTo() ; 自定义动画：animate() ; 注意： 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 jQuery为我们提供另一个方法，可以停止动画排队：stop() ; 1.5.1. 显示隐藏​ 显示隐藏动画，常见有三个方法：show() &#x2F; hide() &#x2F; toggle() ; ​ 语法规范如下: 代码演示 123456789101112131415161718192021222324&lt;body&gt; &lt;button&gt;显示&lt;/button&gt; &lt;button&gt;隐藏&lt;/button&gt; &lt;button&gt;切换&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).eq(0).click(function() &#123; $(&quot;div&quot;).show(1000, function() &#123; alert(1); &#125;); &#125;) $(&quot;button&quot;).eq(1).click(function() &#123; $(&quot;div&quot;).hide(1000, function() &#123; alert(1); &#125;); &#125;) $(&quot;button&quot;).eq(2).click(function() &#123; $(&quot;div&quot;).toggle(1000); &#125;) // 一般情况下，我们都不加参数直接显示隐藏就可以了 &#125;); &lt;/script&gt;&lt;/body&gt; 1.5.2. 滑入滑出​ 滑入滑出动画，常见有三个方法：slideDown() &#x2F; slideUp() &#x2F; slideToggle() ; ​ 语法规范如下: 代码演示 12345678910111213141516171819202122&lt;body&gt; &lt;button&gt;下拉滑动&lt;/button&gt; &lt;button&gt;上拉滑动&lt;/button&gt; &lt;button&gt;切换滑动&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).eq(0).click(function() &#123; // 下滑动 slideDown() $(&quot;div&quot;).slideDown(); &#125;) $(&quot;button&quot;).eq(1).click(function() &#123; // 上滑动 slideUp() $(&quot;div&quot;).slideUp(500); &#125;) $(&quot;button&quot;).eq(2).click(function() &#123; // 滑动切换 slideToggle() $(&quot;div&quot;).slideToggle(500); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; 小案例：下拉菜单略（详情参看源码）。 1.5.3 淡入淡出​ 淡入淡出动画，常见有四个方法：fadeIn() &#x2F; fadeOut() &#x2F; fadeToggle() &#x2F; fadeTo() ; ​ 语法规范如下: 代码演示 123456789101112131415161718192021222324252627&lt;body&gt; &lt;button&gt;淡入效果&lt;/button&gt; &lt;button&gt;淡出效果&lt;/button&gt; &lt;button&gt;淡入淡出切换&lt;/button&gt; &lt;button&gt;修改透明度&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).eq(0).click(function() &#123; // 淡入 fadeIn() $(&quot;div&quot;).fadeIn(1000); &#125;) $(&quot;button&quot;).eq(1).click(function() &#123; // 淡出 fadeOut() $(&quot;div&quot;).fadeOut(1000); &#125;) $(&quot;button&quot;).eq(2).click(function() &#123; // 淡入淡出切换 fadeToggle() $(&quot;div&quot;).fadeToggle(1000); &#125;); $(&quot;button&quot;).eq(3).click(function() &#123; // 修改透明度 fadeTo() 这个速度和透明度要必须写 $(&quot;div&quot;).fadeTo(1000, 0.5); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; 1.5.4 自定义动画​ 自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() ; ​ 语法规范如下: 代码演示 12345678910111213141516&lt;body&gt; &lt;button&gt;动起来&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() &#123; $(&quot;button&quot;).click(function() &#123; $(&quot;div&quot;).animate(&#123; left: 500, top: 300, opacity: .4, width: 500 &#125;, 500); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt; 1.5.5 停止动画排队​ 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 ​ 停止动画排队的方法为：stop() ; stop() 方法用于停止动画或效果。 stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。 ​ 总结: 每次使用动画之前，先调用 stop() ,在调用动画。 1.5.6. 事件切换​ jQuery中为我们添加了一个新事件 hover() ; 功能类似 css 中的伪类 :hover 。介绍如下 语法 1hover([over,]out) // 其中over和out为两个函数 over:鼠标移到元素上要触发的函数（相当于mouseenter） out:鼠标移出元素要触发的函数（相当于mouseleave） 如果只写一个函数，则鼠标经过和离开都会触发它 hover事件和停止动画排列案例 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() &#123; // 鼠标经过 // $(&quot;.nav&gt;li&quot;).mouseover(function() &#123; // // $(this) jQuery 当前元素 this不要加引号 // // show() 显示元素 hide() 隐藏元素 // $(this).children(&quot;ul&quot;).slideDown(200); // &#125;); // // 鼠标离开 // $(&quot;.nav&gt;li&quot;).mouseout(function() &#123; // $(this).children(&quot;ul&quot;).slideUp(200); // &#125;); // 1. 事件切换 hover 就是鼠标经过和离开的复合写法 // $(&quot;.nav&gt;li&quot;).hover(function() &#123; // $(this).children(&quot;ul&quot;).slideDown(200); // &#125;, function() &#123; // $(this).children(&quot;ul&quot;).slideUp(200); // &#125;); // 2. 事件切换 hover 如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数 $(&quot;.nav&gt;li&quot;).hover(function() &#123; // stop 方法必须写到动画的前面 $(this).children(&quot;ul&quot;).stop().slideToggle(); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt; 1.6. 总结","path":"2022/04/03/Js之jQuery笔记（七）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript笔记（六）","text":"1 - 内置对象1.1 内置对象​ JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象​ 前面两种对象是JS 基础 内容，属于 ECMAScript； 第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法），内置对象最大的优点就是帮助我们快速开发 ​ JavaScript 提供了多个内置对象：Math、 Date 、Array、String等 1.2 查文档​ 查找文档：学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN&#x2F;W3C来查询。​ Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。​ MDN:https://developer.mozilla.org/zh-CN/ 1.3 Math对象​ Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。 属性、方法名 功能 Math.PI 圆周率 Math.floor() 向下取整 Math.ceil() 向上取整 Math.round() 四舍五入版 就近取整 注意 -3.5 结果是 -3 Math.abs() 绝对值 Math.max()&#x2F;Math.min() 求最大和最小值 Math.random() 获取范围在[0,1)内的随机值 ​ 注意：上面的方法使用时必须带括号 ​ 获取指定范围内的随机整数： 123function getRandom(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min; &#125; 1.4 日期对象​ Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间 使用Date实例化日期对象 获取当前时间必须实例化： 1var now = new Date(); 获取指定时间的日期对象 1var future = new Date(&#x27;2019/5/1&#x27;); 注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象 使用Date实例的方法和属性 通过Date实例获取总毫米数 总毫秒数的含义 ​ 基于1970年1月1日（世界标准时间）起的毫秒数 获取总毫秒数 123456789// 实例化Date对象var now = new Date();// 1. 用于获取对象的原始值console.log(date.valueOf()) console.log(date.getTime()) // 2. 简单写可以这么做var now = + new Date(); // 3. HTML5中提供的方法，有兼容性问题var now = Date.now(); 1.5 数组对象创建数组的两种方式 字面量方式 示例代码如下： 1var arr = [1,&quot;test&quot;,true]; new Array() 示例代码如下： 1var arr = new Array(); ​ 注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数 ​ 参数传递规则如下： 如果只传入一个参数，则参数规定了数组的长度 如果传入了多个参数，则参数称为数组的元素 检测是否为数组 instanceof 运算符 instanceof 可以判断一个对象是否是某个构造函数的实例 1234var arr = [1, 23];var obj = &#123;&#125;;console.log(arr instanceof Array); // trueconsole.log(obj instanceof Array); // false Array.isArray() Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法 1234var arr = [1, 23];var obj = &#123;&#125;;console.log(Array.isArray(arr)); // trueconsole.log(Array.isArray(obj)); // false 添加删除数组元素的方法 数组中有进行增加、删除元素的方法，部分方法如下表 注意：push、unshift为增加元素方法；pop、shift为删除元素的方法 数组排序 数组中有对数组本身排序的方法，部分方法如下表 注意：sort方法需要传入参数来设置升序、降序排序 如果传入“function(a,b){ return a-b;}”，则为升序 如果传入“function(a,b){ return b-a;}”，则为降序 数组索引方法 数组中有获取数组指定元素索引值的方法，部分方法如下表 数组转换为字符串 数组中有把数组转化为字符串的方法，部分方法如下表 注意：join方法如果不传入参数，则按照 “ , ”拼接元素 其他方法 数组中还有其他操作方法，同学们可以在课下自行查阅学习 1.6 字符串对象基本包装类型​ 为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 ​ 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。 123// 下面代码有什么问题？var str = &#x27;andy&#x27;;console.log(str.length); ​ 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 ​ js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ： 123456// 1. 生成临时变量，把简单类型包装为复杂数据类型var temp = new String(&#x27;andy&#x27;);// 2. 赋值给我们声明的字符变量str = temp;// 3. 销毁临时变量temp = null; 字符串的不可变​ 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 ​ 当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。​ 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 根据字符返回位置​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法： ​ 案例：查找字符串”abcoefoxyozzopp”中所有o出现的位置以及次数 先查找第一个o出现的位置 然后 只要indexOf 返回的结果不是 -1 就继续往后查找 因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找 根据位置返回字符​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符： ​ 在上述方法中，charCodeAt方法返回的是指定位置上字符对应的ASCII码，ASCII码对照表如下： ​ 案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数 核心算法：利用 charAt(） 遍历这个字符串 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1 遍历对象，得到最大值和该字符 ​ 注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数 字符串操作方法​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法： replace()方法​ replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下： 1字符串.replace(被替换的字符串， 要替换为的字符串)； split()方法​ split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。 ​ 其使用格式如下： 1字符串.split(&quot;分割字符&quot;) 2 - 简单数据类型和复杂数据类型2.1 简单数据类型​ 简单类型（基本数据类型、值类型）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null 2.2 复杂数据类型​ 复杂数据类型（引用类型）：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等； 2.3 堆栈 堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈； 简单数据类型存放到栈里面 2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。 简单数据类型的存储方式 ​ 值类型变量的数据直接存放在变量（栈空间）中 复杂数据类型的存储方式 ​ 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中 2.4 简单类型传参​ 函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。 1234567function fn(a) &#123; a++; console.log(a); &#125;var x = 10;fn(x);console.log(x)； ​ 运行结果如下： 2.5 复杂数据类型传参​ 函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。 123456789101112function Person(name) &#123; this.name = name;&#125;function f1(x) &#123; // x = p console.log(x.name); // 2. 这个输出什么 ? x.name = &quot;张学友&quot;; console.log(x.name); // 3. 这个输出什么 ? &#125;var p = new Person(&quot;刘德华&quot;);console.log(p.name); // 1. 这个输出什么 ? f1(p);console.log(p.name); // 4. 这个输出什么 ? ​ 运行结果如下：","path":"2022/04/03/JavaScript笔记（六）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript之作用域与对象笔记（五）","text":"1 - 作用域1.1 作用域概述​ 通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。 JavaScript（es6前）中的作用域有两种： 全局作用域 局部作用域（函数作用域） 1.2 全局作用域 作用于所有代码执行的环境(整个script标签内部)或独立的js文件。 1.3 局部作用域 作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。 1.4 jS没有块级作用域 块作用域由 { } 包括。 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码： java有块级作用域： 12345if(true)&#123; int num = 123; system.out.print(num); // 123&#125;system.out.print(num); // 报错 ​ 以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；而与之类似的JavaScript代码，则不会报错。 js中没有块级作用域（在ES6之前） 12345if(true)&#123; var num = 123; console.log(123); //123&#125;console.log(123); //123 2 - 变量的作用域在JavaScript中，根据作用域的不同，变量可以分为两种： 全局变量 局部变量 2.1 全局变量 在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。 全局变量在代码的任何位置都可以使用 在全局作用域下 var 声明的变量 是全局变量 特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用） 2.2 局部变量 在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量） 局部变量只能在该函数内部使用 在函数内部 var 声明的变量是局部变量 函数的形参实际上就是局部变量 2.3 全局变量和局部变量的区别 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间 3 - 作用域链​ 只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。 12345678910案例分析1：function f1() &#123; var num = 123; function f2() &#123; console.log( num ); &#125; f2();&#125;var num = 456;f1(); 1234567891011121314151617作用域链：采取就近原则的方式来查找变量最终的值var a = 1;function fn1() &#123; var a = 2; var b = &#x27;22&#x27;; fn2(); function fn2() &#123; var a = 3; fn3(); function fn3() &#123; var a = 4; console.log(a); //a的值 ? console.log(b); //b的值 ? &#125; &#125;&#125;fn1(); 4 - 预解析4.1 预解析的相关概念 JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。 JavaScript 解析器在运行 JavaScript 代码的时候分为两步： ​ 预解析和代码执行。 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义，预解析也叫做变量、函数提升。 代码执行： 从上到下执行JS语句。 注意：预解析会把变量和函数的声明在代码执行之前执行完成。 4.2 变量预解析 ​ 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。 12console.log(num); // 结果是多少？var num = 10; // ？ 结果：undefined注意：变量提升只提升声明，不提升赋值 4.3 函数预解析 ​ 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。 1234fn();function fn() &#123; console.log(&#x27;打印&#x27;);&#125; 结果：控制台打印字符串 — ”打印“ 注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！ 4.4 函数表达式声明函数问题 函数表达式创建函数，会执行变量提升 1234fn();var fn = function() &#123; console.log(&#x27;想不到吧&#x27;);&#125; 结果：报错提示 ”fn is not a function” 解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用 5 - 对象5.1 对象的相关概念 什么是对象？ 在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。 对象是由属性和方法组成的。 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 为什么需要对象？ 保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。 如果要保存一个人的完整信息呢？ 例如，将“张三疯”的个人的信息保存在数组中的方式为： 1var arr = [‘张三疯’, ‘男&#x27;, 128,154]; ​ 上述例子中用数组保存数据的缺点是：数据只能通过索引值访问，开发者需要清晰的清除所有的数据的排行才能准确地获取数据，而当数据量庞大时，不可能做到记忆所有数据的索引值。 ​ 为了让更好地存储一组数据，对象应运而生：对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用。 使用对象记录上组数据为： 123456var obj = &#123; &quot;name&quot;:&quot;张三疯&quot;, &quot;sex&quot;:&quot;男&quot;, &quot;age&quot;:128, &quot;height&quot;:154&#125; JS中的对象表达结构更清晰，更强大。 5.2 创建对象的三种方式利用字面量创建对象1花括号 &#123; &#125; 里面包含了表达这个具体事物（对象）的属性和方法；&#123; &#125; 里面采取键值对的形式表示 键：相当于属性名 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等） 代码如下： 12345678var star = &#123; name : &#x27;pink&#x27;, age : 18, sex : &#x27;男&#x27;, sayHi : function()&#123; alert(&#x27;大家好啊~&#x27;); &#125;&#125;; 上述代码中 star即是创建的对象。 对象的使用 对象的属性 对象中存储具体数据的 “键值对”中的 “键”称为对象的属性，即对象中存储具体数据的项 对象的方法 对象中存储函数的 “键值对”中的 “键”称为对象的方法，即对象中存储函数的项 访问对象的属性 对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ” 对象里面属性的另一种调用方式 : 对象[‘属性名’]，注意方括号里面的属性必须加引号 示例代码如下： 12console.log(star.name) // 调用名字属性console.log(star[&#x27;name&#x27;]) // 调用名字属性 调用对象的方法 对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号 示例代码如下： 1star.sayHi(); // 调用 sayHi 方法,注意一定要带后面的括号 变量、属性、函数、方法总结 属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器 变量：单独声明赋值，单独存在 属性：对象里面的变量称为属性，不需要声明 ​ 方法是对象的一部分，函数是单独封装操作的容器 函数：单独存在的，通过“函数名()”的方式就可以调用 方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用 利用 new Object 创建对象 创建空对象 1var andy = new Obect(); 通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象 给空对象添加属性和方法 通过对象操作属性和方法的方式，来为对象增加属性和方法 示例代码如下： 123456andy.name = &#x27;pink&#x27;;andy.age = 18;andy.sex = &#x27;男&#x27;;andy.sayHi = function()&#123; alert(&#x27;大家好啊~&#x27;);&#125; 注意： Object() ：第一个字母大写 new Object() ：需要 new 关键字 使用的格式：对象.属性 &#x3D; 值; 利用构造函数创建对象 构造函数 构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 构造函数的封装格式： 123456function 构造函数名(形参1,形参2,形参3) &#123; this.属性名1 = 参数1; this.属性名2 = 参数2; this.属性名3 = 参数3; this.方法名 = 函数体;&#125; 构造函数的调用格式 1var obj = new 构造函数名(实参1，实参2，实参3) 以上代码中，obj即接收到构造函数创建出来的对象。 注意事项 构造函数约定首字母大写。 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 构造函数中不需要 return 返回结果。 当我们创建对象的时候，必须用 new 来调用构造函数。 其他 构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化 new关键字的作用 在构造函数代码开始执行之前，创建一个空对象； 修改this的指向，把this指向创建出来的空对象； 执行函数的代码 在函数完成之后，返回this—即创建出来的对象 5.3 遍历对象​ for…in 语句用于对数组或者对象的属性进行循环操作。 ​ 其语法如下： 123for (变量 in 对象名字) &#123; // 在此执行代码&#125; ​ 语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。 1234for (var k in obj) &#123; console.log(k); // 这里的 k 是属性名 console.log(obj[k]); // 这里的 obj[k] 是属性值&#125;","path":"2022/04/03/JavaScript笔记（五）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript之数组与函数笔记（四）","text":"1 - 数组1.1 数组的概念 数组可以把一组相关的数据一起存放，并提供方便的访问(获取）方式。 数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。 1.2 创建数组JS 中创建数组有两种方式： 利用 new 创建数组 12var 数组名 = new Array() ；var arr = new Array(); // 创建一个新的空数组 注意 Array () ，A 要大写 利用数组字面量创建数组 1234//1. 使用数组字面量方式创建空的数组var 数组名 = []；//2. 使用数组字面量方式创建带初始值的数组var 数组名 = [&#x27;小白&#x27;,&#x27;小黑&#x27;,&#x27;大黄&#x27;,&#x27;瑞奇&#x27;]; 数组的字面量是方括号 [ ] 声明数组并赋值称为数组的初始化 这种字面量方式也是我们以后最多使用的方式 数组元素的类型 数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。 1var arrStus = [&#x27;小白&#x27;,12,true,28.9]; 1.3 获取数组中的元素​ 索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。 ​ 数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。 1234// 定义数组var arrStus = [1,2,3];// 获取数组中的第2个元素alert(arrStus[1]); 注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined 1.4 遍历数组 数组遍历 ​ 把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项 1234var arr = [&#x27;red&#x27;,&#x27;green&#x27;, &#x27;blue&#x27;];for(var i = 0; i &lt; arr.length; i++)&#123; console.log(arrStus[i]);&#125; 数组的长度 数组的长度：默认情况下表示数组中元素的个数 使用“数组名.length”可以访问数组元素的数量（数组长度）。 12var arrStus = [1,2,3];alert(arrStus.length); // 3 注意： 此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。 当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化 数组的length属性可以被修改： 如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素； 如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除 1.5 数组中新增元素​ 数组中可以通过以下方式在数组的末尾插入新元素： 1数组[ 数组.length ] = 新数据; 2 - 函数2.1 函数的概念​ 在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。 ​ 函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。 2.2 函数的使用声明函数1234// 声明函数function 函数名() &#123; //函数体代码&#125; function 是声明函数的关键字,必须小写 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum 调用函数12// 调用函数函数名(); // 通过调用函数名来执行函数体代码 调用的时候千万不要忘记添加小括号 口诀：函数不调用，自己不执行 注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。 函数的封装 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口 简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包） 例子：封装计算1-100累加和 12345678910111213/* 计算1-100之间值的函数*/// 声明函数function getSum()&#123; var sumNum = 0;// 准备一个变量，保存数字和 for (var i = 1; i &lt;= 100; i++) &#123; sumNum += i;// 把每个数值 都累加 到变量中 &#125; alert(sumNum);&#125;// 调用函数getSum(); 2.3 函数的参数函数参数语法 形参：函数定义时设置接收调用时传入 实参：函数调用时传入小括号内的真实数据 ​ 参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。 函数参数的运用： 123456// 带参数的函数声明function 函数名(形参1, 形参2 , 形参3...) &#123; // 可以定义任意多的参数，用逗号分隔 // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3...); 调用的时候实参值是传递给形参的 形参简单理解为：不用声明的变量 实参和形参的多个参数之间用逗号（,）分隔 函数形参和实参数量不匹配时 注意：在JavaScript中，形参的默认值是undefined。 小结： 函数可以带参数也可以不带参数 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined 调用函数的时候，函数名括号里面的是实参 多个参数中间用逗号分隔 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配 2.4 函数的返回值return 语句返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。 1234567// 声明函数function 函数名（）&#123; ... return 需要返回的值；&#125;// 调用函数函数名(); // 此时调用函数就可以得到函数体内return 后面的值 在使用 return 语句时，函数会停止执行，并返回指定的值 如果函数没有 return ，返回的值是 undefined break ,continue ,return 的区别 break ：结束当前的循环体（如 for、while） continue ：跳出本次循环，继续执行下次循环（如 for、while） return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码 2.5 arguments的使用​ 当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点： 具有 length 属性 按索引方式储存数据 不具有数组的 push , pop 等方法 注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。 2.6 函数案例 函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。 2.7 函数的两种声明方式 自定义函数方式(命名函数) 利用函数关键字 function 自定义函数方式 1234// 声明定义方式function fn() &#123;...&#125;// 调用 fn(); 因为有名字，所以也被称为命名函数 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面 函数表达式方式(匿名函数） 利用函数表达式方式的写法如下： 1234// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function()&#123;...&#125;；// 调用的方式，函数调用必须写到函数体下面fn(); 因为函数没有名字，所以也被称为匿名函数 这个fn 里面存储的是一个函数 函数表达式方式原理跟声明变量方式是一致的 函数调用的代码必须写到函数体后面","path":"2022/04/03/JavaScript笔记（四）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript之循环笔记（三）","text":"1 - 循环1.1 for循环 语法结构 123for(初始化变量; 条件表达式; 操作表达式 )&#123; //循环体&#125; 名称 作用 初始化变量 通常被用于初始化一个计数器，该表达式可以使用 var 关键字声明新的变量，这个变量帮我们来记录次数。 条件表达式 用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。 操作表达式 用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。 执行过程： 初始化变量，初始化操作在整个 for 循环只会执行一次。 执行条件表达式，如果为true，则执行循环体语句，否则退出循环，循环结束。 执行操作表达式，此时第一轮结束。 第二轮开始，直接去执行条件表达式（不再初始化变量），如果为 true ，则去执行循环体语句，否则退出循环。 继续执行操作表达式，第二轮结束。 后续跟第二轮一致，直至条件表达式为假，结束整个 for 循环。 断点调试： 1断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程 1234断点调试的流程：1、浏览器中按 F12--&gt; sources --&gt;找到需要调试的文件--&gt;在程序的某一行设置断点2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。 for 循环重复相同的代码 比如输出10句“媳妇我错了” 123456789// 基本写法for(var i = 1; i &lt;= 10; i++)&#123; console.log(&#x27;媳妇我错了~&#x27;);&#125;// 用户输入次数var num = prompt(&#x27;请输入次数:&#x27;)；for ( var i = 1 ; i &lt;= num; i++) &#123; console.log(&#x27;媳妇我错了~&#x27;);&#125; for 循环重复不相同的代码 例如，求输出1到100岁： 1234// 基本写法for (var i = 1; i &lt;= 100; i++) &#123; console.log(&#x27;这个人今年&#x27; + i + &#x27;岁了&#x27;);&#125; 例如，求输出1到100岁，并提示出生、死亡 12345678910// for 里面是可以添加其他语句的 for (var i = 1; i &lt;= 100; i++) &#123; if (i == 1) &#123; console.log(&#x27;这个人今年1岁了， 它出生了&#x27;); &#125; else if (i == 100) &#123; console.log(&#x27;这个人今年100岁了，它死了&#x27;); &#125; else &#123; console.log(&#x27;这个人今年&#x27; + i + &#x27;岁了&#x27;); &#125;&#125; for循环因为有了计数器的存在，还可以重复的执行某些操作，比如做一些算术运算。 1.2 双重for循环 双重 for 循环概述 循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for 循环，这样的 for 循环语句我们称之为双重for循环。 双重 for 循环语法 12345for (外循环的初始; 外循环的条件; 外循环的操作表达式) &#123; for (内循环的初始; 内循环的条件; 内循环的操作表达式) &#123; 需执行的代码; &#125;&#125; 内层循环可以看做外层循环的循环体语句 内层循环执行的顺序也要遵循 for 循环的执行顺序 外层循环执行一次，内层循环要执行全部次数 打印五行五列星星 123456789var star = &#x27;&#x27;;for (var j = 1; j &lt;= 3; j++) &#123; for (var i = 1; i &lt;= 3; i++) &#123; star += &#x27;☆&#x27; &#125; // 每次满 5个星星 就 加一次换行 star += &#x27;\\n&#x27;&#125;console.log(star); 核心逻辑： 1.内层循环负责一行打印五个星星 2.外层循环负责打印五行 for 循环小结 for 循环可以重复执行某些相同代码 for 循环可以重复执行些许不同的代码，因为我们有计数器 for 循环可以重复执行某些操作，比如算术运算符加法操作 随着需求增加，双重for循环可以做更多、更好看的效果 双重 for 循环，外层循环一次，内层 for 循环全部执行 for 循环是循环条件和数字直接相关的循环 1.3 while循环while语句的语法结构如下： 123while (条件表达式) &#123; // 循环体代码 &#125; 执行思路： 1 先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码 2 执行循环体代码 3 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束 注意： 使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环 1.4 do-while循环do… while 语句的语法结构如下： 123do &#123; // 循环体代码 - 条件表达式为 true 时重复执行循环体代码&#125; while(条件表达式); 执行思路 1 先执行一次循环体代码 2 再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码 注意：先再执行循环体，再判断，do…while循环语句至少会执行一次循环体代码 1.5 continue、breakcontinue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。 例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子，其代码实现如下： 1234567for (var i = 1; i &lt;= 5; i++) &#123; if (i == 3) &#123; console.log(&#x27;这个包子有虫子，扔掉&#x27;); continue; // 跳出本次循环，跳出的是第3次循环 &#125; console.log(&#x27;我正在吃第&#x27; + i + &#x27;个包子呢&#x27;);&#125; 运行结果： break 关键字用于立即跳出整个循环（循环结束）。 例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如下： 123456for (var i = 1; i &lt;= 5; i++) &#123; if (i == 3) &#123; break; // 直接退出整个for 循环，跳到整个for下面的语句 &#125; console.log(&#x27;我正在吃第&#x27; + i + &#x27;个包子呢&#x27;); &#125; 运行结果： 2 - 代码规范2.1 标识符命名规范 变量、函数的命名必须要有意义 变量的名称一般用名词 函数的名称一般用动词 2.2 操作符规范1234567// 操作符的左右两侧各保留一个空格for (var i = 1; i &lt;= 5; i++) &#123; if (i == 3) &#123; break; // 直接退出整个 for 循环，跳到整个for循环下面的语句 &#125; console.log(&#x27;我正在吃第&#x27; + i + &#x27;个包子呢&#x27;);&#125; 2.3 单行注释规范123456for (var i = 1; i &lt;= 5; i++) &#123; if (i == 3) &#123; break; // 单行注释前面注意有个空格 &#125; console.log(&#x27;我正在吃第&#x27; + i + &#x27;个包子呢&#x27;);&#125; 2.4 其他规范关键词、操作符之间后加空格","path":"2022/04/03/JavaScript笔记（三）/","date":"04-03","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript之运算符与流程控制笔记（二）","text":"1 - 运算符（操作符）1.1 运算符的分类​ 运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。 123456JavaScript中常用的运算符有：- 算数运算符- 递增和递减运算符- 比较运算符- 逻辑运算符- 赋值运算符 1.2 算数运算符 算术运算符概述 概念：算术运算使用的符号，用于执行两个变量或值的算术运算。 浮点数的精度问题 ​ 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。 12var result = 0.1 + 0.2;//结果是：0.30000000000000004console.log(0.07 * 100);//结果是：7.000000000000001 ​ 所以：不要直接判断两个浮点数是否相等 ! 表达式和返回值 ​ 表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合 ​ 简单理解：是由数字、运算符、变量等组成的式子 ​ 表达式最终都会有一个结果，返回给开发者，称为返回值 1.3 递增和递减运算符 递增和递减运算符概述 如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ -- ）运算符来完成。 在 JavaScript 中，递增（++）和递减（ -- ）既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。 注意：递增和递减运算符必须和变量配合使用。 递增运算符 前置递增运算符 ++num 前置递增，就是自加1，类似于 num &#x3D; num + 1 使用口诀：先自加，后返回值 12var num = 10;alert(++num + 10); // 21 后置递增运算符 num++ 后置递增，就是自加1，类似于 num &#x3D; num + 1 使用口诀：先返回原值，后自加 12var num = 10;alert(10 + num++); // 20 1.4 比较运算符 比较运算符概述 概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果。 等号比较 12console.log(18 == &#x27;18&#x27;); // trueconsole.log(18 === &#x27;18&#x27;); // false 1.5 逻辑运算符 逻辑运算符概述 逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断 逻辑与&amp;&amp; ​ 两边都是 true才返回 true，否则返回 false 逻辑或 || ​ 两边都是 true才返回 true，否则返回 false 逻辑非 ！ ​ 逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false 12var isOk = !true;console.log(isOk); // false 短路运算（逻辑中断） ​ 逻辑元素父左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值; 逻辑与 ​ 语法： 表达式1 &amp;&amp; 表达式2 - 如果第一个表达式的值为真，则返回表达式2 如果第一个表达式的值为假，则返回表达式1 123console.log( 123 &amp;&amp; 456 ); // 456console.log( 0 &amp;&amp; 456 ); // 0console.log( 123 &amp;&amp; 456&amp;&amp; 789 ); // 789 逻辑或 ​ 语法： 表达式1 || 表达式2 - 如果第一个表达式的值为真，则返回表达式1 - 如果第一个表达式的值为假，则返回表达式2 123console.log( 123 || 456 ); // 123 console.log( 0 || 456 ); // 456 console.log( 123 || 456 || 789 ); // 123 1.6 赋值运算符​ 概念：用来把数据赋值给变量的运算符。 1234var age = 10;age += 5; // 相当于 age = age + 5;age -= 5; // 相当于 age = age - 5;age *= 10; // 相当于 age = age * 10; 1.7 运算符优先级 一元运算符里面的逻辑非优先级很高 逻辑与比逻辑或优先级高 2 - 流程控制2.1 流程控制概念​ 在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。 ​ 简单理解：流程控制就是来控制代码按照一定结构顺序来执行 ​ 流程控制主要有三种结构：顺序结构、分支结构、循环结构 2.2 顺序流程控制​ 2.3 分支流程控制 分支结构 ​ ​ JS 语言提供了两种分支结构语句：if 语句、switch 语句 if 语句 语法结构 1234// 条件成立执行代码，否则什么也不做if (条件表达式) &#123; // 条件成立执行的代码语句&#125; 语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下，会分割成一个一个的语句。 执行流程 if else语句（双分支语句） 语法结构 1234567// 条件成立 执行 if 里面代码，否则执行else 里面的代码if (条件表达式) &#123; // [如果] 条件成立执行的代码&#125; else &#123; // [否则] 执行的代码&#125; 执行流程 if else if 语句(多分支语句) 语法结构 123456789101112// 适合于检查多重条件。if (条件表达式1) &#123; 语句1；&#125; else if (条件表达式2) &#123; 语句2；&#125; else if (条件表达式3) &#123; 语句3； ....&#125; else &#123; // 上述条件都不成立执行此处代码&#125; 执行逻辑 2.4 三元表达式 语法结构 1表达式1 ? 表达式2 : 表达式3; 执行思路 如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值 简单理解： 就类似于 if else （双分支） 的简写 2.5 switch分支流程控制 语法结构 123456789101112switch( 表达式 )&#123; case value1: // 表达式 等于 value1 时要执行的代码 break; case value2: // 表达式 等于 value2 时要执行的代码 break; default: // 表达式 不等于任何一个 value 时要执行的代码&#125; 关键字 switch 后面括号内可以是表达式或值， 通常是一个变量 关键字 case , 后跟一个选项的表达式或值，后面跟一个冒号 switch 表达式的值会与结构中的 case 的值做比较 如果存在匹配全等(&#x3D;&#x3D;&#x3D;) ，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码执行结束 如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码 注意： 执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句。 switch 语句和 if else if 语句的区别 一般情况下，它们两个语句可以相互替换 switch…case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、等于某个范围) switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多少次。 当分支比较少时，if… else语句的执行效率比 switch语句高。 当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。","path":"2022/04/02/JavaScript笔记（二）/","date":"04-02","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript基础笔记（一）","text":"1 - 编程语言1.1 编程 编程： 就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。 计算机程序： 就是计算机所执行的一系列的指令集合，而程序全部都是用我们所掌握的语言来编写的，所以人们要控制计算机一定要通过计算机语言向计算机发出命令。 1.2 计算机语言 计算机语言指用于人与计算机之间通讯的语言，它是人与计算机之间传递信息的媒介。 计算机语言的种类非常的多，总的来说可以分成机器语言，汇编语言和高级语言三大类。 实际上计算机最终所执行的都是 机器语言，它是由“0”和“1”组成的二进制数，二进制是计算机语言的基础。 1.3 编程语言12编程语言： 可以通过类似于人类语言的“语言”来控制计算机，让计算机为我们做事情，这样的语言就叫做编程语言（Programming Language）。编程语言是用来控制计算机的一系列指令，它有固定的格式和词汇（不同编程语言的格式和词汇不一样），必须遵守。如今通用的编程语言有两种形式：汇编语言和高级语言。 语言类型 说明 汇编语言 汇编语言和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆。 高级语言 高级语言主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有C语言、C++、Java、C#、Python、PHP、JavaScript、Go语言、Objective-C、Swift等。 1.4 翻译器 高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器。翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化。 1.5 编程语言和标记语言区别 语言 说明 编程语言 编程语言有很强的逻辑和行为能力。在编程语言里, 你会看到很多 if else 、for 、while等具有逻辑性和行为能力的指令，这是主动的。 标记语言 标记语言（html）不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的, 他是被动的。 总结 计算机可以帮助人类解决某些问题 程序员利用编程语言编写程序发出指令控制计算机来实现这些任务 编程语言有机器语言、汇编语言、高级语言 高级语言需要一个翻译器转换为计算机识别的机器语言 编程语言是主动的有很强的逻辑性 2 - 计算机基础2.1 计算机组成 2.2 数据存储 计算机内部使用二进制 0 和 1来表示数据。 所有数据，包括文件、图片等最终都是以二进制数据（0 和 1）的形式存放在硬盘中的。 所有程序，包括操作系统，本质都是各种数据，也以二进制数据的形式存放在硬盘中。平时我们所说的安装软件，其实就是把程序文件复制到硬盘中。 硬盘、内存都是保存的二进制数据。 2.3 数据存储单位1大小关系：bit &lt; byte &lt; kb &lt; GB &lt; TB&lt;..... 位(bit)： 1bit 可以保存一个 0 或者 1 （最小的存储单位） 字节(Byte)：1B &#x3D; 8b 千字节(KB)：1KB &#x3D; 1024B 兆字节(MB)：1MB &#x3D; 1024KB 吉字节(GB): 1GB &#x3D; 1024MB 太字节(TB): 1TB &#x3D; 1024GB 2.4 程序运行 计算机运行软件的过程： 1. 打开某个程序时，先从硬盘中把程序的代码加载到内存中 2. CPU执行内存中的代码 注意：之所以要内存的一个重要原因，是因为 cpu运行太快了，如果只从硬盘中读数据，会浪费cpu性能，所以，才使用存取速度更快的内存来保存运行时的数据。（内存是电，硬盘是机械） 3 - 初始JavaScript3.1 JavaScript 是什么 JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思） 脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行 现在也可以基于 Node.js 技术进行服务器端编程 3.2 JavaScript的作用 表单动态校验（密码强度检测） （ JS 产生最初的目的 ） 网页特效 服务端开发(Node.js) 桌面程序(Electron) App(Cordova) 控制硬件-物联网(Ruff) 游戏开发(cocos2d-js) 3.3 HTML&#x2F;CSS&#x2F;JS 的关系 3.4 浏览器执行 JS 简介浏览器分成两部分：渲染引擎和 JS 引擎 浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。 3.5 JS 的组成 ECMAScript ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。 ​ ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。 更多参看MDN: MDN手册 DOM——文档对象模型 **文档对象模型**（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等） BOM——浏览器对象模型 **浏览器对象模型**(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。 3.6 JS 初体验JS 有3种书写位置，分别为行内、内嵌和外部。 行内式 1&lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert(&#x27;Hello World&#x27;)&quot; /&gt; 可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick 注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号 可读性差， 在html中编写JS大量代码时，不方便阅读； 引号易错，引号多层嵌套匹配时，非常容易弄混； 特殊情况下使用 内嵌式 123&lt;script&gt; alert(&#x27;Hello World~!&#x27;);&lt;/script&gt; 可以将多行JS代码写到 script 标签中 内嵌 JS 是学习时常用的方式 外部JS文件 1&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt; 利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用 引用外部 JS文件的 script 标签中间不可以写代码 适合于JS 代码量比较大的情况 4 - JavaScript注释4.1 单行注释为了提高代码的可读性，JS与CSS一样，也提供了注释功能。 JS中的注释主要有两种，分别是 单行注释 和 多行注释。 单行注释的注释方式如下： 1// 我是一行文字，不想被 JS引擎 执行，所以 注释起来 // 用来注释单行文字（ 快捷键 ctrl + / ） 4.2 多行注释多行注释的注释方式如下： 1234/* 获取用户年龄和姓名 并通过提示框显示出来*/ 1/* */ 用来注释多行文字（ 默认快捷键 alt + shift + a ） 快捷键修改为： ctrl + shift + &#x2F; vscode → 首选项按钮 → 键盘快捷方式 → 查找 原来的快捷键 → 修改为新的快捷键 → 回车确认 5 - JavaScript输入输出语句为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下： 方法 说明 归属 alert(msg) 浏览器弹出警示框 浏览器 console.log(msg) 浏览器控制台打印输出信息 浏览器 prompt(info) 浏览器弹出输入框，用户可以输入 浏览器 注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。 6 - 变量的概念6.1 什么是变量白话：变量就是一个装东西的盒子。 通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。 6.2 变量在内存中的存储 本质：变量是程序在内存中申请的一块用来存放数据的空间。类似我们酒店的房间，一个房间就可以看做是一个变量。 7 - 变量的使用 变量的声明 变量的赋值 7.1 声明变量12// 声明变量 var age; // 声明一个 名称为age 的变量 var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管 age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间 7.2 赋值1age = 10; // 给 age 这个变量赋值为 10 &#x3D; 用来把右边的值赋给左边的变量空间中 此处代表赋值的意思 变量值是程序员保存到变量空间里的值 7.3 变量的初始化12var age = 18; // 声明变量同时赋值为 18// 声明一个变量并赋值， 我们称之为变量的初始化。 7.4 变量语法扩展 更新变量 ​ 一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。 123var age = 18;age = 81; // 最后的结果就是81因为18 被覆盖掉了 同时声明多个变量 ​ 同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。 1var age = 10, name = &#x27;zs&#x27;, sex = 2; 声明变量特殊情况 情况 说明 结果 var age ; console.log (age); 只声明 不赋值 undefined console.log(age) 不声明 不赋值 直接使用 报错 age &#x3D; 10; console.log (age); 不声明 只赋值 10 7.5 变量命名规范规则： 由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name 严格区分大小写。var app; 和 var App; 是两个变量 不能 以数字开头。 18age 是错误的 不能 是关键字、保留字。例如：var、for、while 变量名必须有意义。 MMD BBD nl → age 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName 推荐翻译网站： 有道 爱词霸 8 - 数据类型8.1 数据类型简介 为什么需要数据类型 在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。 简单来说，数据类型就是数据的类别型号。比如姓名“张三”，年龄18，这些数据的类型是不一样的。 变量的数据类型 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定： 12var age = 10; // 这是一个数字型var areYouOk = &#x27;是的&#x27;; // 这是一个字符串 ​ 在代码运行时，变量的数据类型是由 JS引擎 根据 &#x3D; 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型： 12var x = 6; // x 为数字var x = &quot;Bill&quot;; // x 为字符串 数据类型的分类 JS 把数据类型分为两类： 简单数据类型 （Number,String,Boolean,Undefined,Null） 复杂数据类型 （object) 8.2 简单数据类型简单数据类型（基本数据类型） JavaScript 中的简单数据类型及其说明如下： 数字型 Number ​ JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。 12var age = 21; // 整数var Age = 21.3747; // 小数 数字型进制 最常见的进制有二进制、八进制、十进制、十六进制。 123456 // 1.八进制数字序列范围：0~7var num1 = 07; // 对应十进制的7var num2 = 019; // 对应十进制的19var num3 = 08; // 对应十进制的8 // 2.十六进制数字序列范围：0~9以及A~Fvar num = 0xA; 现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x 数字型范围 JavaScript中数值的最大和最小值 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 最小值：Number.MIN_VALUE，这个值为：5e-32 数字型三个特殊值 Infinity ，代表无穷大，大于任何数值 -Infinity ，代表无穷小，小于任何数值 NaN ，Not a number，代表一个非数值 isNaN 用来判断一个变量是否为非数字的类型，返回 true 或者 false 12345 var usrAge = 21;var isOk = isNaN(userAge); console.log(isNum); // false ，21 不是一个非数字var usrName = &quot;andy&quot;; console.log(isNaN(userName));// true ，&quot;andy&quot;是一个非数字 字符串型 String ​ 字符串型可以是引号中的任意文本，其语法为 双引号 “” 和 单引号’’ 1234var strMsg = &quot;我爱北京天安门~&quot;; // 使用双引号表示字符串var strMsg2 = &#x27;我爱吃猪蹄~&#x27;; // 使用单引号表示字符串// 常见错误var strMsg3 = 我爱大肘子; // 报错，没使用引号，会被认为是js代码，但js没有这些语法 ​ 因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。 字符串引号嵌套 ​ JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双) 1234var strMsg = &#x27;我是&quot;高帅富&quot;程序猿&#x27;; // 可以用&#x27;&#x27;包含&quot;&quot;var strMsg2 = &quot;我是&#x27;高帅富&#x27;程序猿&quot;; // 也可以用&quot;&quot; 包含&#x27;&#x27;// 常见错误var badQuotes = &#x27;What on earth?&quot;; // 报错，不能 单双引号搭配 字符串转义符 ​ 类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。 ​ 转义符都是 \\ 开头的，常用的转义符及其说明如下： 转义符 解释说明 \\n 换行符，n 是 newline 的意思 \\ \\ 斜杠 \\ &#39; ‘ 单引号 &quot; ”双引号 \\t tab 缩进 \\b 空格 ，b 是 blank 的意思 字符串长度 字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。 12var strMsg = &quot;我是帅气多金的程序猿！&quot;;alert(strMsg.length); // 显示 11 字符串拼接 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 &#x3D; 拼接之后的新字符串 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 123456//1.1 字符串 &quot;相加&quot;alert(&#x27;hello&#x27; + &#x27; &#x27; + &#x27;world&#x27;); // hello world//1.2 数值字符串 &quot;相加&quot;alert(&#x27;100&#x27; + &#x27;100&#x27;); // 100100//1.3 数值字符串 + 数值alert(&#x27;11&#x27; + 12); // 1112 + 号总结口诀：数值相加 ，字符相连 字符串拼接加强 12345console.log(&#x27;pink老师&#x27; + 18); // 只要有字符就会相连 var age = 18;console.log(&#x27;pink老师age岁啦&#x27;); // 这样不行哦console.log(&#x27;pink老师&#x27; + age); // pink老师18console.log(&#x27;pink老师&#x27; + age + &#x27;岁啦&#x27;); // pink老师18岁啦 经常会将字符串和变量来拼接，变量可以很方便地修改里面的值 变量是不能添加引号的，因为加引号的变量会变成字符串 如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间 布尔型Boolean ​ 布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。 ​ 布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。 12console.log(true + 1); // 2console.log(false + 1); // 1 Undefined和 Null ​ 一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果） 12345var variable;console.log(variable); // undefinedconsole.log(&#x27;你好&#x27; + variable); // 你好undefinedconsole.log(11 + variable); // NaNconsole.log(true + variable); // NaN ​ 一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null) 1234var vari = null;console.log(&#x27;你好&#x27; + vari); // 你好nullconsole.log(11 + vari); // 11console.log(true + vari); // 1 8.3 获取变量数据类型 获取检测变量的数据类型 ​ typeof 可用来获取检测变量的数据类型 12var num = 18;console.log(typeof num) // 结果 number ​ 不同类型的返回值 字面量 ​ 字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。 数字字面量：8, 9, 10 字符串字面量：’黑马程序员’, “大前端” 布尔字面量：true，false 8.4 数据类型转换​ 什么是数据类型转换？ ​ 使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换： 123转换为字符串类型转换为数字型转换为布尔型 转换为字符串 toString() 和 String() 使用方式不一样。 三种转换方式，更多第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。 转换为数字型（重点） 注意 parseInt 和 parseFloat 单词的大小写，这2个是重点 隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型 转换为布尔型 代表空、否定的值会被转换为 false ，如 ‘’、0、NaN、null、undefined 其余值都会被转换为 true 1234567console.log(Boolean(&#x27;&#x27;)); // falseconsole.log(Boolean(0)); // falseconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(null)); // falseconsole.log(Boolean(undefined)); // falseconsole.log(Boolean(&#x27;小白&#x27;)); // trueconsole.log(Boolean(12)); // true 9 - 解释型语言和编译型语言9.1 概述计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。 翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同 编译器是在代码执行之前进行编译，生成中间代码文件 解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器) 9.2 执行过程 类似于请客吃饭： 编译语言：首先把所有菜做好，才能上桌吃饭 解释语言：好比吃火锅，边吃边涮，同时进行 10 - 关键字和保留字10.1 标识符标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。 标识符不能是关键字或保留字。 10.2 关键字关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。 包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。 10.3 保留字保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。 包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。 注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。","path":"2022/04/02/JavaScript笔记（一）/","date":"04-02","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"css音频与html5新特性（八）","text":"目标 能够说出 3~5 个 HTML5 新增布局和表单标签 能够说出 CSS3 的新增特性有哪些 HTML5新特性概述HTML5 的新增特性主要是针对于以前的不足，增加了一些新的标签、新的表单和新的表单属性等。 这些新特性都有兼容性问题，基本是 IE9+ 以上版本的浏览器才支持，如果不考虑兼容性问题，可以大量使用这些新特性。 语义化标签 （★★）以前布局，我们基本用 div 来做。div 对于搜索引擎来说，是没有语义的 1234&lt;div class=“header”&gt; &lt;/div&gt;&lt;div class=“nav”&gt; &lt;/div&gt;&lt;div class=“content”&gt; &lt;/div&gt;&lt;div class=“footer”&gt; &lt;/div&gt; 发展到了HTML5后，新增了一些语义化标签，这样的话更加有利于浏览器的搜索引擎搜索，也方便了网站的seo（Search Engine Optimization，搜索引擎优化），下面就是新增的一些语义化标签 &lt;header&gt; 头部标签 &lt;nav&gt; 导航标签 &lt;article&gt; 内容标签 &lt;section&gt; 定义文档某个区域 &lt;aside&gt; 侧边栏标签 &lt;footer&gt; 尾部标签 多媒体标签多媒体标签分为 音频 audio 和视频 video 两个标签 使用它们，我们可以很方便的在页面中嵌入音频和视频，而不再去使用落后的flash和其他浏览器插件了。 因为多媒体标签的 属性、方法、事件比较多，因此我们需要什么功能的时候，就需要去查找相关的文档进行学习使用。 视频标签- video（★★★）基本使用当前 元素支持三种视频格式： 尽量使用 mp4格式 使用语法： 1&lt;video src=&quot;media/mi.mp4&quot;&gt;&lt;/video&gt; 兼容写法由于各个浏览器的支持情况不同，所以我们会有一种兼容性的写法，这种写法了解一下即可 12345&lt;video controls=&quot;controls&quot; width=&quot;300&quot;&gt; &lt;source src=&quot;move.ogg&quot; type=&quot;video/ogg&quot; &gt; &lt;source src=&quot;move.mp4&quot; type=&quot;video/mp4&quot; &gt; 您的浏览器暂不支持 &lt;video&gt; 标签播放视频&lt;/ video &gt; 上面这种写法，浏览器会匹配video标签中的source，如果支持就播放，如果不支持往下匹配，直到没有匹配的格式，就提示文本 video 常用属性 属性很多，有一些属性需要大家重点掌握： autoplay 自动播放 注意： 在google浏览器上面，默认禁止了自动播放，如果想要自动播放的效果，需要设置 muted属性 width 宽度 height 高度 loop 循环播放 src 播放源 muted 静音播放 示例代码： 1&lt;video src=&quot;media/mi.mp4&quot; autoplay=&quot;autoplay&quot; muted=&quot;muted&quot; loop=&quot;loop&quot; poster=&quot;media/mi9.jpg&quot;&gt;&lt;/video&gt; 音频标签- audio基本使用当前 元素支持三种视频格式： 尽量使用 mp3格式 使用语法： 1&lt;audio src=&quot;media/music.mp3&quot;&gt;&lt;/audio&gt; 兼容写法由于各个浏览器的支持情况不同，所以我们会有一种兼容性的写法，这种写法了解一下即可 12345&lt; audio controls=&quot;controls&quot; &gt; &lt;source src=&quot;happy.mp3&quot; type=&quot;audio/mpeg&quot; &gt; &lt;source src=&quot;happy.ogg&quot; type=&quot;audio/ogg&quot; &gt; 您的浏览器暂不支持 &lt;audio&gt; 标签。&lt;/ audio&gt; 上面这种写法，浏览器会匹配audio标签中的source，如果支持就播放，如果不支持往下匹配，直到没有匹配的格式，就提示文本 audio 常用属性 示例代码： 1&lt;audio src=&quot;media/music.mp3&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt; 小结 音频标签和视频标签使用方式基本一致 浏览器支持情况不同 谷歌浏览器把音频和视频自动播放禁止了 我们可以给视频标签添加 muted 属性来静音播放视频，音频不可以（可以通过JavaScript解决） 视频标签是重点，我们经常设置自动播放，不使用 controls 控件，循环和设置大小属性 新增的表单元素 （★★）在H5中，帮我们新增加了很多类型的表单，这样方便了程序员的开发 课堂案例：在这个案例中，熟练了新增表单的用法 案例代码： 123456789101112131415&lt;!-- 我们验证的时候必须添加form表单域 --&gt;&lt;form action=&quot;&quot;&gt; &lt;ul&gt; &lt;li&gt;邮箱: &lt;input type=&quot;email&quot; /&gt;&lt;/li&gt; &lt;li&gt;网址: &lt;input type=&quot;url&quot; /&gt;&lt;/li&gt; &lt;li&gt;日期: &lt;input type=&quot;date&quot; /&gt;&lt;/li&gt; &lt;li&gt;时间: &lt;input type=&quot;time&quot; /&gt;&lt;/li&gt; &lt;li&gt;数量: &lt;input type=&quot;number&quot; /&gt;&lt;/li&gt; &lt;li&gt;手机号码: &lt;input type=&quot;tel&quot; /&gt;&lt;/li&gt; &lt;li&gt;搜索: &lt;input type=&quot;search&quot; /&gt;&lt;/li&gt; &lt;li&gt;颜色: &lt;input type=&quot;color&quot; /&gt;&lt;/li&gt; &lt;!-- 当我们点击提交按钮就可以验证表单了 --&gt; &lt;li&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/form&gt; 常见输入类型 1text password radio checkbox button file hidden submit reset image 新的输入类型 类型很多，我们现阶段重点记忆三个： number tel search CSS3新特性CSS3 的现状 新增的CSS3特性有兼容性问题，ie9+才支持 移动端支持优于 PC 端 不断改进中 应用相对广泛 现阶段主要学习：新增选择器和盒子模型以及其他特性 CSS3 新增选择器CSS3 给我们新增了选择器，可以更加便捷，更加自由的选择目标元素。 属性选择器 结构伪类选择器 伪元素选择器 属性选择器（★★）属性选择器，按照字面意思，都是根据标签中的属性来选择元素 示例代码： 123456789101112 /* 只选择 type =text 文本框的input 选取出来 */input[type=text] &#123; color: pink;&#125;/* 选择首先是div 然后 具有class属性 并且属性值 必须是 icon开头的这些元素 */div[class^=icon] &#123; color: red;&#125;/* 选择首先是section 然后 具有class属性 并且属性值 必须是 data结尾的这些元素 */section[class$=data] &#123; color: blue;&#125; 属性选择器，按照字面意思，都是根据标签中的属性来选择元素 属性选择器可以根据元素特定属性的来选择元素。 这样就可以不用借助于类或者id选择器 属性选择器也可以选择出来自定义的属性 注意：类选择器、属性选择器、伪类选择器，权重为 10。 结构伪类选择器结构伪类选择器主要根据文档结构来选择器元素， 常用于根据父级选择器里面的子元素 E:first-child匹配父元素的第一个子元素E 123456789101112&lt;style&gt; ul li:first-child&#123; background-color: red; &#125; &lt;/style&gt; &lt;ul&gt; &lt;li&gt;列表项一&lt;/li&gt; &lt;li&gt;列表项二&lt;/li&gt; &lt;li&gt;列表项三&lt;/li&gt; &lt;li&gt;列表项四&lt;/li&gt; &lt;/ul&gt; E:last-child 则是选择到了最后一个li标签 E:nth-child(n)（★★★）匹配到父元素的第n个元素 匹配到父元素的第2个子元素 ul li:nth-child(2)&#123;&#125; 匹配到父元素的序号为奇数的子元素 ul li:nth-child(odd)&#123;&#125; odd 是关键字 奇数的意思（3个字母 ） 匹配到父元素的序号为偶数的子元素 ul li:nth-child(even)&#123;&#125; even（4个字母 ） 匹配到父元素的前3个子元素 ul li:nth-child(-n+3)&#123;&#125; 选择器中的 n 是怎么变化的呢？ 因为 n是从 0 ，1，2，3.. 一直递增 所以 -n+3 就变成了 n&#x3D;0 时 -0+3&#x3D;3 n&#x3D;1时 -1+3&#x3D;2 n&#x3D;2时 -2+3&#x3D;1 n&#x3D;3时 -3+3&#x3D;0 … 一些常用的公式： 公式不是死的，在这里列举出来让大家能够找寻到这个模式，能够理解代码，这样才能写出满足自己功能需求的代码 常用的结构伪类选择器是： nth-child(n) &#123;...&#125; E:nth-child 与 E:nth-of-type 的区别这里只讲明 E:nth-child(n) 和 E:nth-of-type(n) 的区别 剩下的 E:first-of-type E:last-of-type E:nth-last-of-type(n) 同理做推导即可 1234567891011121314151617181920&lt;style&gt; ul li:nth-child(2)&#123; /* 字体变成红色 */ color: red; &#125; ul li:nth-of-type(2)&#123; /* 背景变成绿色 */ background-color: green; &#125; &lt;/style&gt; &lt;ul&gt; &lt;li&gt;列表项一&lt;/li&gt; &lt;p&gt;乱来的p标签&lt;/p&gt; &lt;li&gt;列表项二&lt;/li&gt; &lt;li&gt;列表项三&lt;/li&gt; &lt;li&gt;列表项四&lt;/li&gt; &lt;/ul&gt; 也就是说： E:nth-child(n) 匹配父元素的第n个子元素E，也就是说，nth-child 对父元素里面所有孩子排序选择（序号是固定的） 先找到第n个孩子，然后看看是否和E匹配 E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E，也就是说，对父元素里面指定子元素进行排序选择。 先去匹配E ，然后再根据E 找第n个孩子 小结 结构伪类选择器一般用于选择父级里面的第几个孩子 nth-child 对父元素里面所有孩子排序选择（序号是固定的） 先找到第n个孩子，然后看看是否和E匹配 nth-of-type 对父元素里面指定子元素进行排序选择。 先去匹配E ，然后再根据E 找第n个孩子 关于 nth-child（n） 我们要知道 n 是从 0 开始计算的，要记住常用的公式 如果是无序列表，我们肯定用 nth-child 更多 类选择器、属性选择器、伪类选择器，权重为 10 伪元素选择器（★★★）伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构 示例demo 1234567891011121314151617181920&lt;style&gt; div &#123; width: 200px; height: 200px; background-color: pink; &#125; /* div::before 权重是2 */ div::before &#123; /* 这个content是必须要写的 */ content: &#x27;我&#x27;; &#125; div::after &#123; content: &#x27;小猪佩奇&#x27;; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt; 是 &lt;/div&gt;&lt;/body&gt; 注意： before 和 after 创建一个元素，但是属于行内元素 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素 语法： element::before {} before 和 after 必须有 content 属性 before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素伪元素选择器和标签选择器一样，权重为 1 应用场景一： 字体图标在实际工作中，字体图标基本上都是用伪元素来实现的，好处在于我们不需要在结构中额外去定义字体图标的标签，通过content属性来设置字体图标的 编码 步骤： 结构中定义div盒子 在style中先申明字体 @font-face 在style中定义after伪元素 div::after{…} 在after伪元素中 设置content属性，属性的值就是字体编码 在after伪元素中 设置font-family的属性 利用定位的方式，让伪元素定位到相应的位置；记住定位口诀：子绝父相 123456789101112131415161718192021222324252627282930313233343536&lt;head&gt; ... &lt;style&gt; @font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?1lv3na&#x27;); src: url(&#x27;fonts/icomoon.eot?1lv3na#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?1lv3na&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?1lv3na&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?1lv3na#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal; font-display: block; &#125; div &#123; position: relative; width: 200px; height: 35px; border: 1px solid red; &#125; div::after &#123; position: absolute; top: 10px; right: 10px; font-family: &#x27;icomoon&#x27;; /* content: &#x27;&#x27;; */ content: &#x27;\\e91e&#x27;; color: red; font-size: 18px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 应用场景二： 仿土豆效果把之前的代码进行了改善 步骤： 找到之前写过的仿土豆的结构和样式，拷贝到自己的页面中 删除之前的mask遮罩 在style中，给大的div盒子（类名叫tudou的），设置 before伪元素 这个伪元素充当的是遮罩的角色，所以我们不用设置内容，但是需要设置content属性，属性的值为空字符串 给这个遮罩设置宽高，背景颜色，默认是隐藏的 当鼠标移入到 div盒子时候，让遮罩显示，利用 hover 来实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;head&gt; ... &lt;style&gt; .tudou &#123; position: relative; width: 444px; height: 320px; background-color: pink; margin: 30px auto; &#125; .tudou img &#123; width: 100%; height: 100%; &#125; .tudou::before &#123; content: &#x27;&#x27;; /* 隐藏遮罩层 */ display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; &#125; /* 当我们鼠标经过了 土豆这个盒子，就让里面before遮罩层显示出来 */ .tudou:hover::before &#123; /* 而是显示元素 */ display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt; 应用场景三： 清除浮动回忆一下清除浮动的方式： 额外标签法也称为隔墙法，是 W3C 推荐的做法。 父级添加 overflow 属性 父级添加after伪元素 父级添加双伪元素 额外标签法也称为隔墙法，是 W3C 推荐的做法 注意： 要求这个新的空标签必须是块级元素 后面两种伪元素清除浮动算是第一种额外标签法的一个升级和优化 盒子模型（★★★）CSS3 中可以通过 box-sizing 来指定盒模型，有2个值：即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变 可以分成两种情况： box-sizing: content-box 盒子大小为 width + padding + border （以前默认的） box-sizing: border-box 盒子大小为 width 如果盒子模型我们改为了box-sizing: border-box ， 那padding和border就不会撑大盒子了（前提padding和border不会超过width宽度） 其他特性（★）图标变模糊 – CSS3滤镜filterfilter CSS属性将模糊或颜色偏移等图形效果应用于元素 语法： 1filter: 函数(); --&gt; 例如： filter: blur(5px); --&gt; blur模糊处理 数值越大越模糊 计算盒子宽度 – calc 函数calc() 此CSS函数让你在声明CSS属性值时执行一些计算 语法： 1width: calc(100% - 80px); 括号里面可以使用 + - * &#x2F; 来进行计算 CSS3 过渡（★★★）过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 过渡动画： 是从一个状态 渐渐的过渡到另外一个状态 可以让我们页面更好看，更动感十足，虽然 低版本浏览器不支持（ie9以下版本） 但是不会影响页面布局。 我们现在经常和 :hover 一起 搭配使用。 语法： 1transition: 要过渡的属性 花费时间 运动曲线 何时开始; 属性 ： 想要变化的 css 属性， 宽度高度 背景颜色 内外边距都可以 。如果想要所有的属性都变化过渡， 写一个all 就可以 花费时间： 单位是 秒（必须写单位） 比如 0.5s 运动曲线： 默认是 ease （可以省略） 何时开始：单位是 秒（必须写单位）可以设置延迟触发时间 默认是 0s （可以省略） 后面两个属性可以省略 记住过渡的使用口诀： 谁做过渡给谁加 过渡练习 步骤： 创建两个div的盒子，属于的嵌套关系，外层类名叫 bar，里层类名叫 bar_in 给外层的bar 这个盒子设置边框，宽高，圆角边框 给里层的bar_in 设置 初试的宽度，背景颜色，过渡效果 给外层的 bar 添加 hover事件，当触发了hover事件 让里层的bar_in 来进行宽度的变化 代码： 123456789101112131415161718192021222324252627&lt;head&gt; ... &lt;style&gt; .bar &#123; width: 150px; height: 15px; border: 1px solid red; border-radius: 7px; padding: 1px; &#125; .bar_in &#123; width: 50%; height: 100%; background-color: red; /* 谁做过渡给谁加 */ transition: all .7s; &#125; .bar:hover .bar_in &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;bar&quot;&gt; &lt;div class=&quot;bar_in&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 广义H5说法 了解狭隘H5 广义H5 广义的 HTML5 是 HTML5 本身 + CSS3 + JavaScript 。 这个集合有时称为 HTML5 和朋友，通常缩写为 HTML5 。 虽然 HTML5 的一些特性仍然不被某些浏览器支持，但是它是一种发展趋势。 HTML5 MDN 介绍：https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML","path":"2022/04/02/css-html笔记（八）/","date":"04-02","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"css精灵图与图标（七）","text":"1234567891011目标：​ 能够使用精灵图​ 能够使用字体图标​ 能够写出 CSS 三角​ 能够写出常见的 CSS 用户界面样式​ 能够说出常见的布局技巧 1. 精灵图（重点）1.1 为什么需要精灵图 一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。 为什么使用精灵图（目的）： ​ 为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧）。 核心原理： ​ 将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。 精灵图举例: 1.2 精灵图（sprites）的使用使用精灵图核心： 精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。 这个大图片也称为 sprites 精灵图 或者 雪碧图 移动背景图片位置， 此时可以使用 background-position 。 移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同 因为一般情况下都是往上往左移动，所以数值是负值。 使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。 使用精灵图核心总结： 精灵图主要针对于小的背景图片使用。 主要借助于背景位置来实现—background-position 。 一般情况下精灵图都是负值。（千万注意网页中的坐标： x轴右边走是正值，左边走是负值， y轴同理。） 1.3 案例：拼出自己名字1.3.1 案例效果 1.3.2 代码参考结构 1234&lt;span class=&quot;p&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;i&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;k&lt;/span&gt; 样式 12345678910111213141516171819202122232425262728span &#123; display: inline-block; background: url(images/abcd.jpg) no-repeat;&#125;.p &#123; width: 100px; height: 112px; /* background-color: pink; */ background-position: -493px -276px;&#125;.i &#123; width: 60px; height: 108px; /* background-color: pink; */ background-position: -327px -142px;&#125;.n &#123; width: 108px; height: 109px; /* background-color: pink; */ background-position: -215px -141px;&#125;.k &#123; width: 105px; height: 114px; /* background-color: pink; */ background-position: -495px -142px;&#125; 2. 字体图标2.1 字体图标的产生字体图标使用场景： 主要用于显示网页中通用、常用的一些小图标。 精灵图是有诸多优点的，但是缺点很明显。 1.图片文件还是比较大的。 2.图片本身放大和缩小会失真。 3.一旦图片制作完毕想要更换非常复杂。 此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。 字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。 2.2 字体图标的优点轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等 兼容性：几乎支持所有的浏览器，请放心使用 注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。 总结： 1.如果遇到一些结构和样式比较简单的小图标，就用字体图标。 2.如果遇到一些结构和样式复杂一点的小图片，就用精灵图。 使用步骤 字体图标是一些网页常见的小图标，我们直接网上下载即可。 因此使用可以分为： 1.字体图标的下载 2.字体图标的引入 （引入到我们html页面中） 3.字体图标的追加 （以后添加新的小图标） 2.3 字体图标的下载推荐下载网站： icomoon 字库 http://icomoon.io 推荐指数 ★★★★★ IcoMoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 阿里 iconfont 字库 http://www.iconfont.cn/ 推荐指数 ★★★★★ 这个是阿里妈妈 M2UX 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用 AI制作图标上传生成。 重点是，免费！ 2.4 字体图标的引入下载完毕之后，注意原先的文件不要删，后面会用。 把下载包里面的 fonts 文件夹放入页面根目录下 字体文件格式 不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件。 1).TureType( .ttf )格式.ttf字体是Windows和Mac的最常见的字体，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+； 2).Web Open Font Format( .woff )格式woff字体，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+； 3).Embedded Open Type( .eot )格式.eot字体是IE专用字体，支持这种字体的浏览器有IE4+； 4).SVG( .svg )格式.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+； 2.在 CSS 样式中全局声明字体： 简单理解把这些字体文件通过css引入到我们页面中。 一定注意字体文件路径的问题 1234567891011@font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?7kkyc2&#x27;); src: url(&#x27;fonts/icomoon.eot?7kkyc2#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?7kkyc2&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?7kkyc2&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?7kkyc2#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal;&#125; html 标签内添加小图标。 给标签定义字体。 123span &#123; font-family: &quot;icomoon&quot;;&#125; 注意：务必保证 这个字体和上面@font-face里面的字体保持一致 2.5 字体图标的追加如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标到原来的字体文件中。 把压缩包里面的 selection.json 从新上传，然后选中自己想要新的图标，从新下载压缩包，并替换原来的文件即可。 2.6 字体图标加载的原理： 3. CSS 三角3.1 介绍网页中常见一些三角形，使用 CSS 直接画出来就可以，不必做成图片或者字体图标。 一张图， 你就知道 CSS 三角是怎么来的了, 做法如下： 12345678div &#123; width: 0; height: 0; border: 50px solid transparent;border-color: red green blue black;line-height:0; font-size: 0;&#125; 我们用css 边框可以模拟三角效果 宽度高度为0 我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了 为了照顾兼容性 低版本的浏览器，加上 font-size: 0; line-height: 0; 3.2 案例：京东三角3.2.1效果图 3.2.2 代码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;CSS 三角制作&lt;/title&gt; &lt;style&gt; .box1 &#123; width: 0; height: 0; /* border: 10px solid pink; */ border-top: 10px solid pink; border-right: 10px solid red; border-bottom: 10px solid blue; border-left: 10px solid green; &#125; .box2 &#123; width: 0; height: 0; border: 50px solid transparent; border-left-color: pink; margin: 100px auto; &#125; .jd &#123; position: relative; width: 120px; height: 249px; background-color: pink; &#125; .jd span &#123; position: absolute; right: 15px; top: -10px; width: 0; height: 0; /* 为了照顾兼容性 */ line-height: 0; font-size: 0; border: 5px solid transparent; border-bottom-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;jd&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4. CSS 用户界面样式什么是界面样式 所谓的界面样式，就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 表单轮廓 防止表单域拖拽 4.1 鼠标样式 cursor123li &#123; cursor: pointer; &#125; 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 4.2 轮廓线 outline给表单添加 outline: 0; 或者 outline: none; 样式之后，就可以去掉默认的蓝色边框。 123input &#123; outline: none; &#125; 4.3 防止拖拽文本域 resize 实际开发中，我们文本域右下角是不可以拖拽的。 123textarea&#123; resize: none;&#125; vertical-align 属性应用 5. vertical-align 属性应用CSS 的 vertical-align 属性使用场景： 经常用于设置图片或者表单(行内块元素）和文字垂直对齐。 官方解释： 用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。 语法： 1vertical-align : baseline | top | middle | bottom 5.1 图片、表单和文字对齐图片、表单都属于行内块元素，默认的 vertical-align 是基线对齐。 此时可以给图片、表单这些行内块元素的 vertical-align 属性设置为 middle 就可以让文字和图片垂直居中对齐了。 5.2 解决图片底部默认空白缝隙问题bug：图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐。 主要解决方法有两种： 1.给图片添加 vertical-align:middle | top| bottom 等。 （提倡使用的） 2.把图片转换为块级元素 display: block; 6. 溢出的文字省略号显示6.1 单行文本溢出显示省略号 单行文本溢出显示省略号–必须满足三个条件： 12345678/*1. 先强制一行内显示文本*/ white-space: nowrap; （ 默认 normal 自动换行） /*2. 超出的部分隐藏*/ overflow: hidden; /*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; 6.2 多行文本溢出显示省略号（了解） 多行文本溢出显示省略号，有较大兼容性问题，适合于webKit浏览器或移动端（移动端大部分是webkit内核） 1234567891011121314/*1. 超出的部分隐藏 */overflow: hidden;/*2. 文字用省略号替代超出的部分 */text-overflow: ellipsis;/* 3. 弹性伸缩盒子模型显示 */display: -webkit-box;/* 4. 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 2;/* 5. 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical; 更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。 7. 常见布局技巧巧妙利用一个技术更快更好的布局： margin负值的运用 文字围绕浮动元素 行内块的巧妙运用 CSS三角强化 7.1. margin负值运用 1.让每个盒子margin 往左侧移动 -1px 正好压住相邻盒子边框 2.鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如果有定位，则加z-index） 7.2 文字围绕浮动元素效果 布局示意图 巧妙运用浮动元素不会压住文字的特性 7.3 行内块巧妙运用 页码在页面中间显示: 把这些链接盒子转换为行内块， 之后给父级指定 text-align:center; 利用行内块元素中间有缝隙，并且给父级添加 text-align:center; 行内块元素会水平会居中 7.4. CSS 三角强化 案例7.4.1 原理 12345678910111213141516171819202122232425&lt;style&gt; .box1 &#123; width: 0; height: 0; /* 把上边框宽度调大 */ /* border-top: 100px solid transparent; border-right: 50px solid skyblue; */ /* 左边和下边的边框宽度设置为0 */ /* border-bottom: 0 solid blue; border-left: 0 solid green; */ /* 1.只保留右边的边框有颜色 */ border-color: transparent red transparent transparent; /* 2. 样式都是solid */ border-style: solid; /* 3. 上边框宽度要大， 右边框 宽度稍小， 其余的边框该为 0 */ border-width: 100px 50px 0 0 ; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt; 7.4.2 案例效果 7.4.3 代码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;CSS三角强化的巧妙运用&lt;/title&gt; &lt;style&gt; .price &#123; width: 160px; height: 24px; line-height: 24px; border: 1px solid red; margin: 0 auto; &#125; .miaosha &#123; position: relative; float: left; width: 90px; height: 100%; background-color:red; text-align: center; color: #fff; font-weight: 700; margin-right: 8px; &#125; .miaosha i &#123; position: absolute; right: 0; top: 0; width: 0; height: 0; border-color: transparent #fff transparent transparent; border-style: solid; border-width: 24px 10px 0 0; &#125; .origin &#123; font-size: 12px; color: gray; text-decoration: line-through; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;price&quot;&gt; &lt;span class=&quot;miaosha&quot;&gt; ¥1650 &lt;i&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;origin&quot;&gt;¥5650&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 8. CSS 初始化不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS 初始化 简单理解： CSS初始化是指重设浏览器的样式。 (也称为CSS reset） 每个网页都必须首先进行 CSS初始化。 这里我们以 京东CSS初始化代码为例。 Unicode编码字体： 把中文字体的名称用相应的Unicode编码来代替，这样就可以有效的避免浏览器解释CSS代码时候出现乱码的问题。 比如： 黑体 \\9ED1\\4F53宋体 \\5B8B\\4F53微软雅黑 \\5FAE\\8F6F\\96C5\\9ED1","path":"2022/04/02/css笔记（七）/","date":"04-02","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"css定位与网页布局（六）","text":"目标 能够说出 为什么要用定位 能够说出 定位的 4 种分类 能够说出 4 种定位各自的特点 能够说出 为什么常用子绝父相布局 能够写出 淘宝轮播图布局 能够说出 显示隐藏的 3 种方式以及区别 1. 定位(position) 介绍1.1 为什么使用定位 我们先来看一个效果，同时思考一下用标准流或浮动能否实现类似的效果？ 场景1： 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子. 场景2：当我们滚动窗口的时候，盒子是固定屏幕某个位置的。 结论：要实现以上效果，标准流 或 浮动都无法快速实现 所以： 1.浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 2.定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。 1.2 定位组成定位：将盒子定在某一个位置，所以定位也是在摆放盒子， 按照定位的方式移动盒子 定位也是用来布局的，它有两部分组成： 定位 &#x3D; 定位模式 + 边偏移 定位模式 用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置。 1.2.1 边偏移（方位名词）边偏移 就是定位的盒子移动到最终位置。有 top、bottom、left 和 right 4 个属性。 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。 1.2.2 定位模式 (position)在 CSS 中，通过 position 属性定义元素的定位模式，语法如下： 123选择器 &#123; position: 属性值; &#125; 定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。 定位模式决定元素的定位方式 ，它通过 CSS 的 position 属性来设置，其值可以分为四个： 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 1.3 定位模式介绍1.3.1. 静态定位(static) - 了解 静态定位是元素的默认定位方式，无定位的意思。它相当于 border 里面的none，静态定位static，不要定位的时候用。 语法： 123选择器 &#123; position: static; &#125; 静态定位 按照标准流特性摆放位置，它没有边偏移。 静态定位在布局时我们几乎不用的 1.3.2. 相对定位(relative) - 重要 相对定位是元素在移动位置的时候，是相对于它自己原来的位置来说的（自恋型）。 语法： 123选择器 &#123; position: relative; &#125; 相对定位的特点：（务必记住） 1.它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）。 2.原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。 因此，相对定位并没有脱标。它最典型的应用是给绝对定位当爹的。。。 效果图： 1.3.3. 绝对定位(absolute) - 重要1.3.3.1 绝对定位的介绍 绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的（拼爹型）。 语法： 123选择器 &#123; position: absolute; &#125; 完全脱标 —— 完全不占位置； 父元素没有定位，则以浏览器为准定位（Document 文档）。 父元素要有定位 元素将依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 绝对定位的特点总结：（务必记住） 1.如果没有祖先元素或者祖先元素没有定位，则以浏览器为基准定位（Document 文档）。 2.如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。 3.绝对定位不再占有原先的位置。所以绝对定位是脱离标准流的。（脱标） 1.3.3.2 定位口诀 —— 子绝父相弄清楚这个口诀，就明白了绝对定位和相对定位的使用场景。 这个“子绝父相”太重要了，是我们学习定位的口诀，是定位中最常用的一种方式这句话的意思是：子级是绝对定位的话，父级要用相对定位。 因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。 ①子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。 ②父盒子需要加定位限制子盒子在父盒子内显示。 ③父盒子布局时，需要占有位置，因此父亲只能是相对定位。 这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。 总结： 因为父级需要占有位置，因此是相对定位， 子盒子不需要占有位置，则是绝对定位 当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。 疑问：为什么在布局时，子级元素使用绝对定位时，父级元素就要用相对定位呢？ 观察下图，思考一下在布局时，左右两个方向的箭头图片以及父级盒子的定位方式。 分析： 方向箭头叠加在其他图片上方，应该使用绝对定位，因为绝对定位完全脱标，完全不占位置。 父级盒子应该使用相对定位，因为相对定位不脱标，后续盒子仍然以标准流的方式对待它。 如果父级盒子也使用绝对定位，会完全脱标，那么下方的广告盒子会上移，这显然不是我们想要的。 结论：父级要占有位置，子级要任意摆放，这就是子绝父相的由来。 1.3.4. 固定定位(fixed) - 重要 固定定位是元素固定于浏览器可视区的位置。（认死理型） 主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变。 语法： 123选择器 &#123; position: fixed; &#125; 固定定位的特点：（务必记住）： 1.以浏览器的可视窗口为参照点移动元素。 跟父元素没有任何关系 不随滚动条滚动。 2.固定定位不在占有原先的位置。 固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。（认死理型） 完全脱标—— 完全不占位置； 只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置； 跟父元素没有任何关系；单独使用的 不随滚动条滚动。 固定定位举例： 提示：IE 6 等低版本浏览器不支持固定定位。 1.3.5 粘性定位(sticky) - 了解 粘性定位可以被认为是相对定位和固定定位的混合。 Sticky 粘性的 语法： 12345选择器 &#123; position: sticky; top: 10px; &#125; 粘性定位的特点： 1.以浏览器的可视窗口为参照点移动元素（固定定位特点） 2.粘性定位占有原先的位置（相对定位特点） 3.必须添加 top 、left、right、bottom 其中一个才有效 跟页面滚动搭配使用。 兼容性较差，IE 不支持。 1.3.6 定位总结 定位模式 是否脱标 移动位置 是否常用 static 静态定位 否 不能使用边偏移 很少 relative 相对定位 否 (占有位置) 相对于自身位置移动 基本单独使用 absolute绝对定位 是（不占有位置） 带有定位的父级 要和定位父级元素搭配使用 fixed 固定定位 是（不占有位置） 浏览器可视区 单独使用，不需要父级 sticky 粘性定位 否 (占有位置) 浏览器可视区 当前阶段少 一定记住 相对定位、固定定位、绝对定位 两个大的特点： 1. 是否占有位置（脱标否） 2. 以谁为基准点移动位置。 学习定位重点学会子绝父相。 注意： 边偏移需要和定位模式联合使用，单独使用无效； top 和 bottom 不要同时使用； left 和 right 不要同时使用。 2. 综合案例：学成在线-hot 模块添加2. 1 案例截图： 2.2 案例分析 一个大的 li 中包含 一个课程图片，课程介绍文字信息，还有hot的小图标； hot图片重叠在课程图片上面—— 脱标，不占位置，需要使用绝对定位； hot图片重叠在li的右上方 —— 需要使用边偏移确定准确位置。 2.3 案例小结 子绝父相 —— 子元素使用绝对定位，父元素使用相对定位； 与浮动的对比： 绝对定位：脱标，利用边偏移指定准确位置； 浮动：脱标，不能指定准确位置，让多个块级元素在一行显示。 课堂练习：模拟老师的随堂案例完成哈根达斯案例（5 分钟）。 结构修改： 123456789101112131415&lt;!-- 修改.box-bd里面的li标签内容，添加一个hot图标 --&gt;&lt;li&gt; &lt;!-- 添加hot小图片 --&gt; &lt;em&gt; &lt;img src=&quot;images/hot.png&quot; alt=&quot;&quot;&gt; &lt;/em&gt; &lt;img src=&quot;images/pic.png&quot; alt=&quot;&quot;&gt; &lt;h4&gt; Think PHP 5.0 博客系统实战项目演练 &lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt;&lt;/li&gt; 样式修改： 123456789101112131415161718192021222324252627.box-bd ul li &#123; /* 子绝父相 */ /* 父元素相对定位 */ position: relative; float: left; width: 228px; height: 270px; background-color: #fff; margin-right: 15px; margin-bottom: 15px; &#125;.box-bd ul li &gt; img &#123; width: 100%;&#125;.box-bd ul li h4 &#123; margin: 20px 20px 20px 25px; font-size: 14px; color: #050505; font-weight: 400;&#125;.box-bd ul li em &#123; /* 子元素绝对定位 */ position: absolute; top: 4px; right: -4px;&#125; 3. 定位(position)的应用3.1. 固定定位小技巧： 固定在版心左侧位置。小算法： 1.让固定定位的盒子 left: 50%. 走到浏览器可视区（也可以看做版心） 的一半位置。 2.让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走 版心宽度的一半位置 就可以让固定定位的盒子贴着版心右侧对齐了。 案例效果： 123456789101112131415161718192021222324&lt;style&gt; .w &#123; width: 800px; height: 1400px; background-color: pink; margin: 0 auto; &#125; .fixed &#123; position: fixed; /* 1. 走浏览器宽度的一半 */ left: 50%; /* 2. 利用margin 走版心盒子宽度的一半距离 */ margin-left: 405px; width: 50px; height: 150px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt; &lt;div class=&quot;w&quot;&gt;版心盒子 800像素&lt;/div&gt; &lt;/body&gt; 3.2. 堆叠顺序（z-index） 在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 z-index 来控制盒子的前后次序 (z轴) 语法： 123选择器 &#123; z-index: 1; &#125; z-index 的特性如下： 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位。 注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 应用 z-index 层叠等级属性可以调整盒子的堆叠顺序。如下图所示： 案例演示：堆叠顺序。 4. 定位(position)的拓展4.1 绝对定位的盒子居中 注意：加了绝对定位&#x2F;固定定位的盒子不能通过设置 margin: auto 设置水平居中。 但是可以通过以下计算方法实现水平和垂直居中，可以按照下图的方法： left: 50%;：让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;：让盒子向左移动自身宽度的一半。 盒子居中定位示意图 4.2 定位特殊特性绝对定位和固定定位也和浮动类似。 1.行内元素添加绝对或者固定定位，可以直接设置高度和宽度。 2.块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。 前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式: 可以用inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。 所以说， 一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。 4.3 脱标的盒子不会触发外边距塌陷浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的） 也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。 4.4 绝对定位（固定定位）会完全压住盒子浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片） 但是绝对定位（固定定位） 会压住下面标准流所有的内容。 浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素 5. 综合案例 - 淘宝轮播图(重点)5.1 效果图 5.2 布局分析 5.3 步骤 大盒子我们类名为： tb-promo 淘宝广告 里面先放一张图片。 左右两个按钮 用链接就好了。 左箭头 prev 右箭头 next ​ 左按钮样式（border-radius：左上，右上，右下，左下）， ​ 右按钮定位，提取左右按钮共同的样式代码（并集选择器） 底侧小圆点ul 继续做。 类名为 promo-nav ​ 中间长方形椭圆 ul的定位（水平居中，离底部15px） ​ 长方形需要五个小圆点，ul无序列表，li浮动，椭圆中小圆点的样式 5.4 知识点：圆角矩形设置4个角圆角矩形可以为4个角分别设置圆度， 但是是有顺序的 1234border-top-left-radius:20px;border-top-right-radius:20px;border-bottom-right-radius:20px;border-bottom-left-radius:20px; 如果4个角，数值相同 1border-radius: 15px; 里面数值不同，我们也可以按照简写的形式，具体格式如下: 1border-radius: 左上角 右上角 右下角 左下角; 还是遵循的顺时针。 5.5 代码参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;淘宝轮播图做法&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; li &#123; list-style: none; &#125; .tb-promo &#123; position: relative; width: 520px; height: 280px; background-color: pink; margin: 100px auto; &#125; .tb-promo img &#123; width: 520px; height: 280px; &#125; /* 并集选择器可以集体声明相同的样式 */ .prev, .next &#123; position: absolute; /* 绝对定位的盒子垂直居中 */ top: 50%; margin-top: -15px; /* 加了绝对定位的盒子可以直接设置高度和宽度 */ width: 20px; height: 30px; background: rgba(0, 0, 0, .3); text-align: center; line-height: 30px; color: #fff; text-decoration: none; &#125; .prev &#123; left: 0; /* border-radius: 15px; */ border-top-right-radius: 15px; border-bottom-right-radius: 15px; &#125; .next &#123; /* 如果一个盒子既有left属性也有right属性，则默认会执行 left属性 同理 top bottom 会执行 top */ right: 0; /* border-radius: 15px; */ border-top-left-radius: 15px; border-bottom-left-radius: 15px; &#125; .promo-nav &#123; position: absolute; bottom: 15px; left: 50%; margin-left: -35px; width: 70px; height: 13px; /* background-color: pink; */ background: rgba(255,255,255, .3); border-radius: 7px; &#125; .promo-nav li &#123; float: left; width: 8px; height: 8px; background-color: #fff; border-radius: 50%; margin: 3px; &#125; /* 不要忘记选择器权重的问题 */ .promo-nav .selected &#123; background-color: #ff5000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tb-promo&quot;&gt; &lt;img src=&quot;images/tb.jpg&quot; alt=&quot;&quot;&gt; &lt;!-- 左侧按钮箭头 --&gt; &lt;a href=&quot;#&quot; class=&quot;prev&quot;&gt; &amp;lt; &lt;/a&gt; &lt;!-- 右侧按钮箭头 --&gt; &lt;a href=&quot;#&quot; class=&quot;next&quot;&gt; &amp;gt; &lt;/a&gt; &lt;!-- 小圆点 --&gt; &lt;ul class=&quot;promo-nav&quot;&gt; &lt;li class=&quot;selected&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6. 网页布局总结通过盒子模型，清楚知道大部分html标签是一个盒子。 通过CSS浮动、定位 可以让每个盒子排列成为网页。 一个完整的网页，是标准流、浮动、定位一起完成布局的，每个都有自己的专门用法。 6.1. 标准流可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。 6.2. 浮动可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局 6.3. 定位定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。 7. 元素的显示与隐藏 目的（本质） ​ 让一个元素在页面中消失或者显示出来 场景 ​ 类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ 7.1. display 显示（重点） display 设置或检索对象是否及如何显示。 123display: none 隐藏对象display：block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： display 隐藏元素后，不再占有原来的位置。 后面应用及其广泛，搭配 JS 可以做很多的网页特效。实际开发场景： 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 7.2. visibility 可见性 （了解） visibility 属性用于指定一个元素应可见还是隐藏。 123visibility：visible ; 元素可视visibility：hidden; 元素隐藏 特点：visibility 隐藏元素后，继续占有原来的位置。（停职留薪） 如果隐藏元素想要原来位置， 就用 visibility：hidden 如果隐藏元素不想要原来位置， 就用 display：none (用处更多 重点） 7.3. overflow 溢出（重点） overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。 但是如果有定位的盒子， 请慎用overflow:hidden 因为它会隐藏多余的部分。 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。 7.4. 显示与隐藏总结 属性 区别 用途 display 显示 （重点） 隐藏对象，不保留位置 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 可见性 （了解） 隐藏对象，保留位置 使用较少 overflow 溢出（重点） 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 8 综合案例：土豆网鼠标经过显示遮罩8.1. 效果图 8.2. 案例目标1.练习元素的显示与隐藏 2.练习元素的定位 8.3. 核心原理原先半透明的黑色遮罩看不见， 鼠标经过 大盒子，就显示出来。 遮罩的盒子不占有位置， 就需要用绝对定位 和 display 配合使用。 8.4. 代码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;仿土豆网显示隐藏遮罩案例&lt;/title&gt; &lt;style&gt; .tudou &#123; position: relative; width: 444px; height: 320px; background-color: pink; margin: 30px auto; &#125; .tudou img &#123; width: 100%; height: 100%; &#125; .mask &#123; /* 隐藏遮罩层 */ display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; &#125; /* 当我们鼠标经过了 土豆这个盒子，就让里面遮罩层显示出来 */ .tudou:hover .mask &#123; /* 而是显示元素 */ display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","path":"2022/04/02/css笔记（六）/","date":"04-02","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"cssPS切图与属性书写顺序与设计步骤（五）","text":"1234567学习目标：​ 了解 PS切图​ 掌握 CSS属性书写顺序​ 掌握 学成在线案例 1. PS 切图1.1. 常见的图片格式 序号 格式 特点和常用的用途 1 jpg JPEG（.JPG）对色彩的信息保留较好，高清，颜色较多，我们产品类的图片 经常用jpg格式的 2 gif GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果, 实际 经常用于一些图片小动画效果 3 png png图像格式，是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景. 如果想要切成 背景透明的图片 ,请选择png格式. 4 psd PSD图像格式，Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计稿. 对我们前端人员来说,最大的优点,我们可以直接从上面复制文字,获得图片,还可以测量大小和距离. PS 有很多的切图方式：图层切图、切片切图、PS 插件切图等。 1.2. 图层切图简单版步骤： ​ ① 使用移动工具，点击需要的图片 ​ ② 查看右侧，找到图片对应的图层，右击图层 → 快速导出为 PNG 但是很多情况下,我们需要合并图层再导出: 步骤： ​ ① 选中需要的若干个图层：选择一个图层，再按住shift键，继续选第二个图层: ​ ② 图层菜单 → 合并图层(ctrl+e) ​ ​ ③ 查看右侧生成的新图层，在合并后的图层上，右击 → 快速导出为 PNG 1.3. 切片切图步骤： ​ ① 利用切片选中图片 ：利用切片工具手动划出 ​ ② 导出选中的图片：文件菜单 → 导出 → 存储为 web 设备所用格式 → 选择我们要的图片格式 → 存储 。 ​ 注意：保存的时候，要选“选中的切片”： 1.4. 插件切图1.4.1. 介绍Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。 1.4.2. 安装注意： cutterman插件要求你的ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。 查看 “窗口菜单”里面的“扩展功能”： ​ ① 如果是扩展功能的是灰色的，表示就是绿色版的，需要重新安装PS ​ ② 如果是扩展功能右侧是可以使用的，表示就是完整版的，可以安装cutterman插件快速切图 官网: http://www.cutterman.cn/zh/cutterman 当cutterman 安装完成后，重启PS，会发现扩展功能里面多了一个cutterman工具： 1.4.3 使用步骤 ​ ① 选择需要的图层 ​ ② 选择web端，点击web下面的下拉三角 ​ ③ 选择需要的图片格式 ​ ④ 设置好存储路径 ​ ⑤ 点击 “导出选中图层” 按钮 示意图： 2. CSS属性书写顺序（重点）生活中衡量一个人有气质： ​ 穿着打扮 举止言行 等等 编程中如何衡量一个人的代码能力： ​ 规范标准 优雅高质量 等等 一个词形容 专业 从代码中看出是否有经验.. 建议遵循以下顺序： 布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background 文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word 其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient … 举例： 12345678910111213.jdc &#123; display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, &#x27;Helvetica Neue&#x27;, Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); border-radius: 10px;&#125; 3. 学成在线页面制作页面展示： 学成在线，是典型的企业级网站。 学习学成网的目的，是为了整体感知企业级网站布局流程，带着大家复习以前的知识。 3.1. 前期准备素材 学成在线PSD源文件 开发工具 &#x3D; PS（切图） + sublime（代码） + chrome（测试） 3.2. 前期准备工作先把我们的前期准备工作做好， 我们本次采取结构与样式相分离思想。 创建 study 目录文件夹 (用于存放我们这个页面的相关内容)。 用vscode打开study目录文件夹. study 目录内新建 images 文件夹，用于保存图片。 新建首页文件 index.html（以后我们的网站首页统一命名规定为 index.html )。 新建 style.css 样式文件。我们本次采用外链样式表。 将样式引入到我们的 HTML 页面文件中。 样式表写入清除内外边距的样式，来检测样式表是否引入成功。 3.3. 页面布局整体思路为了提高网页制作的效率，布局时通常有以下的整体思路，具体如下： ​ 1.必须确定页面的版心（可视区），我们测量可得知。 ​ 2.分析页面中的行模块，以及每个行模块中的列模块。其实页面布局第一准则. ​ 3.一行中的列模块经常浮动布局, 先确定每个列的大小,之后确定列的位置. 页面布局第二准则 ​ 4.制作 HTML 结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要. ​ 5.所以, 先理清楚布局结构,再写代码尤为重要. 这需要我们多写多积累. 3.4. 页面制作确定版心： ​ 这个页面的版心是 1200像素 ，每个版心都要水平居中对齐，所以，我们可以定义版心为公共类： 1234.w &#123; width: 1200px; margin: auto;&#125; 3.4.1. header头部制作结构图如下： 1号是版心盒子 header 1200 * 42 的盒子水平居中对齐, 上下给一个margin值就好了。 版心盒子 里面包含 2号盒子 logo 图标 版心盒子 里面包含 3号盒子 nav 导航栏 版心盒子 里面包含 4号盒子 search 搜索框 版心盒子 里面包含 5号盒子 user 个人信息 注意，要求里面的 4个子盒子 必须都浮动 导航栏注意点: 实际开发中，重要的导航栏，我们不会直接用链接a ，而是用 li 包含链接(li+a)的做法 ​ 1.li+a 语义更清晰，一看这就是有条理的列表型内容。 ​ 2.如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名 注意: ​ 1.让导航栏一行显示, 给 li 加浮动, 因为 li 是块级元素, 需要一行显示. ​ 2.这个nav导航栏可以不给宽度,将来可以继续添加其余文字 ​ 3.因为导航栏里面文字不一样多,所以最好给链接 a 左右padding 撑开盒子,而不是指定宽度 4号盒子search的细节： ​ search 搜索框的意思: 一个 search 大盒子里面包含 2个 表单 ​ 技巧：input和button都，属于行内块元素，会有缝隙，使用浮动，可以去缝隙。 3.4.2. banner制作结构图如下： 1号盒子是通栏的大盒子banner， 不给宽度，给高度，给一个蓝色背景。 2号盒子是版心 w， 要水平居中对齐。 3号盒子版心内，左对齐 subnav 侧导航栏。 4号盒子版心内，右对齐 course 课程。 3.4.2.1 subnav 侧导航栏 (左侧的) subnav 盒子 背景色 黑色半透明 重要的导航栏，li 包 a ，行高45px a里面包含文字和span，span右浮动 当鼠标经过a ，a里面的内容（文字和span）变蓝色 3.4.2.2 course课程表模块 (右侧的)结构图如下： 1号盒子 是 228 * 300 的盒子 右浮动 注意 浮动的元素 不会有外边距塌陷的问题 1号盒子内 分为 上下 两个 子盒子 2号子盒子是 上部分 我们命名为 course-hd (hd 是 head 的简写 头部的意思，我们经常用) 3号子盒子是 下部分 我们命名为 course-bd (bd 是 body 的简写 主体的意思，我们经常用) 3.4.3. 精品推荐小模块结构图如下： 复习点： 因为里面三个盒子都要垂直居中，我们利用 继承性，给 最大的盒子 一个垂直居中的代码就好了，还记得 那些 样式可以继承吗？？？ font- line- text- color 大盒子水平居中 goods 精品 ，注意此处有个盒子阴影 1号盒子是标题 H3 左侧浮动 2号盒子 里面放链接 左侧浮动 goods-item 距离可以控制链接的 左右外边距（注意行内元素只给左右内外边距） 3号盒子 右浮动 mod 修改 3.4.4. 精品推荐大模块结构图如下： 1号盒子为最大的盒子 box 版心水平居中对齐 2号盒子为上面部分 box-hd – 里面 左侧标题H3 左浮动 右侧 链接 a 右浮动 3号盒子为底下部分 box-bd — 里面是无序列表 有 10个 小li 组成 小li 外边距的问题， 这里有个小技巧。 给box-hd 宽度为 1215 就可以一行装开5个 li了 复习点：我们用到清除浮动，因为 box-hd 里面的盒子个数不一定是多少，所以我们就不给高度了，但是里面的盒子浮动会影响下面的布局，因此需要清除浮动。 3.4.5. 底部模块制作结构图如下： 1号盒子通栏大盒子 底部 footer 给高度 底色是白色 2号盒子版心水平居中 3号盒子版权 copyright 左对齐 4号盒子 链接组 links 右对齐","path":"2022/04/02/css笔记（五）/","date":"04-02","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"css与PS切图（四）","text":"一、其他样式1、圆角边框在 CSS3 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。 border-radius 属性用于设置元素的外边框圆角。 语法： 1border-radius:length; 参数值可以为数值或百分比的形式 如果是正方形，想要设置为一个圆，把数值修改为高度或者宽度的一半即可，或者直接写为 50% 该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角 分开写：border-top-left-radius、border-top-right-radius、border-bottom-right-radius 和border-bottom-left-radius 兼容性 ie9+ 浏览器支持, 但是不会影响页面布局,可以放心使用 2、盒子阴影CSS3 中新增了盒子阴影，我们可以使用 box-shadow 属性为盒子添加阴影。语法： 1box-shadow: h-shadow v-shadow blur spread color inset; 3、文字阴影在 CSS3 中，我们可以使用 text-shadow 属性将阴影应用于文本。语法： 1text-shadow: h-shadow v-shadow blur color; 二、浮动1、传统网页布局的三种方式​ CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)： 普通流（标准流） 浮动 定位 这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。 注意：实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式） 。 2、标准流（普通流&#x2F;文档流）所谓的标准流: 就是标签按照规定好默认方式排列 块级元素会独占一行，从上向下顺序排列。常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。常用元素：span、a、i、em 等 以上都是标准流布局，我们前面学习的就是标准流，标准流是最基本的布局方式。 3、为什么需要浮动？​ 总结： 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式. ​ 浮动最典型的应用：可以让多个块级元素一行内排列显示。 ​ 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。 4、什么是浮动？​ float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。 语法： 1选择器 &#123; float: 属性值; &#125; 5、浮动特性加了浮动之后的元素,会具有很多特性,需要我们掌握的. 1、浮动元素会脱离标准流(脱标：浮动的盒子不再保留原先的位置) 2、浮动的元素会一行内显示并且元素顶部对齐 注意： ​ 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。 3、浮动的元素会具有行内块元素的特性 ​ 浮动元素的大小根据内容来决定 ​ 浮动的盒子中间是没有缝隙的 6、浮动元素经常和标准流父级搭配使用为了约束浮动元素位置, 我们网页布局一般采取的策略是: ​ 先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置. 符合网页布局第一准侧 三、常见网页布局浮动布局注意点1、浮动和标准流的父盒子搭配。 先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置 2、一个元素浮动了，理论上其余的兄弟元素也要浮动。 一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题。 浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流. 四、清除浮动1、为什么需要清除浮动？​ 由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。 2、清除浮动本质清除浮动的本质是清除浮动元素造成的影响：浮动的子标签无法撑开父盒子的高度 注意： 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。 父级有了高度，就不会影响下面的标准流了 3、清除浮动样式语法： 1选择器&#123;clear:属性值;&#125; 我们实际工作中， 几乎只用 clear: both; 清除浮动的策略是: 闭合浮动. 4、清除浮动的多种方式4.1、额外标签法额外标签法也称为隔墙法，是 W3C 推荐的做法。 使用方式： ​ 额外标签法会在浮动元素末尾添加一个空的标签。 1例如 &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;，或者其他标签（如&lt;br /&gt;等）。 ​ 优点： 通俗易懂，书写方便 ​ 缺点： 添加许多无意义的标签，结构化较差 ​ 注意： 要求这个新的空标签必须是块级元素。 总结: ​ 1、清除浮动本质是? ​ 清除浮动的本质是清除浮动元素脱离标准流造成的影响 ​ 2、清除浮动策略是? ​ 闭合浮动. 只让浮动在父盒子内部影响,不影响父盒子外面的其他盒子. ​ 3、额外标签法? ​ 隔墙法, 就是在最后一个浮动的子元素后面添 ​ 4、加一个额外标签, 添加 清除浮动样式. ​ 实际工作可能会遇到,但是不常用 4.2、父级添加 overflow 属性可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 。 例如： 1overflow:hidden | auto | scroll; 优点：代码简洁 缺点：无法显示溢出的部分 注意：是给父元素添加代码 4.3、父级添加after伪元素:after 方式是额外标签法的升级版。给父元素添加： 12345678910.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123; /* IE6、7 专有 */ *zoom: 1;&#125; 优点：没有增加标签，结构更简单 缺点：照顾低版本浏览器 代表网站： 百度、淘宝网、网易等 4.4、父级添加双伪元素给父元素添加 12345678910.clearfix:before,.clearfix:after &#123; content:&quot;&quot;; display:table; &#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯等 总结为什么需要清除浮动？ 父级没高度。 子盒子浮动了。 影响下面布局了，我们就应该清除浮动了。 五、PS 切图1、图层切图1最简单的切图方式：右击图层 → 导出 → 切片。 2、切片切图2.1、利用切片选中图片 1利用切片工具手动划出 2.2、导出选中的图片 1文件菜单 → 存储为 web 设备所用格式 → 选择我们要的图片格式 → 存储 。 3、PS插件切图​ Cutterman 是一款运行在 Photoshop 中的插件，能够自动将你需要的图层进行输出，以替代传统的手工 “导出 web 所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 官网：http://www.cutterman.cn/zh/cutterman 注意：Cutterman 插件要求你的 PS 必须是完整版，不能是绿色版，所以大家需要安装完整版本。","path":"2022/04/02/css笔记（四）/","date":"04-02","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"css盒子模型（三）","text":"一、css三大特性1、层叠性​ 相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题 ​ 层叠性原则: 样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式 样式不冲突，不会层叠 2、继承性​ CSS中的继承: 子标签会继承父标签的某些样式，如文本颜色和字号。恰当地使用继承可以简化代码，降低 CSS 样式的复杂性。 子元素可以继承父元素的样式： ​ 1（text-，font-，line-这些元素开头的可以继承，以及color属性） 继承性口诀：龙生龙，凤生凤，老鼠生的孩子会打洞 行高的继承性： 123body &#123; font:12px/1.5 Microsoft YaHei；&#125; 行高可以跟单位也可以不跟单位 如果子元素没有设置行高，则会继承父元素的行高为 1.5 此时子元素的行高是：当前子元素的文字大小 * 1.5 body 行高 1.5 这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高 3、优先级当同一个元素指定多个选择器，就会有优先级的产生。 选择器相同，则执行层叠性 选择器不同，则根据选择器权重执行 选择器优先级计算表格： 优先级注意点: 权重是有4组数字组成,但是不会有进位。 可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推.. 等级判断从左向右，如果某一位数值相同，则判断下一位数值。 可以简单记忆法: 通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为 1000, !important 无穷大. 继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。 权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。 div ul li ——&gt; 0,0,0,3 .nav ul li ——&gt; 0,0,1,2 a:hover —–—&gt; 0,0,1,1 .nav a ——&gt; 0,0,1,1 二、盒子模型1、网页布局的本质网页布局的核心本质： 就是利用 CSS 摆盒子。 网页布局过程： 先准备好相关的网页元素，网页元素基本都是盒子 Box 。 利用 CSS 设置好盒子样式，然后摆放到相应位置。 往盒子里面装内容 2、盒子模型（Box Model）组成​ 盒子模型：把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 ​ CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和 实际内容 3、边框（border）3.1、边框的使用1、border可以设置元素的边框。边框有三部分组成：边框宽度(粗细) 边框样式 边框颜色； 2、语法： 1border : border-width || border-style || border-color; 边框样式 border-style 可以设置如下值： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 3、边框的合写分写 边框简写： 1border: 1px solid red; 边框分开写法： 1border-top: 1px solid red; /* 只设定上边框， 其余同理 */ 3.2、表格的细线边框1、border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。 2、语法： 1border-collapse:collapse; collapse 单词是合并的意思 border-collapse: collapse; 表示相邻边框合并在一起 3.3、边框会影响盒子实际大小边框会额外增加盒子的实际大小。因此我们有两种方案解决： 测量盒子大小的时候,不量边框。 如果测量的时候包含了边框,则需要 width&#x2F;height 减去边框宽度 4、内边距（padding）4.1、内边距的使用方式1、padding 属性用于设置内边距，即边框与内容之间的距离。 2、语法： 合写属性： 分写属性： 4.2、内边距会影响盒子实际大小1、当我们给盒子指定 padding 值之后，发生了 2 件事情： 内容和边框有了距离，添加了内边距。 padding影响了盒子实际大小。 2、内边距对盒子大小的影响： 如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。 如何盒子本身没有指定width&#x2F;height属性, 则此时padding不会撑开盒子大小。 3、解决方案： ​ 如果保证盒子跟效果图大小保持一致，则让 width&#x2F;height 减去多出来的内边距大小即可。 5、外边距（margin）5.1、外边距的使用方式margin 属性用于设置外边距，即控制盒子和盒子之间的距离。 5.2、外边距典型应用外边距可以让块级盒子水平居中的两个条件： 盒子必须指定了宽度（width）。 盒子左右的外边距都设置为 auto 。 常见的写法，以下三种都可以： 123margin-left: auto; margin-right: auto;margin: auto;margin: 0 auto; 注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align:center 即可。 5.3、外边距合并使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。 主要有两种情况: 1、相邻块元素垂直外边距的合并 ​ 当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。 解决方案： 尽量只给一个盒子添加 margin 值。 2、嵌套块元素垂直外边距的塌陷 ​ 对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。 解决方案： 可以为父元素定义上边框。 可以为父元素定义上内边距。 可以为父元素添加 overflow:hidden。 5.4、清除内外边距​ 网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。 1234* &#123; padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */ &#125; ​ 注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了 三、PS 基本操作​ 因为网页美工大部分效果图都是利用 PS（Photoshop）来做的，所以以后我们大部分切图工作都是在 PS 里面完成。 ​ 部分操作： 文件→打开 ：可以打开我们要测量的图片 Ctrl+R：可以打开标尺，或者 视图→标尺 右击标尺，把里面的单位改为像素 Ctrl+ 加号(+)可以放大视图， Ctrl+ 减号(-)可以缩小视图 按住空格键，鼠标可以变成小手，拖动 PS 视图 用选区拖动 可以测量大小 Ctrl+ D 可以取消选区，或者在旁边空白处点击一下也可以取消选区","path":"2022/04/02/css笔记（三）/","date":"04-02","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"css复合选择器与各种标签和背景属性（二）","text":"一、emmet语法1、简介​ Emmet语法的前身是Zen coding,它使用缩写,来提高html&#x2F;css的编写速度, Vscode内部已经集成该语法。 ​ 快速生成HTML结构语法 ​ 快速生成CSS样式语法 2、快速生成HTML结构语法 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成 如果想要生成多个相同标签 加上 * 就可以了 比如 div*3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 如果生成的div 类名是有顺序的， 可以用 自增符号 $ 如果想要在生成的标签内部写内容可以用 { } 表示 3、快速生成CSS样式语法CSS 基本采取简写形式即可 ​ 比如 w200 按tab 可以 生成 width: 200px; ​ 比如 lh26px 按tab 可以生成 line-height: 26px; 4、快速格式化代码Vscode 快速格式化代码: shift+alt+f 也可以设置 当我们 保存页面的时候自动格式化代码: 1）文件 ——.&gt;【首选项】———-&gt;【设置】； 2）搜索emmet.include; 3）在settings.json下的【工作区设置】中添加以下语句： ​ “editor.formatOnType”: true, ​ “editor.formatOnSave”: true 二、css的复合选择器1、什么是复合选择器？​ 在 CSS 中，可以根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。​ 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的，可以更准确、更高效的选择目标元素（标签）​ 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等 2、后代选择器 (重要）定义： ​ 后代选择器又称为包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 语法： ​ 上述语法表示选择元素 1 里面的所有元素 2 (后代元素)。 语法说明： 元素1 和 元素2 中间用空格隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2 可以是儿子，也可以是孙子等，只要是元素1 的后代即可 元素1 和 元素2 可以是任意基础选择器 例子： 3、子选择器 (重要）定义： ​ 子元素选择器（子选择器）只能选择作为某元素的最近一级子元素。 ​ （简单理解就是选亲儿子元素） 语法： ​ 上述语法表示选择元素1 里面的所有直接后代(子元素) 元素2。 语法说明： 元素1 和 元素2 中间用 大于号 隔开 元素1 是父级，元素2 是子级，最终选择的是元素2 元素2 必须是亲儿子，其孙子、重孙之类都不归他管. 你也可以叫他 亲儿子选择器 例子： 4、并集选择器 (重要）定义： ​ 并集选择器可以选择多组标签, 同时为他们定义相同的样式，通常用于集体声明。并集选择器是各选择器通过英文逗号（,）连接而成，任何形式的选择器都可以作为并集选择器的一部分。 语法： ​ 上述语法表示选择元素1 和 元素2。 语法说明： 元素1 和 元素2 中间用逗号隔开 逗号可以理解为和的意思 并集选择器通常用于集体声明 例子： 5、伪类选择器定义： ​ 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。 语法： ​ 伪类选择器书写最大的特点是用冒号（:）表示，比如 :hover 、 :first-child 。 6、链接伪类选择器定义： ​ 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。 语法： ​ 伪类选择器书写最大的特点是用冒号（:）表示，比如 :hover 、 :first-child 。 ​ a:link 没有点击过的(访问过的)链接​ a:visited 点击过的(访问过的)链接​ a:hover 鼠标经过的那个链接​ a:active 鼠标正在按下还没有弹起鼠标的那个链接 链接伪类选择器注意事项 ​ 为了确保生效，请按照 LVHA 的循顺序声明 :link－:visited－:hover－:active。 ​ 记忆法：love hate 或者 lv 包包 hao 。 ​ 因为 a 链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。 链接伪类选择器实际工作开发中的写法： 7、:focus 伪类选择器定义： ​ :focus 伪类选择器用于选取获得焦点的表单元素。 ​ 焦点就是光标，一般情况 类表单元素才能获取 例子： 复合选择器总结 三、css的显示模式1、什么是元素的显示模式定义： ​ 元素显示模式就是元素（标签）以什么方式进行显示，比如自己占一行，比如一行可以放多个。 作用： ​ 网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。 2、元素显示模式的分类2.1、块元素常见的块元素： 1&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt; ​ 1&lt;div&gt; 标签是最典型的块元素。 块级元素的特点： 比较霸道，自己独占一行。 高度，宽度、外边距以及内边距都可以控制。 宽度默认是容器（父级宽度）的100%。 是一个容器及盒子，里面可以放行内或者块级元素。 注意： ​ 文字类的元素内不能放块级元素 12&lt;p&gt; 标签主要用于存放文字，因此 &lt;p&gt; 里面不能放块级元素，特别是不能放&lt;div&gt; 同理， &lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素 2.2、行内元素常见的行内元素： 1&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt; ​ 1&lt;span&gt; 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 行内元素的特点： 相邻行内元素在一行上，一行可以显示多个。 高、宽直接设置是无效的。 默认宽度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 注意： 链接里面不能再放链接 特殊情况链接 里面可以放块级元素，但是给 转换一下块级模式最安全 2.3、行内块元素常见的行内块标签： 1&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt; ​ 它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。 行内块元素的特点： 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。 一行可以显示多个（行内元素特点）。 默认宽度就是它本身内容的宽度（行内元素特点）。 高度，行高、外边距以及内边距都可以控制（块级元素特点）。 2.4、元素显示模式总结 ​ 学习元素显示模式的主要目的就是分清它们各自的特点，当我们网页布局的时候，在合适的地方用合适的标签元素。 3、元素显示模式的转换简单理解: ​ 一个模式的元素需要另外一种模式的特性​ 比如想要增加链接 的触发范围。 转换方式 转换为块元素：display:block; 转换为行内元素：display:inline; 转换为行内块：display: inline-block; 4、单行文字垂直居中的代码解决方案: ​ 让文字的行高等于盒子的高度 就可以让文字在当前盒子内垂直居中 简单理解: ​ 行高的上空隙和下空隙把文字挤到中间了， ​ 如果行高小于盒子高度,文字会偏上， ​ 如果行高大于盒子高度,则文字偏下。 四、css的背景通过 CSS 背景属性，可以给页面元素添加背景样式。背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。 1、背景颜色样式名称： ​ background-color 定义元素的背景颜色 使用方式： 其他说明： ​ 元素背景颜色默认值是 transparent（透明） 2、背景图片样式名称： ​ background-image 定义元素的背景图片 使用方式： 其他说明： ​ 实际开发常见于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置. (精灵图也是一种运用场景) ​ 注意：背景图片后面的地址，千万不要忘记加 URL， 同时里面的路径不要加引号。 3、背景平铺样式名称： ​ background-repeat 设置元素背景图像的平铺 使用方式： 4、背景图片位置样式名称： ​ background-position 属性可以改变图片在背景中的位置 使用方式： ​ ​ 参数代表的意思是：x 坐标和 y 坐标。 可以使用 方位名词 或者 精确单位 其他说明： 1、参数是方位名词 ​ 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致 ​ 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 2、参数是精确单位 ​ 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标 ​ 如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中 3、参数是混合单位 ​ 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标 5、背景图片固定样式名称： ​ background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动。 使用方式： ​ 其他说明： ​ background-attachment 后期可以制作视差滚动的效果。 6、背景样式合写背景合写样式： ​ background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置; 使用方式： 7、背景色半透明CSS3 提供了背景颜色半透明的效果。 使用方式： 最后一个参数是 alpha 透明度，取值范围在 0~1之间 我们习惯把 0.3 的 0 省略掉，写为 background: rgba(0, 0, 0, .3); 注意： 背景半透明是指盒子背景半透明，盒子里面的内容不受影响 CSS3 新增属性，是 IE9+ 版本浏览器才支持的，但是现在实际开发,我们不太关注兼容性写法了,可以放心使用 8、背景总结","path":"2022/04/02/css笔记（二）/","date":"04-02","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"css选择器和文本属性（一）","text":"###css简介 CSS 是层叠样式表 ( Cascading Style Sheets ) 的简称. 有时我们也会称之为 CSS 样式表或级联样式表。 CSS 是也是一种标记语言 CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。 CSS 让我们的网页更加丰富多彩，布局更加灵活自如。简单理解：CSS 可以美化 HTML , 让 HTML 更漂亮， 让页面布局更简单。 CSS 最大价值: 由 HTML 专注去做结构呈现，样式交给 CSS，即 结构 ( HTML ) 与样式( CSS ) 相分离 ###css语法规范 1.使用 HTML 时，需要遵从一定的规范，CSS 也是如此。要想熟练地使用 CSS 对网页进行修饰，首先需要了解CSS 样式规则。 2.CSS 规则由两个主要的部分构成：选择器以及一条或多条声明。 1.选择器是用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设置的具体样式 2.属性和属性值以“键值对”的形式出现 3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等 4.属性和属性值之间用英文“:”分开 5.多个“键值对”之间用英文“;”进行区分 例如： 123456789所有的样式，都包含在 &lt;style&gt; 标签内，表示是样式表。&lt;style&gt; 一般写到 &lt;/head&gt; 上方 &lt;head&gt; &lt;style&gt; h4 &#123; color: blue; font-size: 100px; &#125; &lt;/style&gt; &lt;/head&gt; ###css代码风格： 1234567891011121314151617181. 样式格式书写 1.紧凑格式 h3 &#123; color: deeppink;font-size: 20px;&#125; 2.展开格式 h3 &#123; color: pink; font-size: 20px; &#125; 强烈推荐第二种格式， 因为更直观。 2. 样式大小写风格 1.小写格式 h3 &#123; color: pink; &#125; 2.大写格式 H3 &#123; COLOR: PINK; &#125; ​ 强烈推荐样式选择器，属性名，属性值关键字全部使用小写字母，特殊情况除外。​ 3. 样式空格风格​​ ​ 1. h3 &#123; ​ color: pink; ​ &#125; ​ ​​ ​ 属性值前面，冒号后面，保留一个空格​ ​ 选择器（标签）和大括号中间保留空格​ ###css选择器的作用​ ​ 答：选择器(选择符)就是根据不同需求把不同的标签选出来这就是选择器的作用。 简单来说，就是选择标签用的。​ ​ ​ ​ 找到所有的 h1 标签。 选择器（选对人）​ ​ 设置这些标签的样式，比如颜色为红色（做对事）。​ ##css基础选择器 基础选择器又包括：标签选择器、类选择器、id 选择器和通配符选择器###标签选择器： 标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。语法： 标签选择器{ 属性：属性值 … }作用： 标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。###类选择器 如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器.语法： .类名 { 属性1: 属性值1; … } 结构需要用class属性来调用 class 类的意思 1&lt;div class=&quot;类名&quot;&gt; 变红色 &lt;/div&gt; ​ 1.如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。​ 2.类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个点“.”号显示。​ 3.类选择器使用“.”（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）。​ 4.可以理解为给这个标签起了一个名字，来表示。​ 5.长名称或词组可以使用中横线来为选择器命名。​ 6.不要使用纯数字、中文等命名，尽量使用英文字母来表示。​ 7.命名要有意义，尽量使别人一眼就知道这个类名的目的。​ 8.命名规范：见附件（ Web 前端开发规范手册.doc）###多类名选择器​ 我们可以给一个标签指定多个类名，从而达到更多的选择目的。 这些类名都可以选出这个标签.​ 简单理解就是一个标签有多个名字. 多类名的具体使用： 11. &lt;div class=&quot;red font20&quot;&gt;亚瑟&lt;/div&gt; ​ 注意：​ 1.在标签class 属性中写 多个类名​ 2.多个类名中间必须用空格分开​ 3.这个标签就可以分别具有这些类名的样式###id选择器：​ id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。​ HTML 元素以 id 属性来设置 id 选择器，CSS 中 id 选择器以“#” 来定义。​ 语法：​ #id名 {​ 属性1: 属性值1;​ …​ }​ 注意：id 属性只能在每个 HTML 文档中出现一次###id选择器和类选择器的区别：​ 1.类选择器（class）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用。​ 2.id 选择器好比人的身份证号码，全中国是唯一的，不得重复。​ 3.id 选择器和类选择器最大的不同在于使用次数上。​ 4.类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用。 ###通配符选择器： 语法： * { 属性1: 属性值1; … } 通配符选择器不需要调用， 自动就给所有的元素使用样式 特殊情况才使用，后面讲解使用场景(以下是清除所有的元素标签的内外边距,后期讲) * { margin: 0; padding: 0; }###选择器总结 ##css字体属性:###字体大小： CSS 使用 font-size 属性定义字体大小。语法： p { font-size: 20px; } 1.px（像素）大小是我们网页的最常用的单位 2.谷歌浏览器默认的文字大小为16px 3.不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小 4.可以给 body 指定整个页面文字的大小###字体粗细： CSS 使用 font-weight 属性设置文本字体的粗细。语法： 123p &#123; font-weight: bold; &#125; 1.学会让加粗标签（比如 h 和 strong 等) 不加粗，或者其他标签加粗2.实际开发时，我们更喜欢用数字表示粗细###字体样式： CSS 使用 font-style 属性设置文本的风格。语法： 123p &#123; font-style: normal; &#125; ###字体的综合写法 字体属性可以把以上文字样式综合来写, 这样可以更节约代码: body { font: font-style font-weight font-size&#x2F;line-height font-family;} 使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开 不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用 ###字体总结： ##css文本属性：###文本颜色： color 属性用于定义文本的颜色。语法： 123div &#123; color: red; &#125; 开发中最常用的是十六进制###文本对齐：text-align 属性用于设置元素内文本内容的水平对齐方式。语法： 123div &#123; text-align: center; &#125; ###修饰文本： 语法： 1 div { text-decoration：underline； } 重点记住如何添加下划线 ? 如何删除下划线 ? 其余了解即可. ###文本缩进语法： 123456div &#123; text-indent：20px； &#125; div &#123; text-indent：2em； &#125; em 是一个相对单位，就是当前元素（font-size) 1 个文字的大小, 如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。 ###行间距： line-height 属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离语法： 123p &#123; line-height: 26px; &#125; ​ 行高的文本分为 上间距 文本高度 下间距 &#x3D; 行间距##css样式表：​ 按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类：###行内样式表（行内式）​ 行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 CSS 样式。适合于修改简单样式.​ 语法：​ 1&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;青春不常在，抓紧谈恋爱&lt;/div&gt; ​ 1.style 其实就是标签的属性​ 在双引号中间，写法要符合 CSS 规范​ 2.可以控制当前的标签设置样式​ 3.由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用​ 4.使用行内样式表设定 CSS，通常也被称为行内式引入 ###内部样式表（嵌入式） 内部样式表（内嵌样式表）是写到html页面内部. 是将所有的 CSS 代码抽取出来，单独放到一个 标签中 语法： 123456&lt;style&gt; div &#123; color: red; font-size: 12px; &#125; &lt;/style&gt; ​ 1234567891011 1.&lt;style&gt; 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的&lt;head&gt;标签中 2.通过此种方式，可以方便控制当前整个页面中的元素样式设置 3.代码结构清晰，但是并没有实现结构与样式完全分离 4.使用内部样式表设定 CSS，通常也被称为嵌入式引入，这种方式是我们练习时常用的方式###外部样式表（链接式） 实际开发都是外部样式表. 适合于样式比较多的情况. 核心是:样式单独写到CSS 文件中，之后把CSS文件引入到 HTML 页面中使用. 引入外部样式表分为两步： 1. 新建一个后缀名为 .css 的样式文件，把所有 CSS 代码都放入此文件中。 2. 在 HTML 页面中，使用&lt;link&gt; 标签引入这个文件。 语法： &lt;link rel=&quot;stylesheet&quot; href=&quot;css文件路径&quot;&gt; ##Chrome调试工具： 1.Ctrl+滚轮 可以放大开发者工具代码大小。 2.左边是 HTML 元素结构，右边是 CSS 样式。 3.右边 CSS 样式可以改动数值（左右箭头或者直接输入）和查看颜色。 4.Ctrl + 0 复原浏览器大小。 5.如果点击元素，发现右侧没有样式引入，极有可能是类名或者样式引入错误。 6.如果有样式，但是样式前面有黄色叹号提示，则是样式属性书写错误。","path":"2022/04/02/css笔记（一）/","date":"04-02","excerpt":"","tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"HTML入门基础笔记(二)","text":"##第二天##表格###表格的主要作用 1.表格主要用于显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理 2.表格不是用来布局页面的,而是用来展示数据的。 ​ ​ 3.表格的具体用法：​ 123456789101112131415161718192021222324 &lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ... &lt;/table&gt;​ 1.&lt;table&gt; &lt;/table&gt; 是用于定义表格的标签。​ 2.&lt;tr&gt; &lt;/tr&gt; 标签用于定义表格中的行，必须嵌套在 &lt;table&gt; &lt;/table&gt;标签中。​ 3.&lt;td&gt; &lt;/td&gt; 用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中。​ 4.字母 td 指表格数据（table data），即数据单元格的内容。###表头单元格标签：​ 表头标签的具体实现： &lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; ... &lt;/tr&gt; ... &lt;/table&gt;​ 1.一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示.​ &lt;th&gt; 标签表示 HTML 表格的表头部分(table head 的缩写)​ 2.一般表头单元格位于表格的第一行或第一列，表头单元格里面的文本内容加粗居中显示.​ &lt;th&gt; 标签表示 HTML 表格的表头部分(table head 的缩写) ​ 5.表头单元格也是单元格，常用于表格第一行突出重要性，表头单元格里面的文字会加粗居中###表格属性：​ 1.表格标签这部分属性我们实际开发我们不常用，后面通过 CSS 来设置.​ ​ 完成下面综合案例： ​ ​ 思路： 先制作表格的结构. 1.第一行里面是 th 表头单元格 2.第二行开始里面是 td 普通单元格单元格里面可以放任何元素 3.文字链接图片等都可以 后书写表格属性 1.用到宽度高度边框cellpadding 和 cellspacing 2.表格浏览器中对齐 align###表格结构标签： 使用场景: 因为表格可能很长,为了更好的表示表格的语义，可以将表格分割成 表格头部和表格主体两大部分. 在表格标签中，分别用：标签 表格的头部区域、标签 表格的主体区域. 这样可以更好的分清表格结构。 总结: 1231. &lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。&lt;thead&gt; 内部必须拥有 &lt;tr&gt; 标签。 一般是位于第一行。 2. &lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体，主要用于放数据本体 。 3. 以上标签都是放在 &lt;table&gt;&lt;/table&gt; 标签中。 ​ ###合并单元格：​ 特殊情况下,可以把多个单元格合并为一个单元格, 这里同学们会最简单的合并单元格即可.​ 1.合并单元格方式​ 2.目标单元格​ 3.合并单元格的步骤​ 如下图： 合并单元格方式： 跨行合并：rowspan&#x3D;”合并单元格的个数” ​ 最上侧单元格为目标单元格, 写合并代码 跨列合并：colspan&#x3D;”合并单元格的个数” ​ 最左侧单元格为目标单元格, 写合并代码 合并单元格三步曲： 先确定是跨行还是跨列合并。 找到目标单元格. 写上合并方式 &#x3D; 合并的单元格数量。 比如： 1&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;。删除多余的单元格。 表格总结 ​ 表格学习整体可以分为三大部分: 表格的相关标签 ​ table thead body tr th td 表格的相关属性 ​ cellspacing cellpadding width height border 合并单元格 ​ rowspan collspan##列表​ 表格是用来显示数据的，那么列表就是用来布局的。​ 列表最大的特点就是整齐、整洁、有序，它作为布局会更加自由和方便。​ 根据使用情景不同，列表可以分为三大类：无序列表、有序列表和自定义列表。###无序： ​ &lt;ul&gt; 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 标签定义。无序列表的基本语法格式如下： 12345 &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ... &lt;/ul&gt; 无序列表的各个列表项之间没有顺序级别之分，是并列的。 中只能嵌套 ，直接在 标签中输入其他标签或者文字的做法是不被允许的。 &lt;li&gt; 与 &lt;/li&gt; 之间相当于一个容器，可以容纳所有元素。 123456789101112131415161718 4. 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置。###有序：​ ![](/images/有序.png)有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。在 HTML 标签中，&lt;ol&gt; 标签用于定义有序列表，列表排序以数字来显示，并且使用 &lt;li&gt; 标签来定义列表项。有序列表的基本语法格式如下：&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ... &lt;/ol&gt;1. &lt;ol&gt;&lt;/ol&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ol&gt;&lt;/ol&gt;标签中输入其他标签或者文字的做法是不被允许的。2. ``` &lt;li&gt; 与 &lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 有序列表会带有自己样式属性，但在实际使用时，我们会使用 CSS 来设置。 ###自定义： 自定义列表的使用场景:自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。在 HTML 标签中， 标签用于定义描述列表（或定义列表），该标签会与 （定义项目&#x2F;名字）和 （描述每一个项目&#x2F;名字）一起使用。语法如下： 名词1 名词1解释1 名词1解释2 ###列表总结 ##表单现实中的表单： ###为什么需要表单： 使用表单目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时就需要表单。###表单的组成： 在 HTML 中，一个完整的表单通常由表单域、表单控件（也称为表单元素）和 提示信息3个部分构成。###表单域： 123456 表单域是一个包含表单元素的区域。 在 HTML 标签中， &lt;form&gt; 标签用于定义表单域，以实现用户信息的收集和传递。 &lt;form&gt; 会把它范围内的表单元素信息提交给服务器. 实现代码： &lt;form action=“url地址” method=“提交方式” name=“表单域名称&quot;&gt;各种表单元素控件&lt;/form&gt;###表单域的常用属性： 基础班来说,我们暂时不用表单域提交数据,只需要写上 form 标签即可. 就业班等学习服务器编程阶段会重新讲解.这里只需要记住两点:1.在我们写表单元素之前,应该有个表单域把他们进行包含.2.表单域是 form标签. ###表单控件(表单元素) 1234567 &lt;input&gt; 表单元素在英文单词中，input 是输入的意思，而在表单元素中 &lt;input&gt; 标签用于收集用户信息。在 &lt;input&gt; 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）。&lt;input type=&quot;属性值&quot; /&gt;&lt;input /&gt; 标签为单标签 type 属性设置不同的属性值用来指定不同的控件类型 type 属性的属性值及其描述如下： 1除 type 属性外，&lt;input&gt;标签还有其他很多属性，其常用属性如下： ### 标签 123456789&lt;label&gt; 标签为 input 元素定义标注（标签）。&lt;label&gt; 标签用于绑定一个表单元素, 当点击&lt;label&gt; 标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验.语法： &lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; 核心： &lt;label&gt; 标签的 for 属性应当与相关元素的 id 属性相同。###&lt;select&gt; 表单元素使用场景: 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用&lt;select&gt;标签控件定义下拉列表。 12345678910语法： &lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ... &lt;/select&gt; 123456789101112131415161718192021222324252627282930313233###&lt;textarea&gt; 表单元素1. 使用场景: 当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时我们可以使用 &lt;textarea&gt; 标签。2. 在表单元素中，&lt;textarea&gt; 标签是用于定义多行文本输入的控件。3. 使用多行文本输入控件，可以输入更多的文字，该控件常见于留言板，评论。语法：​ &lt;textarea rows=&quot;3&quot; cols=&quot;20&quot;&gt; 文本内容 &lt;/textarea&gt;通过 &lt;textarea&gt; 标签可以轻松地创建多行文本输入框。cols=“每行中的字符数” ，rows=“显示的行数”，我们在实际开发中不会使用，都是用 CSS 来改变大小。表单元素我们学习了三大组 input 输入表单元素 select 下拉表单元素 textarea 文本域表单元素.这三组表单元素都应该包含在form表单域里面,并且有 name 属性.具体代码：​ &lt;form&gt;​ &lt;input type=“text &quot; name=“username”&gt;​ &lt;select name=&quot;jiguan&quot;&gt; ​ &lt;option&gt;北京&lt;/option&gt;​ &lt;/select&gt; ​ &lt;textarea name= &quot;message&quot;&gt;​ &lt;/textarea&gt;​ &lt;/form&gt; 有三个名字非常相似的标签:表单域 form 使用场景: 提交区域内表单元素给后台服务器文件域 file 是input type 属性值 使用场景: 上传文件文本域 textarea 使用场景: 可以输入多行文字, 比如留言板 网站介绍等…4. 我们当前阶段不需要提交表单元素,所以我们只负责表单元素的外观形态即可.","path":"2022/04/02/HTML笔记（二）/","date":"04-02","excerpt":"","tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"}]},{"title":"HTML入门基础笔记(一)","text":"##HTML第一天###我们接下来是进行的网页开发网页的相关概念: 什么是网页? 什么是HTML? 网页的形成?##什么是网页： 1.网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。 2.网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。###网页的组成： 1.网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。 ###什么是HTML： 1.HTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言。 2.HTML 不是一种编程语言，而是一种标记语言 (markup language)。 标记语言是一套标记标签 (markup tag)。###网页的总结： 1.网页是图片、链接、文字、声音、视频等元素组成, 其实就是一个html文件(后缀名为html) 2.网页生成制作: 有前端人员书写 HTML 文件, 然后浏览器打开,就能看到了网页. 3.HTML: 超文本标记语言, 用来制作网页的一门语言. 有标签组成的. 比如 图片标签 链接标签 视频标签等…###浏览器：常用的浏览器 IE 火狐 谷歌 苹果 欧朋 浏览器是网页显示、运行的平台。常用的浏览器有 IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。平时称为五大浏览器。 查看浏览器市场份额：http://tongji.baidu.com/data/browser浏览器内核（渲染引擎) 负责读取网页内容，整理讯息，计算网页的显示方式并显示页面 目前国内一般浏览器都会采用 Webkit&#x2F;Blink 内核，如 360、UC、QQ、搜狗等。##web标准： Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。###为什么需要Web标准： 浏览器不同，它们显示页面或者排版就有些许差异 遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：1.让 Web 的发展前景更广阔。2.内容能被更广泛的设备访问。3.更容易被搜寻引擎搜索。4.降低网站流量费用。5.使网站更易于维护。6.提高页面浏览速度。##web标准的构成：主要包括 《结构Structure》 、《表现（Presentation）》和《行为（Behavior）》三个方面。Web 标准提出的最佳体验方案：结构、样式、行为相分离。简单理解：结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中 1.结构类似身体 2.表现类似外观装饰 3.行为类似行为动作 4.相比较而言, 三者中结构最重要.##HTML标签的导读：###HTML语法规则： 1.HTML 标签是由尖括号包围的关键词，例如 。 2.HTML 标签通常是成对出现的，例如 和 ，我们称为双标签。 3.签。标签对中的第一个标签是开始标签，第二个标签是结束标签。有些特殊的标签必须是单个标签（极少情况），例如 ，我们称为单标签。###标签的关系： 双标签关系可以分为两类：包含关系和并列关系 包含标签： 12345&lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt;![](/images/大头儿子.png) 并列关系： &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; ###基本结构标签：​ 每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写###开发工具： VSCode的使用： 1. 双击打开软件。 2. 新建文件（Ctrl + N ）。 3. 保存（Ctrl + S ）, 注意移动要保存为 .html 文件 4. Ctrl + 加号键 ，Ctrl + 减号键 可以放大缩小视图 5. 生成页面骨架结构。 输入! 按下 Tab 键。 6. 利用插件在浏览器中预览页面：单击鼠标右键，在弹出窗口中点击“Open In Default Browser”。 **DOCTYPE** &lt;!DOCTYPE html&gt; 文档类型声明标签,告诉浏览器这个页面采取html5版本来显示页面. lang 语言种类 用来定义当前文档显示的语言。 en定义语言为英语 zh-CN定义语言为中文 简单来说,定义为en 就是英文网页, 定义为 zh-CN 就是中文网页 其实对于文档显示来说，定义成en的文档也可以显示中文，定义成zh-CN的文档也可以显示英文 这个属性对浏览器和搜索引擎(百度.谷歌等)还是有作用的字符集 1.字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字。 2.在标签内，可以通过 标签的 charset 属性来规定 HTML 文档应该使用哪种字符编码。 3. 4.charset 常用的值有：GB2312 、BIG5 、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符. 5.注意：上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用“UTF-8”编码，尽量统一写成标准的 “UTF-8”，不要写成 “utf8” 或 “UTF8”。###语义化标签： 学习标签是有技巧的，重点是记住每个标签的语义。简单理解就是指标签的含义，即这个标签是用来干嘛的。###什么是语义化标签： 根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰。 下图没有语义化标签：###添加语义标签：###常用的标签：###标题标签 标题标签 - （重要) 为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了 6 个等级的网页标题，即 12345678910111213&lt;h1&gt; - &lt;h6&gt; 。 具体实现： &lt;h1&gt; 我是一级标题 &lt;/h1&gt; 特点：​ 1.加了标题的文字会变的加粗，字号也会依次变大。 2. 一个标题独占一行。 来！！！左边。。。右边。。。中间： &lt;h1&gt;标题一共六级选,&lt;/h1&gt; &lt;h2&gt;文字加粗一行显。&lt;/h2&gt; &lt;h3&gt;由大到小依次减，&lt;/h3&gt; &lt;h4&gt;从重到轻随之变。&lt;/h4&gt; &lt;h5&gt;语法规范书写后，&lt;/h5&gt; &lt;h6&gt;具体效果刷新见。&lt;/h6&gt; ​ ###段落标签： 在网页中，要把文字有条理地显示出来，就需要将这些文字分段显示。在 HTML 标签中，标签用于定义段落，它可以将整个网页分为若干个段落。 具体实现： &lt;p&gt; 我是一个段落标签 &lt;/p&gt; ​ 特点：​ 1. 文本在一个段落中会根据浏览器窗口的大小自动换行。​ 2. 段落和段落之间保有空隙。​ ###换行标签​ 在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 。​​ ​ 具体实现： ​ &lt;br /&gt; ​ 特点： ​ 1. &lt;br /&gt; 是个单标签。 ​ 2. &lt;br /&gt; ​ ​ 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。 ###文本格式化标签： 在网页中，有时需要为文字设置粗体、斜体 或下划线等效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。 ###div和span标签 和 是没有语义的，它们就是一个盒子，用来装内容的。 具体实现： 这是头部 今日价格 特点： 1. 标签用来布局，但是现在一行只能放一个。 大盒子 2. 标签用来布局，一行上可以多个 。小盒子 ###图片标签： 在 HTML 标签中， 标签用于定义 HTML 页面中的图像。 具体实现： 解释： src 是标签的必须属性，它用于指定图像文件的路径和文件名。 所谓属性：简单理解就是属于这个图像标签的特性。 图像标签的其他属性： ​ 图像标签注意点： 1.图像标签可以拥有多个属性，必须写在标签名的后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.属性采取键值对的格式，即 key&#x3D;“value” 的格式，属性 &#x3D;“属性值”。 ###路径： 分为相对路径和绝对路径： 路径之相对路径 相对路径：以引用文件所在位置为参考基础，而建立出的目录路径。 这里简单来说，图片相对于 HTML 页面的位置 特点： 相对路径是从代码所在的这个文件出发，去寻找目标文件的，而我们这里所说的上一级 、下一级和同一级就是 图片相对于 HTML 页面的位置。 路径之绝对路径： 绝对路径： 1.是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。 例如，“D:\\web\\img\\logo.gif”或完整的网络地址“http://www.i” ###链接标签： 链接的语法格式 文本或图像 属性： 1.href：用于指定链接目标的url地址 2.target:用于指定链接页面的打开方式_self默认值 _blank新窗口打开 3.#：空链接 链接分类： 1.外部链接: 例如 &lt; a href&#x3D;”http:&#x2F;&#x2F; www.baidu.com “&gt; 百度。 2.内部链接:网站内部页面之间的相互链接. 直接链接内部页面名称即可，例如 &lt; a href&#x3D;”index.html”&gt; 首页 。 3.空链接: 如果当时没有确定链接目标时，&lt; a href&#x3D;”#”&gt; 首页 。 4.下载链接: 如果 href 里面地址是一个文件或者压缩包，会下载这个文件。 5.网页元素链接: 在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接. 6.锚点链接: 点我们点击链接,可以快速定位到页面中的某个位置. 在链接文本的 href 属性中，设置属性值为 #名字 的形式，如&lt;a href=&quot;#two&quot;&gt; 第2集 &lt;/a&gt; 找到目标位置标签，里面添加一个 id 属性 = 刚才的名字 ，如：&lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt; ###注释 如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。 HTML中的注释以“&lt;!--”开头，以“ --&gt;”结束。 具体实现： &lt;!-- 注释语句 --&gt; 快捷键: ctrl + / 一句话: 注释标签里面的内容是给程序猿看的, 这个代码是不执行不显示到页面中的. 添加注释是为了更好地解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的 ###特殊字符： 在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。 ![](/images/特殊字符.png) 重点记住：空格 、大于号、 小于号 这三个， 其余的使用很少，如果需要回头查阅即可。","path":"2022/04/02/HTML笔记（一）/","date":"04-02","excerpt":"","tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"}]}],"categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"}]}